[{"content":"Logback日志级别 日志级别指的是日志信息的类型，日志都会分级别，常见的日志级别如下（级别由低到高）：\n日志级别 说明 记录方式 trace 追踪，记录程序运行轨迹 【使用很少】 log.trace(\u0026quot;\u0026hellip;\u0026quot;) debug 调试，记录程序调试过程中的信息，实际应用中一般将其视为最低级别 【使用较多】 log.debug(\u0026quot;\u0026hellip;\u0026quot;) info 记录一般信息，描述程序运行的关键事件，如：网络连接、io操作 【使用较多】 log.info(\u0026quot;\u0026hellip;\u0026quot;) warn 警告信息，记录潜在有害的情况 【使用较多】 log.warn(\u0026quot;\u0026hellip;\u0026quot;) error 错误信息 【使用较多】 log.error(\u0026quot;\u0026hellip;\u0026quot;) 可以在配置文件logback.xml中，控制输出哪些类型的日志\n1 2 3 4 5 \u0026lt;!-- 日志输出级别 --\u0026gt; \u0026lt;root level=\u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34; /\u0026gt; \u0026lt;appender-ref ref=\u0026#34;FILE\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; 如上述代码，此时只会输出大于等于info级别的日志\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Slf4j public class LogTest { // private static final Logger log = LoggerFactory.getLogger(LogTest.class); @Test public void testLog(){ log.debug(\u0026#34;开始计算...\u0026#34;); int sum = 0; int[] nums = {1, 5, 3, 2, 1, 4, 5, 4, 6, 7, 4, 34, 2, 23}; for (int num : nums) { sum += num; } log.info(\u0026#34;计算结果为: {}\u0026#34;, sum); // {}为占位符 log.debug(\u0026#34;结束计算...\u0026#34;); log.trace(\u0026#34;trace .....\u0026#34;); log.warn(\u0026#34;warn ......\u0026#34;); log.error(\u0026#34;error .....\u0026#34;); } } // 在上述配置情况下，输出结果如下 // 2025-09-02 22:19:50.974 [main] INFO com.itheima.LogTest - 计算结果为: 101 // 2025-09-02 22:19:50.980 [main] WARN com.itheima.LogTest - warn ...... // 2025-09-02 22:19:50.980 [main] ERROR com.itheima.LogTest - error ..... 备注：如果有Lombok，可以直接在类前面加上@Slf4j，此时就可以省略private static final Logger log = LoggerFactory.getLogger(LogTest.class);\n","date":"2025-09-03T16:40:25+08:00","permalink":"https://IAmYuanyu.github.io/p/logback%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB/","title":"Logback日志级别"},{"content":"Logback快速入门 准备工作：引入logback的依赖(springboot项目中该依赖已传递)、配置文件logback.xml（放src/main/resources中）\nlogback.xml示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 控制台输出 --\u0026gt; \u0026lt;appender name=\u0026#34;STDOUT\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;encoder class=\u0026#34;ch.qos.logback.classic.encoder.PatternLayoutEncoder\u0026#34;\u0026gt; \u0026lt;!--格式化输出：%d 表示日期，%thread 表示线程名，%-5level表示级别从左显示5个字符宽度，%logger显示日志记录器的名称， %msg表示日志消息，%n表示换行符 --\u0026gt; \u0026lt;pattern\u0026gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;!-- 系统文件输出 --\u0026gt; \u0026lt;appender name=\u0026#34;FILE\u0026#34; class=\u0026#34;ch.qos.logback.core.rolling.RollingFileAppender\u0026#34;\u0026gt; \u0026lt;rollingPolicy class=\u0026#34;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\u0026#34;\u0026gt; \u0026lt;!-- 日志文件输出的文件名, %i表示序号 --\u0026gt; \u0026lt;FileNamePattern\u0026gt;D:/tlias-%d{yyyy-MM-dd}-%i.log\u0026lt;/FileNamePattern\u0026gt; \u0026lt;!-- 最多保留的历史日志文件数量 --\u0026gt; \u0026lt;MaxHistory\u0026gt;30\u0026lt;/MaxHistory\u0026gt; \u0026lt;!-- 最大文件大小，超过这个大小会触发滚动到新文件，默认为 10MB --\u0026gt; \u0026lt;maxFileSize\u0026gt;10MB\u0026lt;/maxFileSize\u0026gt; \u0026lt;/rollingPolicy\u0026gt; \u0026lt;encoder class=\u0026#34;ch.qos.logback.classic.encoder.PatternLayoutEncoder\u0026#34;\u0026gt; \u0026lt;!--格式化输出：%d 表示日期，%thread 表示线程名，%-5level表示级别从左显示5个字符宽度，%msg表示日志消息，%n表示换行符 --\u0026gt; \u0026lt;pattern\u0026gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50}-%msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;!-- 日志输出级别 --\u0026gt; \u0026lt;!-- 开启所有日志（ALL），关闭日志（OFF） --\u0026gt; \u0026lt;root level=\u0026#34;ALL\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34; /\u0026gt; \u0026lt;appender-ref ref=\u0026#34;FILE\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt; ","date":"2025-09-03T16:39:11+08:00","permalink":"https://IAmYuanyu.github.io/p/logback%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"Logback快速入门"},{"content":"@PathVariable属性值的可省略情况 正常情况下@PathVariable的属性值需要与路径参数一致\n但当服务端方法形参名与路径参数一致时，可省略@PathVariable的属性值\n1 2 3 4 5 @GetMapping(\u0026#34;/depts/{id}\u0026#34;) public Result getInfo(@PathVariable(\u0026#34;id\u0026#34;) Integer id) { System.out.println(\u0026#34;根据id查询部门信息：\u0026#34; + id); return Result.success(); } 比如上方代码中，路径参数与服务端方法形参名一致，可简写为下方代码\n1 2 3 4 5 @GetMapping(\u0026#34;/depts/{id}\u0026#34;) public Result getInfo(@PathVariable Integer id) { System.out.println(\u0026#34;根据id查询部门信息：\u0026#34; + id); return Result.success(); } ","date":"2025-09-02T21:24:41+08:00","permalink":"https://IAmYuanyu.github.io/p/@pathvariable%E5%B1%9E%E6%80%A7%E5%80%BC%E7%9A%84%E5%8F%AF%E7%9C%81%E7%95%A5%E6%83%85%E5%86%B5/","title":"@PathVariable属性值的可省略情况"},{"content":"@RequestParam的可省略情况 当前端传递的请求参数名与服务端方法形参名一致时，可以省略@RequestParam注解\n比如下方代码中，@RequestParam(\u0026ldquo;id\u0026rdquo;)可以省略\n1 2 3 4 5 @DeleteMapping(\u0026#34;/depts\u0026#34;) public Result delete(@RequestParam(\u0026#34;id\u0026#34;) Integer id) { System.out.println(\u0026#34;删除部门：\u0026#34; + id); return Result.success(); } ","date":"2025-09-02T21:22:55+08:00","permalink":"https://IAmYuanyu.github.io/p/@requestparam%E7%9A%84%E5%8F%AF%E7%9C%81%E7%95%A5%E6%83%85%E5%86%B5/","title":"@RequestParam的可省略情况"},{"content":"分层解耦 三层架构 在web开发中，一般有三层结构，从第一层到第三层分别为控制层（controller）、业务逻辑层（service）、数据访问层（dao）\ncontroller：控制层，接收前端发送的请求，对请求进行处理，并响应数据。\nservice：业务逻辑层，处理具体的业务逻辑。\ndao：数据访问层(Data Access Object)（持久层），负责数据访问操作，包括数据的增、删、改、查。\n三层拆分前的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @RestController //@Controller + @ResponseBody -----\u0026gt; 如果返回的是一个对象/集合 --\u0026gt; 转json --\u0026gt; 响应 public class UserController { @RequestMapping(\u0026#34;/list\u0026#34;) public List\u0026lt;User\u0026gt; list(){ //1. 读取user.txt中的数据 InputStream in = this.getClass().getClassLoader().getResourceAsStream(\u0026#34;user.txt\u0026#34;); ArrayList\u0026lt;String\u0026gt; lines = IoUtil.readUtf8Lines(in, new ArrayList\u0026lt;\u0026gt;()); //2. 业务逻辑处理: 解析数据, 封装User对象 --\u0026gt; List\u0026lt;User\u0026gt; List\u0026lt;User\u0026gt; userList = lines.stream().map(line -\u0026gt; { String[] split = line.split(\u0026#34;,\u0026#34;); return new User( Integer.parseInt(split[0]), split[1], split[2], split[3], Integer.parseInt(split[4]), LocalDateTime.parse(split[5], DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;))); }).toList(); //3. 响应数据 return userList; } 三层拆分后的代码：\nIOC与DI入门 如果按照刚刚Controller层中用new对象获取Service的方法，即\n1 private UserService userService = new UserServiceImpl(); 按照这种形式获取的话，如果有多个实现类需要切换就得频繁修改代码，为了解决这个问题，spring提供了控制反转和依赖注入\n控制反转： Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转\n依赖注入： Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入\nBean对象：IOC容器中创建、管理的对象，称之为Bean\n所以要将DAO和Service层的实现类交给IOC容器管理，并为Controller和Service注入运行时所依赖的对象\n要做到上述操作只需要在实现类上方加上@Component，在Service和DAO成员变量上方加上@Autowired即可，例如\n1 2 3 4 5 6 7 @Component //将当前类交给spring管理, 声明为spring容器中bean对象 public class UserDaoImpl implements UserDao ----------------------------------------------- @Autowired //应用程序运行时，会自动查询该类型的bean对象，并赋值给该成员变量 private UserService userService; IOC详解 常见Bean注解 要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一\n注解 说明 位置 @Component 声明 bean 的基础注解 不属于以下三类时，用此注解 @Controller @Component 的衍生注解 标注在控制层类上 @Service @Component 的衍生注解 标注在业务层类上 @Repository @Component 的衍生注解 标注在数据访问层类上（由于与 mybatis 整合，用的少） 在idea中查看Bean 在idea中，启动项目后可以查看Bean\n点击添加依赖后重新启动项目，再打开此处即可查看\nBean的默认名字为首字母小写的类名，可以自定义Bean的名字，如图所示\nBean的生效范围 前面声明bean的四大注解，要想生效，还需要被组件扫描注解@ComponentScan扫描。\n该注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 @SpringBootApplication 中，默认扫描的范围是启动类所在包及其子包。\nDI详解 基于@Autowired进行依赖注入的常见方式有如下三种：\n属性注入 1 2 3 4 5 6 @RestController public class UserController { @Autowired private UserService userService; //...... } 优点：代码简洁、方便快速开发\n缺点：隐藏了类之间的依赖关系、可能会破坏类的封装性\n构造函数注入（构造器注入） 1 2 3 4 5 6 7 8 9 @RestController public class UserController { private final UserService userService; @Autowired public UserController(UserService userService) { this.userService = userService; } } 优点：能清晰地看到类的依赖关系、提高了代码的安全性\n缺点：代码繁琐、如果构造参数过多，可能会导致构造函数臃肿\n注意：如果只有一个构造函数，@Autowired注解可以省略\nsetter注入 1 2 3 4 5 6 7 8 9 @RestController public class UserController { private UserService userService; @Autowired public void setUserService(UserService userService) { this.userService = userService; } } 优点：保持了类的封装性，依赖关系更清晰\n缺点：需要额外编写setter方法，增加了代码量\n@Autowired的注意事项 @Autowired注解默认是按照类型进行注入的，如果存在多个相同类型的Bean（多个实现类），将会报错，比如\n有三种解决方式：\n①**@Primary**\n1 2 3 4 5 6 7 8 @Primary @Service public class UserServiceImpl implements UserService { @Override public List\u0026lt;User\u0026gt; list() { // 省略 …… } } ②**@Qualifier**\n1 2 3 4 5 6 @RestController public class UserController { @Autowired @Qualifier(\u0026#34;userServiceImpl\u0026#34;) private UserService userService; } ③**@Resource**\n1 2 3 4 5 @RestController public class UserController { @Resource(name = \u0026#34;userServiceImpl\u0026#34;) private UserService userService; } @Resource 与 @Autowired区别 ?\n@Autowired是Spring框架提供的注解，而@Resource是JavaEE规范提供的\n@Autowired默认是按照类型注入，而@Resource默认是按照名称注入\n","date":"2025-08-10T12:36:49+08:00","permalink":"https://IAmYuanyu.github.io/p/%E5%88%86%E5%B1%82%E8%A7%A3%E8%80%A6/","title":"分层解耦"},{"content":"反射 概述 可以用反射来获取类中的所有信息\n获取class对象的三种方式 Class.forName(\u0026ldquo;全类名\u0026rdquo;) 全类名：包名 + 类名\n1 2 3 4 5 6 try { Class clazz = Class.forName(\u0026#34;com.yuanyu.Student\u0026#34;); System.out.println(clazz);// class com.yuanyu.Student } catch (ClassNotFoundException e) { throw new RuntimeException(e); } 在idea中，全类名可以直接复制\n类名.class 1 System.out.println(Student.class);// class com.yuanyu.Student 对象.getClass() 1 2 Student student = new Student(); System.out.println(student.getClass());// class com.yuanyu.Student 以上三种方式获取的字节码文件对象是一样的\n获取构造方法 获取构造方法 Class类中用于获取构造方法的方法\nConstructor\u0026lt;?\u0026gt;[] getConstructors()：返回所有公共构造方法对象的数组\nConstructor\u0026lt;?\u0026gt;[] getDeclaredConstructors()：返回所有构造方法对象的数组\nConstructor\u0026lt;T\u0026gt; getConstructor(Class\u0026lt;?\u0026gt;... parameterTypes)：返回单个公共构造方法对象\nConstructor\u0026lt;T\u0026gt; getDeclaredConstructor(Class\u0026lt;?\u0026gt;... parameterTypes)：返回单个构造方法对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 try { // 1. 获取class字节码文件对象 Class clazz = Class.forName(\u0026#34;com.yuanyu.Student\u0026#34;); // 2. 获取构造方法 // 2.1 获取所有public修饰的构造方法 Constructor[] constructors1 = clazz.getConstructors(); for (Constructor constructor : constructors1) { System.out.println(constructor); } System.out.println(\u0026#34;============================================\u0026#34;); // 2.2 获取所有构造方法（包括：private、protected等） Constructor[] constructors2 = clazz.getDeclaredConstructors(); for (Constructor constructor : constructors2) { System.out.println(constructor); } System.out.println(\u0026#34;============================================\u0026#34;); // 2.3 获取指定参数类型的public构造方法 Constructor constructor1 = clazz.getConstructor(String.class, int.class); System.out.println(constructor1); // Constructor constructor2 = clazz.getConstructor(int.class); // System.out.println(constructor2);// 会报错 Constructor constructor3 = clazz.getConstructor(); System.out.println(constructor3); System.out.println(\u0026#34;============================================\u0026#34;); // 2.4 获取指定参数类型的构造方法（包括：private、protected等） Constructor declaredConstructor = clazz.getDeclaredConstructor(int.class); System.out.println(declaredConstructor); } catch (Exception e) { e.printStackTrace(); } 输出结果：\n其中，我的Student类如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package com.yuanyu; public class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public Student() { } protected Student(String name) { this.name = name; } private Student(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 用途 获取构造方法的权限修饰符、参数列表等，具体不多赘述\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 try { Class clazz = Class.forName(\u0026#34;com.yuanyu.Student\u0026#34;); Constructor declaredConstructor = clazz.getDeclaredConstructor(String.class, int.class); // 获取权限修饰符 int modifiers = declaredConstructor.getModifiers(); System.out.println(modifiers);// 1(表示获取的这个构造是public的，具体数字表示什么，可以上网查阅) // 获取参数列表 Parameter[] parameters = declaredConstructor.getParameters(); for (Parameter parameter : parameters) { System.out.println(parameter); /** * 输出： * java.lang.String name * int age */ } // 暴力反射：临时修改访问权限，使得私有的构造方法可以被访问 // 如果是私有的构造方法，可以临时修改访问权限，使得私有的构造方法可以被访问 declaredConstructor.setAccessible(true); Student student = (Student) declaredConstructor.newInstance(\u0026#34;张三\u0026#34;, 18); System.out.println(student);// Student{name=\u0026#39;张三\u0026#39;, age=18}\t(如果输出的是com.yuanyu.Student@5a14e60d这种，说明没有重写toString方法) } catch (Exception e) { e.printStackTrace(); } 获取成员变量 获取成员变量 Class类中用于获取成员变量的方法\nField [] getFields ()：返回所有公共成员变量对象的数组 Field [] getDeclaredFields ()：返回所有成员变量对象的数组 Field getField (String name)：返回单个公共成员变量对象 Field getDeclaredField (String name)：返回单个成员变量对象\n获取成员变量的用法与获取构造方法的用法类似，此处省略\n用途 获取成员变量的修饰符、成员变量名等，具体不多赘述\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 try { Class clazz = Class.forName(\u0026#34;com.yuanyu.Student\u0026#34;); // 获取name字段 Field field = clazz.getDeclaredField(\u0026#34;name\u0026#34;); System.out.println(field);// private java.lang.String com.yuanyu.Student.name // 获取权限修饰符 int modifiers = field.getModifiers(); System.out.println(modifiers);// 2(表示获取的这个字段是private的，具体数字表示什么，可以上网查阅) // 获取成员变量名 String name = field.getName(); System.out.println(name);// name // 获取数据类型 Class\u0026lt;?\u0026gt; type = field.getType(); System.out.println(type);// class java.lang.String // 获取成员变量记录的值 Student student = new Student(\u0026#34;张三\u0026#34;, 18); field.setAccessible(true); Object o = field.get(student); System.out.println(o);// 张三 // 修改对象中记录的值 field.set(student, \u0026#34;李四\u0026#34;); System.out.println(student);// Student{name=\u0026#39;李四\u0026#39;, age=18} } catch (Exception e) { e.printStackTrace(); } 获取成员方法 获取成员方法 Method [] getMethods ()：返回所有公共成员方法对象的数组，包括继承的 Method [] getDeclaredMethods ()：返回所有成员方法对象的数组，不包括继承的 Method getMethod (String name, Class... parameterTypes)：返回单个公共成员方法对象\nMethod getDeclaredMethod(String name, Class... parameterTypes)：返回单个成员方法对象\n1 2 3 4 5 6 7 8 9 10 11 12 try { // 获取class字节码文件对象 Class clazz = Class.forName(\u0026#34;com.yuanyu.Student\u0026#34;); // 获取指定的单一方法 // 后面的参数可以区分不同的同名方法 Method eat1 = clazz.getDeclaredMethod(\u0026#34;eat\u0026#34;, String.class, int.class); System.out.println(eat1);// private void com.yuanyu.Student.eat(java.lang.String, int) Method eat2 = clazz.getDeclaredMethod(\u0026#34;eat\u0026#34;, String.class); System.out.println(eat2);// private void com.yuanyu.Student.eat(java.lang.String) } catch (Exception e) { e.printStackTrace(); } 为了演示，在Student类中加入了下面三个方法\n1 2 3 4 5 6 7 8 9 10 11 12 public String sleep() { System.out.println(\u0026#34;睡觉中~~~\u0026#34;); return \u0026#34;别打扰\u0026#34;; } private void eat(String food) throws IOException, InterruptedException, NullPointerException { System.out.println(\u0026#34;我要吃\u0026#34; + food); } private void eat(String food, int num) { System.out.println(\u0026#34;我要吃\u0026#34; + num + \u0026#34;个\u0026#34; + food); } 用途 获取方法的修饰符、名字、形参、返回值、抛出的异常等，具体不多赘述\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 try { // 获取class字节码文件对象 Class clazz = Class.forName(\u0026#34;com.yuanyu.Student\u0026#34;); // 获取指定的单一方法 Method method = clazz.getDeclaredMethod(\u0026#34;eat\u0026#34;, String.class); // 获取权限修饰符 int modifiers = method.getModifiers(); System.out.println(modifiers);// 2(表示获取的这个方法时private的，具体数字表示什么，可以上网查阅) // 获取方法名 String name = method.getName(); System.out.println(name);// eat // 获取形参 Parameter[] parameters = method.getParameters(); for (Parameter parameter : parameters) { System.out.println(parameter);// java.lang.String food } // 获取方法抛出的异常 Class\u0026lt;?\u0026gt;[] exceptionTypes = method.getExceptionTypes(); for (Class\u0026lt;?\u0026gt; exceptionType : exceptionTypes) { System.out.println(exceptionType); /** * 输出： * class java.io.IOException * class java.lang.InterruptedException * class java.lang.NullPointerException */ } /** 方法运行 * Method类中用于创建对象的方法 * Object invoke(Object obj, Object... args)：运行方法 * 参数一：调用方法的对象 * 参数二：调用方法时，需要传入的参数（如果没有就不写） * 返回值：被调用方法返回的值（如果没有就不写） */ Student student = new Student(); method.setAccessible(true); method.invoke(student, \u0026#34;肯德基\u0026#34;);// 我要吃肯德基 // 方法有返回值时，可以获取返回值 Object result = clazz.getDeclaredMethod(\u0026#34;sleep\u0026#34;).invoke(student);// 睡觉中~~~ System.out.println(result);// 别打扰 } catch (Exception e) { e.printStackTrace(); } 上述笔记基于黑马课程\n","date":"2025-08-03T19:07:17+08:00","permalink":"https://IAmYuanyu.github.io/p/java%E5%8F%8D%E5%B0%84/","title":"Java反射"},{"content":"Maven依赖下载不完整导致爆红 产生原因：由于网络原因，依赖没有下载完整导致的，在maven仓库中生成了xxx.lastUpdated文件，该文件不删除，不会再重新下载。\n解决方案：\n打开Maven的本地仓库\n然后在命令行中输入\n1 del /s *.lastUpdated 之后重新加载依赖，还爆红就重新打开idea\n","date":"2025-07-30T00:56:33+08:00","permalink":"https://IAmYuanyu.github.io/p/maven%E4%BE%9D%E8%B5%96%E4%B8%8B%E8%BD%BD%E4%B8%8D%E5%AE%8C%E6%95%B4%E5%AF%BC%E8%87%B4%E7%88%86%E7%BA%A2/","title":"Maven依赖下载不完整导致爆红"},{"content":"Maven依赖范围 依赖的jar包，默认情况下，可以在任何地方使用。可以通过 … 设置其作用范围。\n作用范围：\n主程序范围有效。（main文件夹范围内） 测试程序范围有效。（test文件夹范围内） 是否参与打包运行。（package指令范围内） scope值 主程序 测试程序 打包（运行） 范例 compile（默认） Y Y Y log4j test - Y - junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 例如，不设置时，junit单元测试可以在main文件夹下使用\n1 2 3 4 5 6 7 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.9.1\u0026lt;/version\u0026gt; \u0026lt;!--依赖范围--\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 加上test后，就只能在test文件夹下使用了\n加test前：\n加test后：\n","date":"2025-07-30T00:54:50+08:00","permalink":"https://IAmYuanyu.github.io/p/maven%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4/","title":"Maven依赖范围"},{"content":"Junit参数化测试/批量测试 参数化测试 @ParameterizedTest + @ValueSource搭配使用实现参数化测试\n@ParameterizedTest：参数化测试的注解 (可以让单个测试运行多次，每次运行时仅参数不同)\n@ValueSource：参数化测试的参数来源，赋予测试方法参数\n指定测试类、测试方法显示的名称 @DisplayName：指定测试类、测试方法显示的名称 （默认为类名、方法名）\n","date":"2025-07-30T00:52:50+08:00","permalink":"https://IAmYuanyu.github.io/p/junit%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95/","title":"Junit参数化测试"},{"content":"Maven依赖管理 导入依赖 输入需要导入的依赖后，点击右上角的刷新就会自动下载\n导入依赖后，点击idea右侧的maven，可以查看导入的依赖，导入的依赖可能会关联其他依赖\n排除依赖 排除时无需填写版本\n输入完需要排除的依赖后，刷新完依赖就消失了\n","date":"2025-07-30T00:49:06+08:00","permalink":"https://IAmYuanyu.github.io/p/maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/","title":"Maven依赖管理"},{"content":"下载压缩包 首先在官网：下载 Apache Maven – Maven下载bin.zip结尾的安装包\n配置本地仓库 将刚刚下载的压缩包解压到一个没有中文的路径后，在其根目录新建一个文件夹，我这里取名为mvn_repo\n然后打开创建文件夹，复制该文件夹的路径\n回到上一级目录（根目录），打开conf文件夹，打开settings.xml(建议用vs code之类的编译器)，然后如图操作（弄完记得保存）\n配置国内仓库地址 默认从国外的仓库下载文件，如果没法连接外网，建议配置一下国内镜像\n还是在刚刚的settings.xml文件中进行修改，修改完记得保存\n1 2 3 4 5 6 \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/nexus/content/groups/public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; 配置环境变量 为了能够在任意目录下执行Maven指令，需要配置Maven的环境变量\n验证是否配置成功 使用电脑快捷键Win+R，在弹出的窗口输入cmd，然后点击确定\n在命令行输入mvn -v，配置成功的话即可看见刚刚配置的maven的版本号\n","date":"2025-07-29T00:11:35+08:00","permalink":"https://IAmYuanyu.github.io/p/maven%E5%AE%89%E8%A3%85/","title":"Maven安装"},{"content":"Collections集合工具类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 1. 批量添加元素：Collections.addAll(集合, 需要添加的元素中间用逗号隔开) 2. 将集合中的元素顺序打乱：Collections.shuffle(集合) 3. 将集合中的元素按照默认规则排序：Collections.sort(集合) 可以在实体类中定义默认排序规则 public class Person implements Comparable\u0026lt;Person\u0026gt; { private String name; private int age; // 基础get、set等方法此处省略 @Override public int compareTo(Person o) { // this-o升序，o-this降序 return this.age - o.age; } } 4. 将集合中的元素按照指定规则排序：Collections.sort(集合, 规则) 例： ArrayList\u0026lt;Person\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new Person(\u0026#34;张三\u0026#34;, 45)); list.add(new Person(\u0026#34;李四\u0026#34;, 30)); list.add(new Person(\u0026#34;王五\u0026#34;, 35)); Collections.sort(list, new Comparator\u0026lt;Person\u0026gt;() { @Override public int compare(Person o1, Person o2) { // o1-o2升序, o2-o1降序 return o1.getAge() - o2.getAge(); } }); System.out.println(list); // [Person{name=\u0026#39;李四\u0026#39;, age=30}, Person{name=\u0026#39;王五\u0026#39;, age=35}, Person{name=\u0026#39;张三\u0026#39;, age=45}] Arrays中的静态方法 1 2 3 直接指定元素，存到list集合中： List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;); System.out.println(list); // [张三, 李四, 王五] ","date":"2025-07-20T23:45:49+08:00","permalink":"https://IAmYuanyu.github.io/p/collections%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB/","title":"Collections集合工具类"},{"content":"格式：\n1 2 3 for(元素类型 变量名:要遍历的集合名或数组名){ 变量名代表着每一个元素 } 快速生成：集合名或数组名.for\n例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;张三\u0026#34;); list.add(\u0026#34;李四\u0026#34;); list.add(\u0026#34;王五\u0026#34;); list.add(\u0026#34;赵六\u0026#34;); for (String name : list) { System.out.println(name); } System.out.println(\u0026#34;======================\u0026#34;); int[] arr = {1, 2, 3, 4, 5}; for (int num : arr) { System.out.println(num); } 输出结果： 张三 李四 王五 赵六 ====================== 1 2 3 4 5 注意：\n增强for遍历集合时，底层实现原理为迭代器 增强for遍历数组时，底层实现原理为普通for循环 因为遍历集合时原理为迭代器，所以在遍历集合的过程中不要随意修改集合长度，否则会出现并发修改异常\n","date":"2025-07-20T23:44:19+08:00","permalink":"https://IAmYuanyu.github.io/p/%E5%A2%9E%E5%BC%BAfor/","title":"增强for"},{"content":"左移：\u0026laquo; 运算规则：左移几位就相当于乘2的几次方\n注意：当左移的位数n超过该数据类型的总位数时，相当于左移（n - 总位数）位\n例：2 \u0026laquo; 2 ，相当于2乘2的平方，即2乘4，结果是8\n右移：\u0026raquo; 运算规则：类似于除以2的n次方，如果不能整除，向下取整\n例：10 \u0026raquo; 2\t，相当于10除以2的平方，即10除以4，为2.5，向下取整，结果为2\n​\t10 \u0026raquo; 3\t，相当于10除以2的三次方，即10除以8，为1.25，向下取整，结果为1\n","date":"2025-07-20T20:39:23+08:00","permalink":"https://IAmYuanyu.github.io/p/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E7%A1%80%E5%B7%A6%E7%A7%BB%E5%92%8C%E5%8F%B3%E7%A7%BB/","title":"位运算基础——左移和右移"},{"content":"使用ArrayList时，如果想要通过数值而不是索引进行删除，可以通过装箱解决\n1 2 3 4 5 ArrayList\u0026lt;Integer\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); list2.add(2); System.out.println(list2); list2.remove(Integer.valueOf(2)); System.out.println(list2); 如果直接输入想要删除的数值会被当成索引\n1 2 3 4 5 ArrayList\u0026lt;Integer\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); list2.add(2); System.out.println(list2); list2.remove(2); System.out.println(list2); ","date":"2025-07-20T20:34:16+08:00","permalink":"https://IAmYuanyu.github.io/p/integer%E7%B1%BB%E5%9E%8Barraylist%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E6%95%B0%E5%AD%97/","title":"Integer类型ArrayList删除指定数字"},{"content":" 本教程默认已经连上github仓库\n设置 vite.config.ts / vite.config.js 1 2 3 4 5 6 7 8 9 10 11 export default defineConfig({ base: \u0026#34;/你的仓库名/\u0026#34;, // 在此处加上base，其余部分不用改 plugins: [ vue() ], resolve: { alias: { \u0026#39;@\u0026#39;: fileURLToPath(new URL(\u0026#39;./src\u0026#39;, import.meta.url)) }, }, }) 将内容推送至gh-pages分支 首先确保package.json文件中scripts中有build\n1 2 3 4 5 \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vite build\u0026#34;, // 如果没有就手动加上 \u0026#34;preview\u0026#34;: \u0026#34;vite preview\u0026#34; }, 然后将源代码打包成生产环境可用的静态文件\n1 npm run build 再将生成的dist目录推送至gh-pages\n1 git subtree push --prefix dist origin gh-pages 在github上将gh-pages分支作为Github Page 打开项目所在的仓库，如图操作\n自动化部署 安装依赖\n1 npm install gh-pages --save-dev 回到package.json文件新增下方内容\n1 2 3 4 5 6 7 \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vite build\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;vite preview\u0026#34;, \u0026#34;predeploy\u0026#34;: \u0026#34;npm run build\u0026#34;, // 新增 \u0026#34;deploy\u0026#34;: \u0026#34;gh-pages -d dist\u0026#34; // 新增 } 之后更新在线网站只需要运行npm run deploy即可\n常见问题：刷新页面后404 解决方式：\n第一步：在项目根目录的public文件夹中添加404.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;script\u0026gt; sessionStorage.redirect = location.href; \u0026lt;/script\u0026gt; \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;0;URL=\u0026#39;/\u0026#39;\u0026#34;\u0026gt; \u0026lt;title\u0026gt;404\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 其中\u0026lt;meta http-equiv=\u0026quot;refresh\u0026quot; content=\u0026quot;0;URL='/'\u0026quot;\u0026gt;表示跳转到该网页0秒后跳转到完整根目录/\n这个跳转目录根据自己的情况进行更改，比如我有两个在线网页一个是我的博客https://iamyuanyu.github.io/，另一个是部署的项目https://iamyuanyu.github.io/项目名/，此时我的meta标签就需要改成\u0026lt;meta http-equiv=\u0026quot;refresh\u0026quot; content=\u0026quot;0;URL='/项目名'\u0026quot;\u0026gt;，不然我的项目刷新后会直接跳转到我的博客\n第二步：在项目根目录的index.html中添加以下内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; ··· \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ··· \u0026lt;/body\u0026gt; \u0026lt;!-- ***************需要添加的内容↓*************** --\u0026gt; \u0026lt;script\u0026gt; (function(){ var redirect = sessionStorage.redirect; delete sessionStorage.redirect; if (redirect \u0026amp;\u0026amp; redirect != location.href) { history.replaceState(null, null, redirect); } })(); \u0026lt;/script\u0026gt; \u0026lt;!-- ***************需要添加的内容↑*************** --\u0026gt; \u0026lt;/html\u0026gt; 如何重新部署即可\n","date":"2025-06-18T18:46:48+08:00","permalink":"https://IAmYuanyu.github.io/p/%E9%83%A8%E7%BD%B2vue3%E9%A1%B9%E7%9B%AE%E5%88%B0githubpages/","title":"部署Vue3项目到GithubPages"},{"content":"步骤： 确保当前分支的修改已提交 1 2 git add . # 暂存所有更改 git commit -m \u0026#34;你的提交信息\u0026#34; # 提交更改 切换到主分支（如 main 或 master） 1 git checkout main # 切换到主分支 合并当前分支的修改到主分支 1 git merge 你的当前分支名 # 例如我的分支叫yuanyu则 git merge yuanyu 推送到远程主分支 1 git push origin main # 推送主分支到远程 ","date":"2025-06-18T16:01:49+08:00","permalink":"https://IAmYuanyu.github.io/p/git%E5%B0%86%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E5%B9%B6%E5%85%A5%E4%B8%BB%E5%88%86%E6%94%AF/","title":"Git将当前分支并入主分支"},{"content":" 出现FTP报错“451 No mapping for the Unicode character”时可以尝试下方方法\n尝试切换为默认语言\n切换后在尝试传输文件看看\n本人自用：Xftp连接Windows虚拟机https://blog.csdn.net/kunkunowod/article/details/130231980\n","date":"2025-06-16T19:34:54+08:00","image":"https://IAmYuanyu.github.io/p/xftp%E4%BC%A0%E8%BE%93%E9%94%99%E8%AF%AF451/Snipaste_2025-06-16_19-36-48_hu_2110a7f15485a802.png","permalink":"https://IAmYuanyu.github.io/p/xftp%E4%BC%A0%E8%BE%93%E9%94%99%E8%AF%AF451/","title":"Xftp传输错误451"},{"content":"通过压缩图片来减小PPT大小 用电脑自带的PowerPoint打开PPT\n通过取消字体嵌入来减小PPT大小 点击左上角的“文件”\n","date":"2025-05-26T15:44:24+08:00","image":"https://IAmYuanyu.github.io/p/%E5%8E%8B%E7%BC%A9ppt%E5%A4%A7%E5%B0%8F/image-20250526154658931_hu_dd3c2b529d474a86.png","permalink":"https://IAmYuanyu.github.io/p/%E5%8E%8B%E7%BC%A9ppt%E5%A4%A7%E5%B0%8F/","title":"压缩PPT大小"},{"content":"找到项目中的main.js或main.ts\n方便复制：\n1 2 3 4 5 import zhCn from \u0026#39;element-plus/dist/locale/zh-cn.mjs\u0026#39; app.use(ElementPlus, { locale: zhCn }) ","date":"2025-05-25T16:34:14+08:00","image":"https://IAmYuanyu.github.io/p/%E5%B0%86elementplus%E9%BB%98%E8%AE%A4%E8%AF%AD%E8%A8%80%E8%AE%BE%E7%BD%AE%E4%B8%BA%E4%B8%AD%E6%96%87/Snipaste_2025-05-25_16-36-27_hu_62a592240d367f2b.png","permalink":"https://IAmYuanyu.github.io/p/%E5%B0%86elementplus%E9%BB%98%E8%AE%A4%E8%AF%AD%E8%A8%80%E8%AE%BE%E7%BD%AE%E4%B8%BA%E4%B8%AD%E6%96%87/","title":"将ElementPlus默认语言设置为中文"},{"content":"找到项目下的vite.config.js或vite.config.ts\n","date":"2025-05-25T15:06:25+08:00","image":"https://IAmYuanyu.github.io/p/%E5%88%A0%E9%99%A4%E5%88%9B%E5%BB%BAvue3%E5%90%8E%E9%A1%B5%E9%9D%A2%E4%B8%8B%E6%96%B9%E7%9A%84devtools/Snipaste_2025-05-25_15-11-59_hu_9b092747df9fc9ca.png","permalink":"https://IAmYuanyu.github.io/p/%E5%88%A0%E9%99%A4%E5%88%9B%E5%BB%BAvue3%E5%90%8E%E9%A1%B5%E9%9D%A2%E4%B8%8B%E6%96%B9%E7%9A%84devtools/","title":"删除创建vue3后页面下方的devtools"},{"content":"如果电脑有下载“火绒安全软件”，可以使用火绒进行电脑软件的联网控制\n火绒官网：https://www.huorong.cn/\n","date":"2025-05-17T13:51:37+08:00","permalink":"https://IAmYuanyu.github.io/p/%E4%BD%BF%E7%94%A8%E7%81%AB%E7%BB%92%E6%8E%A7%E5%88%B6%E8%BD%AF%E4%BB%B6%E8%81%94%E7%BD%91/","title":"使用火绒控制软件联网"},{"content":"如果同时使用@Data和@Builder，@Builder会生成全参构造方法，并覆盖默认的无参构造方法，导致框架无法通过反射调用无参构造方法\n解决方式：添加@NoArgsConstructor和@AllArgsConstructor\n1 2 3 4 @Builder @Data @NoArgsConstructor @AllArgsConstructor 注：@NoArgsConstructor和@AllArgsConstructor顺序不能反\n建议使用@Data时都带上@NoArgsConstructor和@AllArgsConstructor\n","date":"2025-04-17T17:51:11+08:00","permalink":"https://IAmYuanyu.github.io/p/@data%E4%B8%8E@builder%E8%81%94%E7%94%A8%E6%97%B6%E5%86%B2%E7%AA%81/","title":"@Data与@Builder联用时冲突"},{"content":" 创建一个.txt文件，将下方内容复制进去 1 2 3 4 5 6 7 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\.md] @=\u0026#34;Typora.exe\u0026#34; [HKEY_CLASSES_ROOT\\.md\\ShellNew] \u0026#34;NullFile\u0026#34;=\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\Typora.exe] @=\u0026#34;Markdown 文档\u0026#34; @=\u0026ldquo;Typora.exe\u0026rdquo; 是设置运行.md文件的程序，此处以Typora为例\n@=\u0026ldquo;Markdown 文档\u0026rdquo; 是设置右键新建.md文件时显示的名字，可以根据自己喜好取名\n然后修改后缀名 注：如果文件名不显示.txt不要直接手动加上，请自行上网查询如何显示文件后缀名，此处不过多赘述\n运行修改名字后的文件 运行成功后，之后右键新建就可以创建Markdown类型文件了 注：若依旧没有，可以打开任务管理器（快捷键Ctrl+Shift+Esc），然后如图操作\n","date":"2025-04-13T18:58:10+08:00","image":"https://IAmYuanyu.github.io/p/%E5%8F%B3%E9%94%AE%E5%88%9B%E5%BB%BAmarkdown%E6%96%87%E6%A1%A3/image-20250413190421751_hu_739f8ff5616abbd7.png","permalink":"https://IAmYuanyu.github.io/p/%E5%8F%B3%E9%94%AE%E5%88%9B%E5%BB%BAmarkdown%E6%96%87%E6%A1%A3/","title":"右键创建Markdown文档"},{"content":"修改本地 Git 的全局默认分支名称 在终端运行以下命令，设置 main 为未来所有新仓库的默认分支：\n1 git config --global init.defaultBranch main 验证配置是否生效：\n1 git config --global init.defaultBranch # 应输出 `main` 修改现有本地仓库的主分支名称 如果已有本地仓库仍在使用 master，需手动重命名分支：\n1 git branch -m master main # 将本地分支从 master 重命名为 main 更新远程仓库（如 GitHub） 情况1：远程仓库允许修改默认分支 推送 main 分支到远程：\n1 git push -u origin main 在远程仓库设置中将 main 设为默认分支：\nGitHub: Settings → General → Default branch → 选择 main → 点击 Update。 删除远程的 master 分支（可选）：\n1 git push origin --delete master 情况2：远程仓库不允许直接修改（如权限限制） 联系仓库管理员或按照团队流程提交分支修改请求。\n同步其他协作者的本地仓库 通知协作者运行以下命令更新其本地分支：\n1 2 3 4 git fetch origin git branch -m master main # 重命名本地分支 git branch -u origin/main main # 关联本地 main 到远程 main git remote set-head origin -a # 更新远程 HEAD 引用 验证修改是否成功 检查本地分支：\n1 git branch -a # 应显示 `main` 而非 `master` 检查远程默认分支：\n1 git remote show origin # 查看 HEAD branch 是否为 `main` ","date":"2025-04-11T00:24:59+08:00","permalink":"https://IAmYuanyu.github.io/p/github%E4%BB%93%E5%BA%93%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E5%88%86%E6%94%AF/","title":"Github仓库修改默认分支"},{"content":"\n问题如图，命名前段发送的请求地址与方法都没问题，状态码也是200，但还是报错，得不到响应，这可能是跨域问题，比如我后端地址为8080，但前端是3006，就产生了跨域问题\n解决方式 在后端项目创建一个文件，建议src/main/java/com/yourpackage/config/CorsConfig.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.CorsRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/**\u0026#34;) .allowedOrigins(\u0026#34;http://localhost:前端端口\u0026#34;) // 前端地址 .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;) .allowedHeaders(\u0026#34;*\u0026#34;) .allowCredentials(true); } } 将上述代码复制进入刚刚创建的文件中，如果像直接允许所有跨域访问可以用下面的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.CorsRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/**\u0026#34;) // 允许所有路径 .allowedOrigins(\u0026#34;*\u0026#34;) // 允许所有来源（注意：不能和 allowCredentials 同时使用） .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;) .allowedHeaders(\u0026#34;*\u0026#34;) .maxAge(3600); // 预检请求缓存时间（秒） } } ","date":"2025-04-06T20:45:47+08:00","image":"https://IAmYuanyu.github.io/p/springboot%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20250406203609910_hu_4ac9865150175128.png","permalink":"https://IAmYuanyu.github.io/p/springboot%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","title":"Springboot解决跨域问题"},{"content":"VScode中间正上方的搜索框输入%后，再输入想要找到的内容，会直接搜索整个项目中所有文件的内容，符合目标的内容会直接标出来文件名与文件位置\n之前真不知道可以全局查找内容，看别人的项目都是根据文件名猜对应内容，然后一个个找\n","date":"2025-04-06T18:09:30+08:00","permalink":"https://IAmYuanyu.github.io/p/%E7%94%A8vscode%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87/","title":"用VScode快速定位目标"},{"content":"明明编写代码的时候Lombok可以正常使用，idea也可以进行代码补全，但运行后又提示找不到方法符号\n未启用注解处理 注意选择自己的项目，然而我不是这里报错\n未安装Lombok插件 除非是上古版本idea，不然一般都是自带好的，我也不是这里出问题\npom.xml中依赖缺失 这些一般是用Spring Initializer自动生成的，一般不会出问题，至少我不是这里出错\nidea缓存问题 我依旧不是这个问题，当时我都快摆烂了，上网查了半天就这些方法\nMaven出问题 头疼了两天，之后尝试clean一下Maven结果就可以了\n","date":"2025-04-04T16:54:47+08:00","permalink":"https://IAmYuanyu.github.io/p/lombok%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/","title":"Lombok编译报错"},{"content":"将本地仓库同步远程仓库 push代码的时候可能出现下方情况\ngit fetch + git rebase（推荐） 出现上面情况后输入下方指令\n1 2 git fetch origin # 获取远程更新 git rebase origin/要同步的分支名 # 保持线性历史 比如要同步主分支可以如下输入：\n1 2 git fetch origin git rebase origin/master # 有的主分支用main 此时在尝试push代码应该就可以了\ngit pull（不推荐） 此时可以使用git pull origin \u0026lt;分支名\u0026gt;\n如要与主分支同步，可输入下方指令\n1 git pull origin master 现在可以再push一下代码，应该就可以正常提交了\n","date":"2025-04-02T21:33:26+08:00","permalink":"https://IAmYuanyu.github.io/p/%E5%90%8C%E6%AD%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","title":"同步远程仓库"},{"content":"创建新分支 创建想要的分支，其中branch01为想要创建的分支名 1 git checkout -b branch01 添加修改文件到暂存区 1 git add . 提交修改 1 git commit -m \u0026#34;Initial commit on branch01\u0026#34; 推送 branch01 分支到远程仓库并建立关联 1 git push -u origin branch01 之后再推送代码时只需输入git push就会自动推送到branch01分支\n如果希望都每次手动选择分支可以输入：\n1 git push origin branch01 上述代码仅完成单次推送，后续仍需指定分支名\n切换分支 切换分支输入下方命令：\n1 git checkout \u0026lt;已有分支名\u0026gt; 如果你在当前分支有未提交的更改，切换分支时可能会遇到问题。若你确定要丢弃这些未提交的更改并强制切换分支，可以使用以下命令：\n1 git checkout -f \u0026lt;已有分支名\u0026gt; 查看分支 查看本地分支 若你想查看本地仓库中存在的分支，可以使用 git branch 命令。具体操作如下： 打开终端，进入仓库所在的目录，然后执行以下命令：\n1 git branch 执行该命令后，终端会列出当前仓库中所有的本地分支，并且当前所在的分支会以绿色显示，同时前面带有一个星号（*）。\n查看远程分支 如果你想要查看远程仓库中的分支，可以使用 git branch -r 命令，该命令会列出所有的远程分支。操作步骤如下： 在终端中进入仓库目录，执行以下命令：\n1 git branch -r ","date":"2025-04-02T20:44:40+08:00","permalink":"https://IAmYuanyu.github.io/p/%E5%9C%A8gitee%E4%B8%8A%E4%BC%A0%E5%85%B6%E4%BB%96%E5%88%86%E6%94%AF/","title":"在Gitee上传其他分支"},{"content":"将代码发送到团队仓库 设置个人信息 上传代码前，要先设置个人信息，个人信息配置代码如下所示\n先找到团队的仓库页面，打开如图位置\n复制红色方框内的两条指令，分别在终端中执行\n连接远程仓库 打开要上传代码的文件夹，依次在cmd窗口执行下方命令\n1 2 3 4 5 git init git add . git commit -m \u0026#34;这里填写这次代码的上传备注，喜欢写什么写什么\u0026#34; git remote add origin https://gitee.com/... # 填写要连接的仓库地址 git push -u origin \u0026#34;master\u0026#34; 注：上传代码的时候应该会验证账号和密码，账号名是个人主页@后面的名字\n","date":"2025-04-02T20:44:07+08:00","permalink":"https://IAmYuanyu.github.io/p/%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E5%8F%91%E9%80%81%E5%88%B0gitee%E5%9B%A2%E9%98%9F%E4%BB%93%E5%BA%93/","title":"将本地代码发送到Gitee团队仓库"},{"content":"1.class类的以及class对象的介绍以及反射介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1.反射概述:解剖class对象的一个技术 2.问题:能解剖class对象的啥呢? a.解剖出成员变量 : 赋值 b.解剖出成员方法: 调用 c.解剖出构造方法: new对象 3.用反射的好处:让代码变的更通用,更灵活 4.怎么学反射: a.将反射看成是一套API来学 b.通过涛哥的案例,体会反射的好处,用反射写出来的代码有多牛掰 5.问题:玩儿反射,最开始的一步是干啥? 获取Class对象 6.class对象:class文件对应的对象 class类:描述class对象的类叫做class类 2.反射之获取Class对象 1 2 3 4 5 6 7 1.方式1:调用Object中的getClass方法: Class \u0026lt;?\u0026gt; getClass() 2.方式2:不管是基本类型还是引用类型,jvm都为其提供了一个静态成员:class 3.方式3:Class类中的静态方法: static Class\u0026lt;?\u0026gt; forName(String className) className:传递的是类的全限定名(包名.类名) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class Person { private String name; private Integer age; public Person() { } //私有构造 private Person(String name){ this.name = name; } public Person(String name, Integer age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Demo01GetClass { @Test public void get1()throws Exception{ /* 1.方式1:调用Object中的getClass方法: Class \u0026lt;?\u0026gt; getClass() */ Person person = new Person(); Class\u0026lt;? extends Person\u0026gt; aClass1 = person.getClass(); System.out.println(\u0026#34;aClass1 = \u0026#34; + aClass1); System.out.println(\u0026#34;==========================\u0026#34;); //2.方式2:不管是基本类型还是引用类型,jvm都为其提供了一个静态成员:class Class\u0026lt;Person\u0026gt; aClass2 = Person.class; System.out.println(\u0026#34;aClass2 = \u0026#34; + aClass2); System.out.println(\u0026#34;===========================\u0026#34;); /* static Class\u0026lt;?\u0026gt; forName(String className) className:传递的是类的全限定名(包名.类名) */ Class\u0026lt;?\u0026gt; aClass3 = Class.forName(\u0026#34;com.atguigu.c_reflect.Person\u0026#34;); System.out.println(\u0026#34;aClass3 = \u0026#34; + aClass3); System.out.println(\u0026#34;==========================\u0026#34;); System.out.println(aClass1==aClass2); } } 运行结果：\n写类的全限定名小技巧:\n1.如何快速写类的全限定名:\n​ a.直接赋值粘贴\n​ b.直接写类名 -\u0026gt; 回车选中\n2.如何检测类的全限定名写对了\n​ 按ctrl不放,鼠标点击此类名,能跳到对应的类中,就证明写对了\n2.1.三种获取Class对象的方式最通用的一种 1 2 3 4 1. 方式3:Class类中的静态方法: static Class\u0026lt;?\u0026gt; forName(String className) className:传递的是类的全限定名(包名.类名) 2.原因:参数为String形式,可以和properties文件结合使用 1 2 # pro.properties文件 className=com.atguigu.c_reflect.Student 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Demo02GetClass { public static void main(String[] args)throws Exception { Properties properties = new Properties(); FileInputStream in = new FileInputStream(\u0026#34;module25\\\\pro.properties\u0026#34;); properties.load(in); String className = properties.getProperty(\u0026#34;className\u0026#34;); System.out.println(className); Class\u0026lt;?\u0026gt; aClass = Class.forName(className); System.out.println(\u0026#34;aClass = \u0026#34; + aClass); } } 运行结果：\n2.2.开发中最常用的是哪一种 1 1.直接类名.class-\u0026gt; 最方便使用 3.获取Class对象中的构造方法 3.1.获取所有public的构造方法 1 2 1.Class类中的方法: Constructor\u0026lt;?\u0026gt;[] getConstructors() -\u0026gt; 获取所有public的构造 1 2 3 4 5 6 7 8 9 10 11 public class Demo03GetConstructor { public static void main(String[] args) { //获取Class对象 Class\u0026lt;Person\u0026gt; aClass = Person.class; //获取所有public的构造 Constructor\u0026lt;?\u0026gt;[] constructors = aClass.getConstructors(); for (Constructor\u0026lt;?\u0026gt; constructor : constructors) { System.out.println(constructor); } } } 运行结果：（Person类的定义在反射之获取Class对象）\n3.2.获取空参构造_public 1 2 3 4 5 6 7 8 9 10 11 1.Class类中的方法: Constructor\u0026lt;T\u0026gt; getConstructor(Class\u0026lt;?\u0026gt;... parameterTypes)-\u0026gt;获取指定的public的构造 parameterTypes:可变参数,可以传递0个或者多个参数 a.如果获取的是空参构造:参数不用写 b.如果获取的是有参构造:参数写参数类型的class对象 2.Constructor类中的方法: T newInstance(Object...initargs) -\u0026gt; 创建对象 initargs:传递的是构造方法的实参 a.如果根据无参构造new对象,initargs不写了 b.如果根据有参构造new对象,initargs传递实参 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class Demo04GetConstructor { public static void main(String[] args)throws Exception { //获取Class对象 Class\u0026lt;Person\u0026gt; aClass = Person.class; //获取无参构造 Constructor\u0026lt;Person\u0026gt; constructor1 = aClass.getConstructor(); //获取有参构造 Constructor\u0026lt;Person\u0026gt; constructor2 = aClass.getConstructor(String.class, Integer.class); System.out.println(\u0026#34;constructor1 = \u0026#34; + constructor1); System.out.println(\u0026#34;constructor2 = \u0026#34; + constructor2); /** 输出： * constructor1 = public Person() * constructor2 = public Person(java.lang.String,java.lang.Integer) */ /* 好比是Person person = new Person() */ Person person1 = constructor1.newInstance(); Person person2 = constructor2.newInstance(\u0026#34;张三\u0026#34;, 18); //好比是直接输出对象名,默认调用toString System.out.println(person1); System.out.println(person2); /** 输出： * Person{name=\u0026#39;null\u0026#39;, age=null} * Person{name=\u0026#39;张三\u0026#39;, age=18} */ Person person = new Person(); System.out.println(person.toString()); /** 输出： * Person{name=\u0026#39;null\u0026#39;, age=null} */ } } 3.3.利用空参构造创建对象的快捷方式_public 1 2 3 4 5 Class类中的方法: T newInstance() -\u0026gt; 根据空参构造创建对象 前提:被反射的类中必须有public的空参构造 注：在jdk17中过时了 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Demo05GetConstructor { public static void main(String[] args)throws Exception { //获取Class对象 Class\u0026lt;Person\u0026gt; aClass = Person.class; /* 好比是Person person = new Person() */ Person person = aClass.newInstance(); //好比是直接输出对象名,默认调用toString System.out.println(person); } } 3.4.利用反射获取有参构造并创建对象_public 1 2 3 4 5 6 7 8 9 10 11 1.Class类中的方法: Constructor\u0026lt;T\u0026gt; getConstructor(Class\u0026lt;?\u0026gt;... parameterTypes)-\u0026gt;获取指定的public的构造 parameterTypes:可变参数,可以传递0个或者多个参数 a.如果获取的是空参构造:参数不用写 b.如果获取的是有参构造:参数写参数类型的class对象 2.Constructor类中的方法: T newInstance(Object...initargs) -\u0026gt; 创建对象 initargs:传递的是构造方法的实参 a.如果根据无参构造new对象,initargs不写了 b.如果根据有参构造new对象,initargs传递实参 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Demo06GetConstructor { public static void main(String[] args)throws Exception { //获取Class对象 Class\u0026lt;Person\u0026gt; aClass = Person.class; Constructor\u0026lt;Person\u0026gt; constructor = aClass.getConstructor(String.class, Integer.class); System.out.println(\u0026#34;constructor = \u0026#34; + constructor); //创建对象-\u0026gt; 好比是Person person = new Person(\u0026#34;三上\u0026#34;,26) Person person = constructor.newInstance(\u0026#34;三上\u0026#34;, 26); //好比是直接输出Person对象,直接调用toString System.out.println(person); } } 运行结果：\n3.5.利用反射获取私有构造(暴力反射) 1 2 3 4 5 6 7 8 1.Constructor\u0026lt;?\u0026gt;[] getDeclaredConstructors()获取所有构造方法,包括private 2.Constructor\u0026lt;T\u0026gt; getDeclaredConstructor(类\u0026lt;?\u0026gt;... parameterTypes) -\u0026gt; 获取指定构造,包括private parameterTypes:参数类型的class对象 3.Constructor有一个父类叫做AccessibleObject ,里面有一个方法 void setAccessible(boolean flag) -\u0026gt; 修改访问权限 flag为true:解除私有权限 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Demo07GetConstructor { public static void main(String[] args) { Class\u0026lt;Person\u0026gt; aClass = Person.class; Constructor\u0026lt;?\u0026gt;[] dc = aClass.getDeclaredConstructors(); for (Constructor\u0026lt;?\u0026gt; constructor : dc) { System.out.println(constructor); } /** 输出： * public Person(java.lang.String,java.lang.Integer) * private Person(java.lang.String) * public Person() */ } } 1 2 3 4 5 6 7 8 9 10 11 12 public class Demo08GetConstructor { public static void main(String[] args)throws Exception { Class\u0026lt;Person\u0026gt; aClass = Person.class; Constructor\u0026lt;Person\u0026gt; dc = aClass.getDeclaredConstructor(String.class); dc.setAccessible(true);//解除私有权限-\u0026gt;暴力反射 Person person = dc.newInstance(\u0026#34;三上\u0026#34;); System.out.println(person); // 输出：Person{name=\u0026#39;三上\u0026#39;, age=null} } } 4.反射方法 4.1.利用反射获取所有成员方法_public 1 2 1.Class类中方法: Method[] getMethods() -\u0026gt; 获取所有public的方法,包括父类中的public方法 1 2 3 4 5 6 7 8 9 10 /** * 获取所有的public的方法 */ private static void method01() { Class\u0026lt;Person\u0026gt; aClass = Person.class; Method[] methods = aClass.getMethods(); for (Method method : methods) { System.out.println(method); } } 4.2.反射之获取方法(有参,无参)_public 1 2 3 4 5 6 7 8 9 10 11 1.Class类中的方法: Method getMethod(String name, Class\u0026lt;?\u0026gt;... parameterTypes) 获取指定的public的成员方法 name:传递方法名 parameterTypes:方法参数类型的class对象 2.调用方法:Method对象中的方法: Object invoke(Object obj, Object... args) -\u0026gt; 执行方法 obj:根据构造new出来的对象 args:方法实参 -\u0026gt; 如果有参数,直接传递实参;否则不用传 返回值:Object -\u0026gt; 接收被执行方法的返回值,如果方法没有返回值,不用接收了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * 获取指定的public的方法 */ private static void method02()throws Exception { Class\u0026lt;Person\u0026gt; aClass = Person.class; //创建对象 Person person = aClass.newInstance(); Method setName = aClass.getMethod(\u0026#34;setName\u0026#34;, String.class); //相当于person.setName(\u0026#34;柳岩\u0026#34;) setName.invoke(person,\u0026#34;柳岩\u0026#34;); System.out.println(person);//好比调用toString方法 System.out.println(\u0026#34;============================\u0026#34;); Method getName = aClass.getMethod(\u0026#34;getName\u0026#34;); //好比是person.getName() Object o = getName.invoke(person); System.out.println(o); } /** 输出： * Person{name=\u0026#39;柳岩\u0026#39;, age=null} * ============================ * 柳岩 */ 4.3.反射之操作私有方法 1 2 3 4 5 6 7 1.Method[] getDeclaredMethods() -\u0026gt; 获取所有的成员方法,包括private 的 2.Method getDeclaredMethod(String name, 类\u0026lt;?\u0026gt;... parameterTypes)-\u0026gt; 获取执行成员方法,包括private name:传递方法名 parameterTypes:方法参数类型的class对象 3.解除私有权限:void setAccessible(boolean flag) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * 反射指定的成员方法:包括private的 */ private static void method04()throws Exception { Class\u0026lt;Person\u0026gt; aClass = Person.class; Person person = aClass.newInstance(); Method method = aClass.getDeclaredMethod(\u0026#34;eat\u0026#34;); method.setAccessible(true); method.invoke(person); } /** * 获取所有成员方法,包括private */ private static void method03() { Class\u0026lt;Person\u0026gt; aClass = Person.class; Method[] dm = aClass.getDeclaredMethods(); for (Method method : dm) { System.out.println(method); } } 5.反射成员变量 5.1.获取所有属性 1 2 3 4 Class类中的方法: 1.Field[] getFields() -\u0026gt; 获取所有public的属性 2.Field[] getDeclaredFields() -\u0026gt; 获取所有属性,包括priavte的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * 1.Field[] getFields() -\u0026gt; 获取所有public的属性 * 2.Field[] getDeclaredFields() -\u0026gt; 获取所有属性,包括priavte的 */ private static void method01() { Class\u0026lt;Student\u0026gt; studentClass = Student.class; Field[] fields = studentClass.getFields(); for (Field field : fields) { System.out.println(field); } System.out.println(\u0026#34;========================\u0026#34;); Field[] df = studentClass.getDeclaredFields(); for (Field field : df) { System.out.println(field); } } 运行结果：\n5.2.获取指定属性 1 2 3 4 5 6 7 8 9 10 11 12 Class类中的方法: 1.Field getField(String name) -\u0026gt; 获取指定public的属性 2.Field getDeclaredField(String name) -\u0026gt; 获取指定属性,包括priavte的 3.Field类中的方法: void set(Object obj,Object value) -\u0026gt; 为属性赋值,相当于javabean中的set方法 obj:对象 value:赋予的值 Object get(Object obj) -\u0026gt; 获取属性值 obj:对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Field getField(String name) -\u0026gt; 获取指定public的属性 */ private static void method02()throws Exception { Class\u0026lt;Student\u0026gt; studentClass = Student.class; Student student = studentClass.newInstance(); Field age = studentClass.getField(\u0026#34;age\u0026#34;); //调用set方法为属性赋值 age.set(student,10); //调用get方法获取属性值 -\u0026gt; 相当于javabean中的get方法 Object o = age.get(student); System.out.println(\u0026#34;o = \u0026#34; + o); } /** * Field getDeclaredField(String name) -\u0026gt; 获取指定属性,包括priavte的 */ private static void method03()throws Exception { Class\u0026lt;Student\u0026gt; studentClass = Student.class; Student student = studentClass.newInstance(); Field name = studentClass.getDeclaredField(\u0026#34;name\u0026#34;); //解除私有权限 name.setAccessible(true); //调用set方法为属性赋值 name.set(student,\u0026#34;柳岩\u0026#34;); //调用get方法获取属性值 -\u0026gt; 相当于javabean中的get方法 Object o = name.get(student); System.out.println(\u0026#34;o = \u0026#34; + o); } 6.反射练习(编写一个小框架) 反射的使用场景之——MyBatis执行方法：\n1 2 3 public interface 接口名{ public Employee find() } 1 2 3 4 5 6 // MyBatis的配置文件 \u0026lt;select id=\u0026#34;find\u0026#34; resultType=\u0026#34;Employee的全限定名\u0026#34;\u0026gt; select 列名 from 表名 where 条件 \u0026lt;/select\u0026gt; 根据接口的class对象,创建一个实现类对象,然后通过配置文件中的方法名反射这个方法,invoke执行这个方法 练习：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 需求:在配置文件中,配置类的全限定名,以及配置一个方法名,通过解析配置文件,让配置好的方法执行起来 className=包名.Person methodName=eat 步骤: 1.创建properties配置文件,配置信息 a.问题:properties配置文件放到哪里? 将来我们开发完之后给用户的是out路径下的class文件,将class文件打包, 如果将配置文件直接放到模块下 那么out路径下是不会生成这个配置文件的,如果没有配置文件,程序也就运行不起来了 解决:我们可以将配置文件放到src下,放到src下,out路径下就会出现配置文件 b.问题:将配置文件放到src下,out路径下会自动生成配置文件,但是如果我们将来将所有的配置文件都放到src下,那么src下面会显得特别乱 解决:我们可以单独创建一个文件夹,将所有的配置文件放到此文件夹下,将此文件夹改成资源目录,取名为resources 2.读取配置文件,解析配置文件 a.问题:如果将配置文件放到resources资源目录下,我们怎么读取 new FileInputStream(\u0026#34;模块名\\\\resources\\\\properties文件名\u0026#34;) -\u0026gt; 这样不行,out路径下没有resources -\u0026gt; 相当于写死了 b.问题解决:用类加载器 ClassLoader classLoader = 当前类.class.getClassLoader() InputStream in = classLoader.getResourceAsStream(\u0026#34;文件名\u0026#34;)//自动扫描resources下的文件-\u0026gt;可以简单理解为扫描out路径下的配置文件 3.根据解析出来的className,创建Class对象 4.根据解析出来的methodName,获取对应的方法 5.执行方法 将resources文件夹改变为资源目录\nproperties配置文件：\n1 2 className=com.atguigu.d_reflect.Person methodName=eat Person类的内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Demo01Reflect { public static void main(String[] args)throws Exception { //1.创建properties集合 Properties properties = new Properties(); //2.读取配置文件,解析配置文件 InputStream in = Demo01Reflect.class.getClassLoader().getResourceAsStream(\u0026#34;pro.properties\u0026#34;); properties.load(in); //System.out.println(properties); //3.根据解析出来的className,创建Class对象 //4.根据解析出来的methodName,获取对应的方法 String className = properties.getProperty(\u0026#34;className\u0026#34;); String methodName = properties.getProperty(\u0026#34;methodName\u0026#34;); Class\u0026lt;?\u0026gt; aClass = Class.forName(className); Object o = aClass.newInstance(); Method method = aClass.getMethod(methodName); //5.执行方法 method.invoke(o); } } 注：本笔记基于尚硅谷课程\n","date":"2025-04-01T22:47:59+08:00","permalink":"https://IAmYuanyu.github.io/p/%E5%8F%8D%E5%B0%84/","title":"反射"},{"content":"类的加载时机 1 2 3 4 5 1.new对象 2.new子类对象(new子类对象先初始化父类) 3.执行main方法 4.调用静态成员 5.反射,创建Class对象 类加载器_ClassLoader 1 类加载器此处基于jdk8讲解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 1.概述: 在jvm中,负责将本地上的class文件加载到内存的对象_ClassLoader 2.分类: BootStrapClassLoader:根类加载器-\u0026gt;C语言写的,我们是获取不到的 也称之为引导类加载器,负责Java的核心类加载的 比如:System,String等 jre/lib/rt.jar下的类都是核心类 ExtClassLoader:扩展类加载器 负责jre的扩展目录中的jar包的加载 在jdk中jre的lib目录下的ext目录 AppClassLoader:系统类加载器 负责在jvm启动时加载来自java命令的class文件(自定义类),以及classPath环境变量所指定的jar包(第三方jar包) 不同的类加载器负责加载不同的类 3.三者的关系(从类加载机制层面):AppClassLoader的父类加载器是ExtClassLoader ExtClassLoader的父类加载器是BootStrapClassLoader 但是:他们从代码级别上来看,没有子父类继承关系-\u0026gt;他们都有一个共同的父类-\u0026gt;ClassLoader 4.获取类加载器对象:getClassLoader()是Class对象中的方法 类名.class.getClassLoader() 5.获取类加载器对象对应的父类加载器 ClassLoader类中的方法:ClassLoader getParent()-\u0026gt;没啥用 6.双亲委派(全盘负责委托机制) a.Person类中有一个String Person本身是AppClassLoader加载 String是BootStrapClassLoader加载 b.加载顺序: Person本身是App加载,按道理来说String也是App加载 但是App加载String的时候,先问一问Ext,说:Ext你加载这个String吗? Ext说:我不加载,我负责加载的是扩展类,但是app你别着急,我问问我爹去-\u0026gt;boot Ext说:boot,你加载String吗? boot说:正好我加载核心类,行吧,我加载吧! 7.类加载器的cache(缓存)机制(扩展):一个类加载到内存之后,缓存中也会保存一份儿,后面如果再使用此类,如果缓存中保存了这个类,就直接返回他,如果没有才加载这个类.下一次如果有其他类在使用的时候就不会重新加载了,直接去缓存中拿,保证了类在内存中的唯一性 8.所以:类加载器的双亲委派和缓存机制共同造就了加载类的特点:保证了类在内存中的唯一性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Demo01ClassLoader { public static void main(String[] args) { app(); //ext(); //boot(); } /** * 负责加载核心类 * rt.jar包中的类 * * BootStrapClassLoader是C语言编写,我们获取不到 */ private static void boot() { ClassLoader classLoader = String.class.getClassLoader(); System.out.println(\u0026#34;classLoader = \u0026#34; + classLoader); } /** * 负责加载扩展类 */ private static void ext() { ClassLoader classLoader = DNSNameService.class.getClassLoader(); System.out.println(\u0026#34;classLoader = \u0026#34; + classLoader); } /** * 负责加载自定义类以及第三方jar中的类 */ private static void app() { ClassLoader classLoader = Demo01ClassLoader.class.getClassLoader(); System.out.println(\u0026#34;classLoader = \u0026#34; + classLoader); ClassLoader classLoader1 = FileUtils.class.getClassLoader(); System.out.println(\u0026#34;classLoader1 = \u0026#34; + classLoader1); ClassLoader parent = classLoader1.getParent(); System.out.println(\u0026#34;parent = \u0026#34; + parent); //ClassLoader parent1 = parent.getParent(); //System.out.println(\u0026#34;parent1 = \u0026#34; + parent1); } } 该笔记基于尚硅谷课程\n视频地址：https://www.bilibili.com/video/BV1JZ421a7PX?spm_id_from=333.788.videopod.episodes\u0026amp;vd_source=5d30cbe8a5e5c1e21aa0b0a536d3829a\u0026amp;p=186\n","date":"2025-03-31T22:38:32+08:00","permalink":"https://IAmYuanyu.github.io/p/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","title":"类的加载时机与类加载器"},{"content":"Junit介绍 1 2 3 1.概述:Junit是一个单元测试框架,可以代替main方法去执行其他的方法 2.作用:可以单独执行一个方法,测试该方法是否能跑通 3.注意:Junit是第三方工具,所以使用之前需要导入jar包 Junit的基本使用(重点) 1 2 3 4 5 1.导入Junit的jar包 2.定义一个方法,在方法上写注解: @Test 3.执行方法: a.点击该方法左边的绿色按钮,点击run执行 -\u0026gt; 单独执行一个指定的方法 b.如果想要执行所有带@Test的方法,点击类名左边绿色按钮,点击run执行 -\u0026gt; 执行当前类中所有带@Test的方法 1 2 3 4 5 6 7 8 9 10 11 public class Demo01Junit { @Test public void add(){ System.out.println(\u0026#34;我是@Test执行的add方法\u0026#34;); } @Test public void delete(){ System.out.println(\u0026#34;我是@Test执行的delete方法\u0026#34;); } } Junit的注意事项 1 2 3 1.@Test不能修饰static方法 2.@Test不能修饰带参数的方法 3.@Test不能修饰带返回值的方法 Junit相关注解 1 2 @Before:在@Test之前执行,有多少个@Test执行,@Before就执行多少次-\u0026gt;都是用作初始化一些数据 @After:在@Test之后执行,有多少个@Test执行,@After就执行多少次-\u0026gt; 都是用作释放资源使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Demo02Junit { @Test public void add(){ System.out.println(\u0026#34;我是@Test执行的add方法\u0026#34;); } @Test public void delete(){ System.out.println(\u0026#34;我是@Test执行的delete方法\u0026#34;); } @Before public void methodBefore(){ System.out.println(\u0026#34;我是@Before执行的方法\u0026#34;); } @After public void methodAfter(){ System.out.println(\u0026#34;我是@After执行的方法\u0026#34;); } } @Test以后怎么使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Demo03Junit { /* public static void main(String[] args) { CategoryController cc = new CategoryController(); int result = cc.add(\u0026#34;蔬菜\u0026#34;); System.out.println(\u0026#34;result = \u0026#34; + result); List\u0026lt;String\u0026gt; list = cc.findAllCategory(); System.out.println(list); }*/ /** * 此方法专门测添加功能 */ @Test public void add(){ CategoryController cc = new CategoryController(); int result = cc.add(\u0026#34;蔬菜\u0026#34;); System.out.println(\u0026#34;result = \u0026#34; + result); } /** * 此方法专门测查询所有功能 */ @Test public void findAllCategory(){ CategoryController cc = new CategoryController(); List\u0026lt;String\u0026gt; list = cc.findAllCategory(); System.out.println(list); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class CategoryController { /** * 添加功能 */ public int add(String categoryName){ ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(categoryName); return 1;//如果返回一个1,证明添加成功了 } /** * 查询功能 */ public List\u0026lt;String\u0026gt; findAllCategory(){ ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;蔬菜\u0026#34;); list.add(\u0026#34;水果\u0026#34;); list.add(\u0026#34;服装\u0026#34;); list.add(\u0026#34;电器\u0026#34;); list.add(\u0026#34;玩具\u0026#34;); return list; } } 其他注解\n1 2 @BeforeClass:在@Test之前执行,只执行一次,可以修饰静态方法 @AfterClass:@Test之后执行,只执行一次,可以修饰静态方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Demo04Junit { @Test public void add(){ System.out.println(\u0026#34;我是@Test执行的add方法\u0026#34;); } @Test public void delete(){ System.out.println(\u0026#34;我是@Test执行的delete方法\u0026#34;); } @BeforeClass public static void methodBefore(){ System.out.println(\u0026#34;我是@Before执行的方法\u0026#34;); } @AfterClass public static void methodAfter(){ System.out.println(\u0026#34;我是@After执行的方法\u0026#34;); } } 注：该笔记基于尚硅谷课程\n视频地址：https://www.bilibili.com/video/BV1JZ421a7PX/?p=185\u0026amp;share_source=copy_web\u0026amp;vd_source=6b5118a5d5b29a140a6c9241c8cdd612\n","date":"2025-03-31T22:02:07+08:00","permalink":"https://IAmYuanyu.github.io/p/junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","title":"Junit单元测试"},{"content":"使用 Capacitor 1. 安装 Capacitor 在 Vue 项目中安装 Capacitor 相关依赖：\n1 2 npm install @capacitor/core @capacitor/cli npx cap init 运行 npx cap init 后，会提示你输入应用名称和包名，按要求填写即可。\n2. 添加 Android 平台支持 1 npx cap add android 此命令会在项目中创建一个 android 目录，其中包含 Android 项目的相关文件。\n3. 构建 Vue 项目 1 npm run build 该命令会在项目根目录下生成一个 dist 文件夹，里面包含了打包后的静态文件。\n4. 将构建文件同步到 Capacitor 1 npx cap sync 这会将 dist 目录中的文件复制到 android 项目的相应位置。\n5. 打开 Android 项目并打包 APK （前提：已安装Android Studio） 1 npx cap open android 这将打开 Android Studio 中的项目。在 Android Studio 中，点击菜单栏的 Build -\u0026gt; Build Bundle(s) / APK(s) -\u0026gt; Build APK(s)，等待构建完成后，在 android/app/build/outputs/apk/debug 目录下可以找到生成的 APK 文件。\nAndroid Studio官网：\nhttps://developer.android.google.cn/studio?hl=zh-cn\n安装的时候一定要选custom不要选standard！！！！不然C盘爆炸\n6. 安装 APK 到安卓设备 将生成的 APK 文件复制到安卓设备上，在设备上找到该文件并点击安装。\n","date":"2025-03-27T15:25:58+08:00","permalink":"https://IAmYuanyu.github.io/p/%E5%B0%86vue%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAapk%E6%96%87%E4%BB%B6/","title":"将Vue项目打包为apk文件"},{"content":"以vscode为例，用ctrl+f快捷键打开右上角窗口\n标题一键降级：（六级标题也会受影响） 查找：^#+(?=\\s)\n替换：#$0\n标题一键升级：（一级标题不受影响） 查找：##(?=\\s)\n替换：#\n注意：以#开头的内容会受影响。因为没有七级标题，六级标题降级后需要手动调整为想要的效果\n","date":"2025-03-27T14:15:06+08:00","permalink":"https://IAmYuanyu.github.io/p/%E5%B0%86md%E6%96%87%E4%BB%B6%E4%B8%AD%E6%89%80%E6%9C%89%E6%A0%87%E9%A2%98%E4%B8%80%E9%94%AE%E5%8D%87%E9%99%8D%E7%BA%A7/","title":"将md文件中所有标题一键升降级"},{"content":"刚弄完前一篇的教程就遇到了这个问题，头疼了半天，结果发现了一个简单无脑的解决方式\npush代码的时候加上-f，即用git push -f提交代码\n此方法有诸多风险，如数据可能丢失，破坏团队其他人代码，历史版本难以恢复等等，只建议用于自己的个人小作坊，并且确定旧代码完全没用了\n图中是我刚搭建好此网站，上传代码时遇到的问题，当时不太懂，直接去public文件夹提交代码，结果提交时与自动部署发生冲突了，其实后续需要更新网站的内容，只要执行“Hugo+Github搭建个人博客”教程中最后一步即可，无需再去管public文件夹了\n","date":"2025-03-26T21:44:16+08:00","image":"https://IAmYuanyu.github.io/p/%E6%9A%B4%E5%8A%9B%E8%A7%A3%E5%86%B3git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E6%8A%A5%E9%94%99/%E4%BB%A3%E7%A0%81%E6%97%A0%E6%B3%95%E6%8F%90%E4%BA%A4_hu_5fcaa6455564256e.png","permalink":"https://IAmYuanyu.github.io/p/%E6%9A%B4%E5%8A%9B%E8%A7%A3%E5%86%B3git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E6%8A%A5%E9%94%99/","title":"暴力解决git上传代码报错"},{"content":"参考视频：\n【【雷】Hugo + Github免费搭建博客，并实现自动化部署】 https://www.bilibili.com/video/BV1bovfeaEtQ/?share_source=copy_web\u0026vd_source=6b5118a5d5b29a140a6c9241c8cdd612\n下载HUGO HUGO官网：https://gohugo.io/\n在cmd中输入hugo new site 要创建文件夹的名字\n7.若配置了hugo的全局环境变量则无需执行copy命令，若不知道是否配置，则与图中操作一样\n下载网页主题并启动 8.到这一步后，先把cmd窗口放到后台，别关掉，重新打开hugo官网\n14.下载好主题后，把主题压缩包解压到hugo的themes文件夹中\n15.打开下载的hugo-theme-stack-3.30.0文件夹，再打开其中的exampleSite文件夹\n17.粘贴到hugo的dev文件夹下\n18.删掉hugo.toml，因为刚刚复制的hugo.yaml与其作用是一致的，相当于已经配置好了的hugo.toml\n19.然后打开刚刚复制过来的content文件夹，再打开之中的post文件夹\n20.因为rich-content中有引用国外网站，可能会导致之后无法启动网页\n21.回到dev文件夹\n23.此时已经可以启动网页了，点开步骤8时放在后台的cmd窗口，输入hugo server -D（其实就是官方提示的命令hugo server --buildDrafts的缩写）\n24.注意别关闭cmd窗口，关闭后就打不开下方网页了\n创建第一个博客 25.网页启动后可以在cmd窗口用快捷键Ctrl+C结束网页，此时就可以继续输入命令了。\n输入hugo new content post/myFirstBlog/index.md创建新内容\n26.在cmd窗口输入hugo server -D，重新启动网页\n27.Hugo的默认根路径在在static文件夹，所以要注意修改笔记中图片的路径\nstack主题配置 见参考视频\nGithub常规部署 28.下载Git：https://git-scm.com/downloads/win\n29.登录Github：https://github.com/\n若Github要2FA验证，可以下载下方插件\n下载方式如下\n使用方式：\n30.创建仓库，创建后出现的页面别关掉\n31.修改hugo.yaml中baseurl\n32.打开dev中的public文件夹，在路径处输入cmd\n补充（非必要，可不看）：可以先删掉public文件夹，再在cmd窗口输入hugo -D重新生成一个public文件夹。因为在配置主题的时候可能会把很多没必要的地方删掉，而删掉的部分仍留在public中，这时就可以用hugo -D重新生成一次静态页面\n33.然后在cmd窗口依次输入git init、git add .、git commit -m \u0026quot;first commit\u0026quot;、git branch -M main、git remote add origin https://github.com/xxx/xxx.github.io.git（这里填你自己的仓库地址）、git push -u origin main，中间输出部分太长，就不放在图中了\n34.如果和图中一样说明部署完成了\nGithub自动部署 自动部署：当你在dev文件中push代码后，页面就会自动更新\n35.再创建一个仓库\n36.打开dev文件夹，创建一个.gitignore文件，内容如图（不会创建.gitignore文件，就在此处打开cmd窗口，输入type nul\u0026gt;.gitignore即可）\n37.在dev文件夹打开cmd窗口，再执行一次和步骤33一样的操作（git remote add origin https://……命令记得换成hugo-main的仓库地址）\n38.返回Github首页\n42.将token配置为hugo-main仓库的环境变量\n44.回到dev文件夹，创建.github/workflows/\n45.打开workflows文件夹，创建一个随意取个名.yaml文件，此处叫hugo_deploy.yaml，不会创建可以用图中命令type nul\u0026gt;hugo_deploy.yaml\n46.将下方内容赋值到创建的hugo_deploy.yaml中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 47.此时已完成了自动化部署。之后更新了代码，只要再次回到dev文件夹，打开cmd窗口，依次输入git add .、git commit -m \u0026quot;update25-3-26-20:00\u0026quot;（双引号内写什么无所谓）、git push后，页面就会更新（hugo-main编译完成后可能会有一点延迟，可以先等一两分钟看看）\n","date":"2025-03-26T14:52:51+08:00","image":"https://IAmYuanyu.github.io/p/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://IAmYuanyu.github.io/p/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"Hugo+Github搭建个人博客"},{"content":"JavaScript 进阶 - 第1天 学习作用域、变量提升、闭包等语言特征，加深对 JavaScript 的理解，掌握变量赋值、函数声明的简洁语法，降低代码的冗余度。\n理解作用域对程序执行的影响 能够分析程序执行的作用域范围 理解闭包本质，利用闭包创建隔离作用域 了解什么变量提升及函数提升 掌握箭头函数、解析剩余参数等简洁语法 作用域 了解作用域对程序执行的影响及作用域链的查找机制，使用闭包函数创建隔离作用域避免全局变量污染。\n作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为全局作用域和局部作用域。\n局部作用域 局部作用域分为函数作用域和块作用域。\n函数作用域 在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; // 声明 counter 函数 function counter(x, y) { // 函数内部声明的变量 const s = x + y console.log(s) // 18 } // 设用 counter 函数 counter(10, 8) // 访问变量 s console.log(s)// 报错 \u0026lt;/script\u0026gt; 总结：\n函数内部声明的变量，在函数外部无法被访问 函数的参数也是函数内部的局部变量 不同函数内部声明的变量无法互相访问 函数执行完毕后，函数内部的变量实际被清空了 块作用域 在 JavaScript 中使用 {} 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;script\u0026gt; { // age 只能在该代码块中被访问 let age = 18; console.log(age); // 正常 } // 超出了 age 的作用域 console.log(age) // 报错 let flag = true; if(flag) { // str 只能在该代码块中被访问 let str = \u0026#39;hello world!\u0026#39; console.log(str); // 正常 } // 超出了 age 的作用域 console.log(str); // 报错 for(let t = 1; t \u0026lt;= 6; t++) { // t 只能在该代码块中被访问 console.log(t); // 正常 } // 超出了 t 的作用域 console.log(t); // 报错 \u0026lt;/script\u0026gt; JavaScript 中除了变量外还有常量，常量与变量本质的区别是【常量必须要有值且不允许被重新赋值】，常量值为对象时其属性和方法允许重新赋值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;script\u0026gt; // 必须要有值 const version = \u0026#39;1.0.0\u0026#39;; // 不能重新赋值 // version = \u0026#39;1.0.1\u0026#39;; // 常量值为对象类型 const user = { name: \u0026#39;小明\u0026#39;, age: 18 } // 不能重新赋值 user = {}; // 属性和方法允许被修改 user.name = \u0026#39;小小明\u0026#39;; user.gender = \u0026#39;男\u0026#39;; \u0026lt;/script\u0026gt; 总结：\nlet 声明的变量会产生块作用域，var 不会产生块作用域 const 声明的常量也会产生块作用域 不同代码块之间的变量无法互相访问 推荐使用 let 或 const 注：开发中 let 和 const 经常不加区分的使用，如果担心某个值会不小被修改时，则只能使用 const 声明成常量。\n全局作用域 \u0026lt;script\u0026gt; 标签和 .js 文件的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。\n1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; // 此处是全局 function sayHi() { // 此处为局部 } // 此处为全局 \u0026lt;/script\u0026gt; 全局作用域中声明的变量，任何其它作用域都可以被访问，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;script\u0026gt; // 全局变量 name const name = \u0026#39;小明\u0026#39; // 函数作用域中访问全局 function sayHi() { // 此处为局部 console.log(\u0026#39;你好\u0026#39; + name) } // 全局变量 flag 和 x const flag = true let x = 10 // 块作用域中访问全局 if(flag) { let y = 5 console.log(x + y) // x 是全局的 } \u0026lt;/script\u0026gt; 总结：\n为 window 对象动态添加的属性默认也是全局的，不推荐！ 函数中未使用任何关键字声明的变量为全局变量，不推荐！！！ 尽可能少的声明全局变量，防止全局变量被污染 JavaScript 中的作用域是程序被执行时的底层机制，了解这一机制有助于规范代码书写习惯，避免因作用域导致的语法错误。\n作用域链 在解释什么是作用域链前先来看一段代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;script\u0026gt; // 全局作用域 let a = 1 let b = 2 // 局部作用域 function f() { let c // 局部作用域 function g() { let d = \u0026#39;yo\u0026#39; } } \u0026lt;/script\u0026gt; 函数内部允许创建新的函数，f 函数内部创建的新函数 g，会产生新的函数作用域，由此可知作用域产生了嵌套的关系。\n如下图所示，父子关系的作用域关联在一起形成了链状的结构，作用域链的名字也由此而来。\n作用域链本质上是底层的变量查找机制，在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;script\u0026gt; // 全局作用域 let a = 1 let b = 2 // 局部作用域 function f() { let c // let a = 10; console.log(a) // 1 或 10 console.log(d) // 报错 // 局部作用域 function g() { let d = \u0026#39;yo\u0026#39; // let b = 20; console.log(b) // 2 或 20 } // 调用 g 函数 g() } console.log(c) // 报错 console.log(d) // 报错 f(); \u0026lt;/script\u0026gt; 总结：\n嵌套关系的作用域串联起来形成了作用域链 相同作用域链中按着从小到大的规则查找变量 子作用域能够访问父作用域，父级作用域无法访问子级作用域 JS垃圾回收机制 什么是垃圾回收机制？\n垃圾回收机制(Garbage Collection) 简称 GC\nJS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。\n正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题\n但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况\n不再用到的内存，没有及时释放，就叫做内存泄漏\n内存的生命周期\nJS环境中分配的内存, 一般有如下生命周期：\n内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用：即读写内存，也就是使用变量、函数等 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 说明： Ø 全局变量一般不会回收(关闭页面回收)；\nØ 一般情况下局部变量的值, 不用了, 会被自动回收掉\n堆栈空间分配区别：\n栈（操作系统）: 由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。 堆（操作系统）: 一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面。 下面介绍两种常见的浏览器垃圾回收算法: 引用计数法 和 标记清除法\nl 引用计数\nIE采用的引用计数算法, 定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用了就回收对象\n算法：\n跟踪记录被引用的次数 如果被引用了一次，那么就记录次数1,多次引用会累加 ++ 如果减少一个引用就减1 \u0026ndash; 如果引用次数是0 ，则释放内存 但它却存在一个致命的问题：嵌套引用（循环引用）\n如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。\nl 标记清除法\n现代的浏览器已经不再使用引用计数算法了。\n现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。\n核心：\n标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。 闭包 闭包是一种比较特殊和函数，使用闭包能够访问函数作用域中的变量。从代码形式上看闭包是一个做为返回值的函数，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 1. 闭包 : 内层函数 + 外层函数变量 // function outer() { // const a = 1 // function f() { // console.log(a) // } // f() // } // outer() // 2. 闭包的应用： 实现数据的私有。统计函数的调用次数 // let count = 1 // function fn() { // count++ // console.log(`函数被调用${count}次`) // } // 3. 闭包的写法 统计函数的调用次数 function outer() { let count = 1 function fn() { count++ console.log(`函数被调用${count}次`) } return fn } const re = outer() // 被保存到全局变量中，不会被回收 // const re = function fn() { // count++ // console.log(`函数被调用${count}次`) // } re() // 函数被调用2次 re() // 函数被调用3次 // const fn = function() { } 函数表达式 // 4. 闭包存在的问题： 可能会造成内存泄漏 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 总结：\n1.怎么理解闭包？\n闭包 = 内层函数 + 外层函数的变量 2.闭包的作用？\n封闭数据，实现数据私有，外部也可以访问函数内部的变量 闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来 3.闭包可能引起的问题？\n内存泄漏 变量提升 变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问，\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; // 访问变量 str console.log(str + \u0026#39;world!\u0026#39;); // 声明变量 str var str = \u0026#39;hello \u0026#39;; \u0026lt;/script\u0026gt; 总结：\n变量在未声明即被访问时会报语法错误 变量在声明之前即被访问，变量的值为 undefined let 声明的变量不存在变量提升，推荐使用 let 变量提升出现在相同作用域当中 实际开发中推荐先声明再访问变量 注：关于变量提升的原理分析会涉及较为复杂的词法分析等知识，而开发中使用 let 可以轻松规避变量的提升，因此在此不做过多的探讨，有兴趣可查阅资料。\n函数 知道函数参数默认值、动态参数、剩余参数的使用细节，提升函数应用的灵活度，知道箭头函数的语法及与普通函数的差异。\n函数提升 函数提升与变量提升比较类似，是指函数在声明之前即可被调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; // 调用函数 foo() // 声明函数 function foo() { console.log(\u0026#39;声明之前即被调用...\u0026#39;) } // 不存在提升现象 bar() // 错误 var bar = function () { console.log(\u0026#39;函数表达式不存在提升现象...\u0026#39;) } \u0026lt;/script\u0026gt; 总结：\n函数提升能够使函数的声明调用更灵活 函数表达式不存在提升的现象 函数提升出现在相同作用域当中 函数参数 函数参数的使用细节，能够提升函数应用的灵活度。\n默认值 1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; // 设置参数默认值 function sayHi(name=\u0026#34;小明\u0026#34;, age=18) { document.write(`\u0026lt;p\u0026gt;大家好，我叫${name}，我今年${age}岁了。\u0026lt;/p\u0026gt;`); } // 调用函数 sayHi(); sayHi(\u0026#39;小红\u0026#39;); sayHi(\u0026#39;小刚\u0026#39;, 21); \u0026lt;/script\u0026gt; 总结：\n声明函数时为形参赋值即为参数的默认值 如果参数未自定义默认值时，参数的默认值为 undefined 调用函数时没有传入对应实参时，参数的默认值被当做实参传入 动态参数 arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; // 求生函数，计算所有参数的和 function sum() { // console.log(arguments) let s = 0 for(let i = 0; i \u0026lt; arguments.length; i++) { s += arguments[i] } console.log(s) } // 调用求和函数 sum(5, 10)// 两个参数 sum(1, 2, 4) // 两个参数 \u0026lt;/script\u0026gt; 总结：\narguments 是一个伪数组 arguments 的作用是动态获取函数的实参 剩余参数（推荐使用这个） 1 2 3 4 5 6 7 8 \u0026lt;script\u0026gt; function config(baseURL, ...other) { console.log(baseURL) // 得到 \u0026#39;http://baidu.com\u0026#39; console.log(other) // other 得到 [\u0026#39;get\u0026#39;, \u0026#39;json\u0026#39;] } // 调用函数 config(\u0026#39;http://baidu.com\u0026#39;, \u0026#39;get\u0026#39;, \u0026#39;json\u0026#39;); \u0026lt;/script\u0026gt; 总结：\n... 是语法符号，置于最末函数形参之前，用于获取多余的实参 借助 ... 获取的剩余实参，是个真数组 展开运算符 展开运算符(…),将一个数组进行展开\n1 2 const arr = [1, 2, 3, 4, 5] console.log(...arr) // 1 2 3 4 5 说明：不会修改原数组\n典型运用场景： 求数组最大值(最小值)、合并数组等\n1 2 3 4 5 6 7 8 9 // 求数组最大（最小）值 const arr1 = [1, 2, 3, 4, 5] console.log(Math.max(...arr1)) // 5 console.log(Math.min(...arr1)) // 1 // 合并数组 const arr2 = [6, 7, 8] const arr3 = [...arr1, ...arr2] console.log(arr3) // 箭头函数 箭头函数是一种声明函数的简洁语法，它与普通函数并无本质的区别，差异性更多体现在语法格式上。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; const fn = function () { console.log(123) } // 1. 箭头函数 基本语法 const fn = () =\u0026gt; { console.log(123) } fn() // 123 const fn = (x) =\u0026gt; { console.log(x) } fn(1) // 1 // 2. 只有一个形参的时候，可以省略小括号 const fn = x =\u0026gt; { console.log(x) } fn(1) // 1 // 3. 只有一行代码的时候，我们可以省略大括号 const fn = x =\u0026gt; console.log(x) fn(1) // 1 // 4. 只有一行代码的时候，可以省略return const fn = x =\u0026gt; x + x console.log(fn(1)) // 2 // 5. 箭头函数可以直接返回一个对象 const fn = (uname) =\u0026gt; ({ uname: uname }) console.log(fn(\u0026#39;刘德华\u0026#39;)) // {uname: \u0026#39;刘德华\u0026#39;} \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 总结：\n箭头函数属于表达式函数，因此不存在函数提升 箭头函数只有一个参数时可以省略圆括号 () 箭头函数函数体只有一行代码时可以省略花括号 {}，并自动做为返回值被返回 箭头函数参数 箭头函数中没有 arguments，只能使用 ... 动态获取实参\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 1. 利用箭头函数来求和 const getSum = (...arr) =\u0026gt; { let sum = 0 for (let i = 0; i \u0026lt; arr.length; i++) { sum += arr[i] } return sum } const result = getSum(2, 3, 4) console.log(result) // 9 \u0026lt;/script\u0026gt; 箭头函数 this 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层沿用this。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;script\u0026gt; // 以前this的指向： 谁调用的这个函数，this 就指向谁 // console.log(this) // window // // 普通函数 // function fn() { // console.log(this) // window // } // window.fn() // // 对象方法里面的this // const obj = { // name: \u0026#39;andy\u0026#39;, // sayHi: function () { // console.log(this) // obj // } // } // obj.sayHi() // 2. 箭头函数的this 是上一层作用域的this 指向 // const fn = () =\u0026gt; { // console.log(this) // window // } // fn() // 对象方法箭头函数 this // const obj = { // uname: \u0026#39;pink老师\u0026#39;, // sayHi: () =\u0026gt; { // console.log(this) // this 指向谁？ window // } // } // obj.sayHi() const obj = { uname: \u0026#39;pink老师\u0026#39;, sayHi: function () { console.log(this) // obj let i = 10 const count = () =\u0026gt; { console.log(this) // obj } count() } } obj.sayHi() \u0026lt;/script\u0026gt; 解构赋值 知道解构的语法及分类，使用解构简洁语法快速为变量赋值。\n解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值，分为数组解构、对象解构两大类型。\n数组解构 数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; // 普通的数组 let arr = [1, 2, 3] // 批量声明变量 a b c // 同时将数组单元值 1 2 3 依次赋值给变量 a b c let [a, b, c] = arr console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 \u0026lt;/script\u0026gt; 总结：\n赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量 变量的顺序对应数组单元值的位置依次进行赋值操作 变量的数量大于单元值数量时，多余的变量将被赋值为 undefined 变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位 允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效 注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析\n典型应用交互2个变量\n1 2 3 4 let a = 1 let b = 2; // 注：这里的分号必须加 [b, a] = [a, b] console.log(a, b) // 2 1 两种要加分号的情况 1.立即执行函数\n1 2 3 4 5 6 7 8 9 // 不加分号 console.log(1) // 1 (function fn() {console.log(2)})() // Uncaught TypeError: console.log(...) is not a function // 不加分号时，上述代码在电脑看来如下，当然会报错 console.log(1)(function fn() {console.log(2)})() // 加分号 console.log(1); // 1 (function fn() {console.log(2)})() // 2 2.数组开头\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 不加分号 let a, b console.log(1) // 1 [a, b] = [1, 2] // Uncaught TypeError: Cannot set properties of undefined (setting \u0026#39;undefined\u0026#39;) console.log(a, b) // 与立即执行函数同理，不加分号时，上述代码在电脑看来如下，当然会报错 let a, b console.log(1)[a, b] = [1, 2] console.log(a, b) // 加分号 let a, b console.log(1); // 1 [a, b] = [1, 2] console.log(a, b) // 1 2 数组解构的几种情况 利用剩余参数解决变量少 单元值多的情况：\n剩余参数返回的还是一个数组\n防止有undefined传递单元值的情况，可以设置默认值：\n允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效\n按需导入，忽略某些返回值：\n支持多维数组的结构：\n对象解构 基本语法 对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;script\u0026gt; // 普通对象 const user = { name: \u0026#39;小明\u0026#39;, age: 18 }; // 批量声明变量 name age // 同时将数组单元值 小明 18 依次赋值给变量 name age const {name, age} = user console.log(name) // 小明 console.log(age) // 18 \u0026lt;/script\u0026gt; 总结：\n赋值运算符 = 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量 对象属性的值将被赋值给与属性名相同的变量 对象中找不到与变量名一致的属性时变量值为 undefined 允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效 注：支持多维解构赋值\n给新的变量名赋值 可以从一个对象中提取变量并同时修改新的变量名\n1 2 3 4 const {uname: name, age} = {uname: \u0026#39;张三\u0026#39;, age: 18} console.log(name) // 张三 console.log(age) // 18 // 此时打印uname会提示undefined 冒号表示“什么值：赋值给谁”\n数组对象结构 1 2 3 4 5 6 7 8 9 const pig = [ { uname: \u0026#39;佩奇\u0026#39;, age: 5 } ] const [{uname:name, age}] = pig console.log(name) // 佩奇 console.log(age) // 5 多级对象结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 多级对象结构 const pig = { name: \u0026#39;佩奇\u0026#39;, family: { mom: \u0026#39;pigMom\u0026#39;, dad: \u0026#39;pigDad\u0026#39; }, age: 5 } const {name, family:{mom, dad}, age} = pig console.log(name) // 佩奇 console.log(mom) // pigMom console.log(dad) // pigDad console.log(age) // 5 // 多级数组对象结构 const pig = [ { name: \u0026#39;佩奇\u0026#39;, family: { mom: \u0026#39;pigMom\u0026#39;, dad: \u0026#39;pigDad\u0026#39; }, age: 5 } ] const [{name, family:{mom, dad}, age}] = pig console.log(name) // 佩奇 console.log(mom) // pigMom console.log(dad) // pigDad console.log(age) // 5 案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 1. 这是后台传递过来的数据 const msg = { \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;获取新闻列表成功\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;5G商用自己，三大运用商收入下降\u0026#34;, \u0026#34;count\u0026#34;: 58 }, { \u0026#34;id\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;国际媒体头条速览\u0026#34;, \u0026#34;count\u0026#34;: 56 }, { \u0026#34;id\u0026#34;: 3, \u0026#34;title\u0026#34;: \u0026#34;乌克兰和俄罗斯持续冲突\u0026#34;, \u0026#34;count\u0026#34;: 1669 }, ] } // 需求1： 请将以上msg对象 采用对象解构的方式 只选出 data 方面后面使用渲染页面 // const { data } = msg // console.log(data) // 需求2： 上面msg是后台传递过来的数据，我们需要把data选出当做参数传递给 函数 // const { data } = msg // msg 虽然很多属性，但是我们利用解构只要 data值 function render({ data }) { // const { data } = arr // 我们只要 data 数据 // 内部处理 console.log(data) } render(msg) // 需求3， 为了防止msg里面的data名字混淆，要求渲染函数里面的数据名改为 myData function render({ data: myData }) { // 要求将 获取过来的 data数据 更名为 myData // 内部处理 console.log(myData) } render(msg) \u0026lt;/script\u0026gt; 综合案例 forEach遍历数组 forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数\n注意：\n1.forEach 主要是遍历数组\n2.参数当前数组元素是必须要写的， 索引号可选。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // forEach 就是遍历 加强版的for循环 适合于遍历数组对象 const arr = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;pink\u0026#39;] const result = arr.forEach(function (item, index) { console.log(item) // 数组元素 red green pink console.log(index) // 索引号 }) // console.log(result) // undefined \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 渲染商品列表案例 核心思路：有多少条数据，就渲染多少模块，然后 生成对应的 html结构标签， 赋值给 list标签即可\n①：利用forEach 遍历数据里面的 数据\n②：拿到数据，利用字符串拼接生成结构添加到页面中\n③：注意：传递参数的时候，可以使用对象解构\n效果图：\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;商品渲染\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; box-sizing: border-box; } .list { width: 990px; margin: 0 auto; display: flex; flex-wrap: wrap; padding-top: 100px; } .item { width: 240px; margin-left: 10px; padding: 20px 30px; transition: all .5s; margin-bottom: 20px; } .item:nth-child(4n) { margin-left: 0; } .item:hover { box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.2); transform: translate3d(0, -4px, 0); cursor: pointer; } .item img { width: 100%; } .item .name { font-size: 18px; margin-bottom: 10px; color: #666; } .item .price { font-size: 22px; color: firebrick; } .item .price::before { content: \u0026#34;¥\u0026#34;; font-size: 14px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;price\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const goodsList = [ { id: \u0026#39;4001172\u0026#39;, name: \u0026#39;称心如意手摇咖啡磨豆机咖啡豆研磨机\u0026#39;, price: \u0026#39;289.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/84a59ff9c58a77032564e61f716846d6.jpg\u0026#39;, }, { id: \u0026#39;4001594\u0026#39;, name: \u0026#39;日式黑陶功夫茶组双侧把茶具礼盒装\u0026#39;, price: \u0026#39;288.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/3346b7b92f9563c7a7e24c7ead883f18.jpg\u0026#39;, }, { id: \u0026#39;4001009\u0026#39;, name: \u0026#39;竹制干泡茶盘正方形沥水茶台品茶盘\u0026#39;, price: \u0026#39;109.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/2d942d6bc94f1e230763e1a5a3b379e1.png\u0026#39;, }, { id: \u0026#39;4001874\u0026#39;, name: \u0026#39;古法温酒汝瓷酒具套装白酒杯莲花温酒器\u0026#39;, price: \u0026#39;488.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/44e51622800e4fceb6bee8e616da85fd.png\u0026#39;, }, { id: \u0026#39;4001649\u0026#39;, name: \u0026#39;大师监制龙泉青瓷茶叶罐\u0026#39;, price: \u0026#39;139.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/4356c9fc150753775fe56b465314f1eb.png\u0026#39;, }, { id: \u0026#39;3997185\u0026#39;, name: \u0026#39;与众不同的口感汝瓷白酒杯套组1壶4杯\u0026#39;, price: \u0026#39;108.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/8e21c794dfd3a4e8573273ddae50bce2.jpg\u0026#39;, }, { id: \u0026#39;3997403\u0026#39;, name: \u0026#39;手工吹制更厚实白酒杯壶套装6壶6杯\u0026#39;, price: \u0026#39;99.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/af2371a65f60bce152a61fc22745ff3f.jpg\u0026#39;, }, { id: \u0026#39;3998274\u0026#39;, name: \u0026#39;德国百年工艺高端水晶玻璃红酒杯2支装\u0026#39;, price: \u0026#39;139.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/8896b897b3ec6639bbd1134d66b9715c.jpg\u0026#39;, }, ] // 声明一个字符串变量 let str = \u0026#39;\u0026#39; // 遍历数组 goodsList.forEach(item =\u0026gt; { // 结构对象 const {name, price, picture} = item // 拼接字符串 str += ` \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;${picture}\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;name\u0026#34;\u0026gt;${name}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;price\u0026#34;\u0026gt;${price}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ` }) document.querySelector(\u0026#39;.list\u0026#39;).innerHTML = str \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; filter筛选数组 filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素\n主要使用场景： 筛选数组符合条件的元素，并返回筛选之后元素的新数组\nl filter() 筛选数组\nl 返回值：返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组\nl 参数：currentValue 必须写， index 可选\nl 因为返回新数组，所以不会影响原数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; const arr = [10, 20, 30] // const newArr = arr.filter(function (item, index) { // // console.log(item) // // console.log(index) // return item \u0026gt;= 20 // }) // 返回的符合条件的新数组 const newArr = arr.filter(item =\u0026gt; item \u0026gt;= 20) console.log(newArr) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 商品列表价格筛选 需求：\n①：渲染数据列表\n②：根据选择不同条件显示不同商品\n分析：\n①：渲染页面 利用forEach 遍历数据里面的 数据，并渲染数据列表\n②：根据 filter 选择不同条件显示不同商品\n步骤：\n①：渲染页面模块\n(1) 初始化需要渲染页面，同时，点击不同的需求，还会重新渲染页面，所以渲染做成一个函数\n(2) 做法基本跟前面案例雷同，就是封装到了一个函数里面\n②：点击不同需求，显示不同页面内容\n(1) 点击采取事件委托方式 .filter\n(2) 利用过滤函数 filter 筛选出符合条件的数据，因为生成的是一个数组，传递给渲染函数即可\n(3) 筛选条件是根据点击的 data-index 来判断\n(4) 可以使用对象解构，把 事件对象 解构\n(5) 因为 全部区间不需要筛选，直接 把goodList渲染即可\n效果图：\n![](/assets/GIF 2024-11-9 23-04-19.gif)\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;商品渲染\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; box-sizing: border-box; } .list { width: 990px; margin: 0 auto; display: flex; flex-wrap: wrap; } .item { width: 240px; margin-left: 10px; padding: 20px 30px; transition: all .5s; margin-bottom: 20px; } .item:nth-child(4n) { margin-left: 0; } .item:hover { box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.2); transform: translate3d(0, -4px, 0); cursor: pointer; } .item img { width: 100%; } .item .name { font-size: 18px; margin-bottom: 10px; color: #666; } .item .price { font-size: 22px; color: firebrick; } .item .price::before { content: \u0026#34;¥\u0026#34;; font-size: 14px; } .filter { display: flex; width: 990px; margin: 0 auto; padding: 50px 30px; } .filter a { padding: 10px 20px; background: #f5f5f5; color: #666; text-decoration: none; margin-right: 20px; } .filter a:active, .filter a:focus { background: #05943c; color: #fff; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;filter\u0026#34;\u0026gt; \u0026lt;a data-index=\u0026#34;1\u0026#34; href=\u0026#34;javascript:;\u0026#34;\u0026gt;0-100元\u0026lt;/a\u0026gt; \u0026lt;a data-index=\u0026#34;2\u0026#34; href=\u0026#34;javascript:;\u0026#34;\u0026gt;100-300元\u0026lt;/a\u0026gt; \u0026lt;a data-index=\u0026#34;3\u0026#34; href=\u0026#34;javascript:;\u0026#34;\u0026gt;300元以上\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;全部区间\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;price\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 初始化数据 const goodsList = [ { id: \u0026#39;4001172\u0026#39;, name: \u0026#39;称心如意手摇咖啡磨豆机咖啡豆研磨机\u0026#39;, price: \u0026#39;289.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/84a59ff9c58a77032564e61f716846d6.jpg\u0026#39;, }, { id: \u0026#39;4001594\u0026#39;, name: \u0026#39;日式黑陶功夫茶组双侧把茶具礼盒装\u0026#39;, price: \u0026#39;288.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/3346b7b92f9563c7a7e24c7ead883f18.jpg\u0026#39;, }, { id: \u0026#39;4001009\u0026#39;, name: \u0026#39;竹制干泡茶盘正方形沥水茶台品茶盘\u0026#39;, price: \u0026#39;109.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/2d942d6bc94f1e230763e1a5a3b379e1.png\u0026#39;, }, { id: \u0026#39;4001874\u0026#39;, name: \u0026#39;古法温酒汝瓷酒具套装白酒杯莲花温酒器\u0026#39;, price: \u0026#39;488.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/44e51622800e4fceb6bee8e616da85fd.png\u0026#39;, }, { id: \u0026#39;4001649\u0026#39;, name: \u0026#39;大师监制龙泉青瓷茶叶罐\u0026#39;, price: \u0026#39;139.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/4356c9fc150753775fe56b465314f1eb.png\u0026#39;, }, { id: \u0026#39;3997185\u0026#39;, name: \u0026#39;与众不同的口感汝瓷白酒杯套组1壶4杯\u0026#39;, price: \u0026#39;108.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/8e21c794dfd3a4e8573273ddae50bce2.jpg\u0026#39;, }, { id: \u0026#39;3997403\u0026#39;, name: \u0026#39;手工吹制更厚实白酒杯壶套装6壶6杯\u0026#39;, price: \u0026#39;99.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/af2371a65f60bce152a61fc22745ff3f.jpg\u0026#39;, }, { id: \u0026#39;3998274\u0026#39;, name: \u0026#39;德国百年工艺高端水晶玻璃红酒杯2支装\u0026#39;, price: \u0026#39;139.00\u0026#39;, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/8896b897b3ec6639bbd1134d66b9715c.jpg\u0026#39;, }, ] // 封装渲染函数 function render(arr = []) { // 声明空字符串 let str = \u0026#39;\u0026#39; // 遍历数组 arr.forEach(item =\u0026gt; { // 解构对象 const {name, price, picture} = item str += ` \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;${picture}\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;name\u0026#34;\u0026gt;${name}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;price\u0026#34;\u0026gt;${price}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ` }) // 把内容追加给list document.querySelector(\u0026#39;.list\u0026#39;).innerHTML = str } // 页面一打开就要渲染 render(goodsList) // 过滤筛选 // 事件委托 document.querySelector(\u0026#39;.filter\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, e =\u0026gt; { // 解构对象 const {tagName, dataset} = e.target if(tagName === \u0026#39;A\u0026#39;) { let arr = goodsList if (dataset.index === \u0026#39;1\u0026#39;) { // 箭头函数，参数只有一个时可以省略形参的小括号，代码只有一行时，可以省略大括号并作为返回值返回 // filter函数，此时返回的是price在0~100间的item arr = goodsList.filter(item =\u0026gt; item.price \u0026gt;= 0 \u0026amp;\u0026amp; item.price \u0026lt;= 100) } if (dataset.index === \u0026#39;2\u0026#39;) { arr = goodsList.filter(item =\u0026gt; item.price \u0026gt;= 100 \u0026amp;\u0026amp; item.price \u0026lt;= 300) } if (dataset.index === \u0026#39;3\u0026#39;) { arr = goodsList.filter(item =\u0026gt; item.price \u0026gt;= 300) } // 无论点了谁，都要渲染页面，并且因为一开始将goodsList赋值给了arr // 所以如果点全部区间选项时，data-index不满足上面的判断，等同于直接渲染goodsList render(arr) } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JavaScript 进阶 - 第2天 了解面向对象编程的基础概念及构造函数的作用，体会 JavaScript 一切皆对象的语言特征，掌握常见的对象属性和方法的使用。\n了解面向对象编程中的一般概念 能够基于构造函数创建对象 理解 JavaScript 中一切皆对象的语言特征 理解引用对象类型值存储的的特征 掌握包装类型对象常见方法的使用 深入对象 了解面向对象的基础概念，能够利用构造函数创建对象。\n构造函数 构造函数是专门用于创建对象的函数，如果一个函数使用 new 关键字调用，那么这个函数就是构造函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script\u0026gt; // 定义函数 function foo() { console.log(\u0026#39;通过 new 也能调用函数...\u0026#39;); } // 调用函数 new foo; // 例 function Pig(name, age, gender) { this.name = name this.age = age this.gender = gender } // 创建对象 const Peppa = new Pig(\u0026#39;佩奇\u0026#39;, 6, \u0026#39;男\u0026#39;) const George = new Pig(\u0026#39;乔治\u0026#39;, 3, \u0026#39;男\u0026#39;) \u0026lt;/script\u0026gt; 总结：\n命名以大写字母开头 使用 new 关键字调用函数的行为被称为实例化 实例化构造函数时没有参数时可以省略 () 构造函数的返回值即为新创建的对象 构造函数内部的 return 返回的值无效！ 注：实践中为了从视觉上区分构造函数和普通函数，习惯将构造函数的首字母大写。\n实例成员 通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script\u0026gt; // 构造函数 function Person() { // 构造函数内部的 this 就是实例对象 // 实例对象中动态添加属性 this.name = \u0026#39;小明\u0026#39; // 实例对象动态添加方法 this.sayHi = function () { console.log(\u0026#39;大家好~\u0026#39;) } } // 实例化，p1 是实例对象 // p1 实际就是 构造函数内部的 this const p1 = new Person() console.log(p1) console.log(p1.name) // 访问实例属性 p1.sayHi() // 调用实例方法 \u0026lt;/script\u0026gt; 总结：\n构造函数内部 this 实际上就是实例对象，为其动态添加的属性和方法即为实例成员 为构造函数传入参数，动态创建结构相同但值不同的对象 注：构造函数创建的实例对象彼此独立互不影响。\n静态成员 在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; // 构造函数 function Person(name, age) { // 省略实例成员 } // 静态属性 Person.eyes = 2 Person.arms = 2 // 静态方法 Person.walk = function () { console.log(\u0026#39;^_^人都会走路...\u0026#39;) // this 指向 Person console.log(this.eyes) } \u0026lt;/script\u0026gt; 总结：\n静态成员指的是添加到构造函数本身的属性和方法 一般公共特征的属性或方法静态成员设置为静态成员 静态成员方法中的 this 指向构造函数本身 内置构造函数 掌握各引用类型和包装类型对象属性和方法的使用。\n在 JavaScript 中最主要的数据类型有 6 种，分别是字符串、数值、布尔、undefined、null 和 对象，常见的对象类型数据包括数组和普通对象。其中字符串、数值、布尔、undefined、null 也被称为简单类型或基础类型，对象也被称为引用类型。\n在 JavaScript 内置了一些构造函数，绝大部的数据处理都是基于这些构造函数实现的，JavaScript 基础阶段学习的 Date 就是内置的构造函数。\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; // 实例化 let date = new Date(); // date 即为实例对象 console.log(date); \u0026lt;/script\u0026gt; 甚至字符串、数值、布尔、数组、普通对象也都有专门的构造函数，用于创建对应类型的数据。\n1 2 3 4 5 const str = \u0026#39;pink\u0026#39; // js底层会将上面的代码包装成下方代码 const str = new String(\u0026#39;pink\u0026#39;) // 所以才能调用方法 console.log(str.length) Object Object 是内置的构造函数，用于创建普通对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;script\u0026gt; // 通过构造函数创建普通对象 const user = new Object({name: \u0026#39;小明\u0026#39;, age: 15}) // 这种方式声明的变量称为【字面量】 let student = {name: \u0026#39;杜子腾\u0026#39;, age: 21} // 对象语法简写 let name = \u0026#39;小红\u0026#39;; let people = { // 相当于 name: name name, // 相当于 walk: function () {} walk () { console.log(\u0026#39;人都要走路...\u0026#39;); } } console.log(student.constructor); console.log(user.constructor); console.log(student instanceof Object); \u0026lt;/script\u0026gt; 总结：\n推荐使用字面量方式声明对象，而不是 Object 构造函数\nObject.assign 静态方法创建新的对象\n1 2 3 4 5 6 7 8 // 拷贝对象 Object.assign(新对象, 被拷贝对象) const obj = { name: \u0026#39;pink\u0026#39;, age: 18} const ept = {} Object.assign(ept, obj) console.log(ept) // {name: \u0026#39;pink\u0026#39;, age: 18} // 可用于新增属性 Object.assign(ept, {gender: \u0026#39;男\u0026#39;}) console.log(ept) // {name: \u0026#39;pink\u0026#39;, age: 18, gender: \u0026#39;男\u0026#39;} Object.keys 静态方法获取对象中所有属性（返回数组）\nObject.values 表态方法获取对象中所有属性值（返回数组）\n1 2 3 const obj = { name: \u0026#39;pink\u0026#39;, age: 18} console.log(Object.keys(obj)) // [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;] console.log(Object.values(obj)) // [\u0026#39;pink\u0026#39;, 18] Array Array 是内置的构造函数，用于创建数组。\n1 2 3 4 5 6 7 8 \u0026lt;script\u0026gt; // 构造函数创建数组 let arr = new Array(5, 7, 8); // 字面量方式创建数组 let list = [\u0026#39;html\u0026#39;, \u0026#39;css\u0026#39;, \u0026#39;javascript\u0026#39;] \u0026lt;/script\u0026gt; 数组赋值后，无论修改哪个变量另一个对象的数据值也会相当发生改变。\n总结：\n推荐使用字面量方式声明数组，而不是 Array 构造函数\n实例方法 forEach 用于遍历数组，替代 for 循环 (重点)\n实例方法 filter 过滤数组单元值，生成新数组(重点)\n实例方法 map 迭代原数组，生成新数组(重点)\n实例方法 join 数组元素拼接为字符串，返回字符串(重点)\n实例方法 find 查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点)\n使用场景：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const arr = [ { name: \u0026#39;小米\u0026#39;, price: 4999 }, { name: \u0026#39;华为\u0026#39;, price: 6999 }, { name: \u0026#39;苹果\u0026#39;, price: 12999 } ] const mi = arr.find(item =\u0026gt; item.name === \u0026#39;小米\u0026#39;) console.log(mi) // {name: \u0026#39;小米\u0026#39;, price: 4999} 实例方法every 检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回 true，否则返回 false(重点) 使用场景：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const arr = [ { name: \u0026#39;小米\u0026#39;, price: 4999 }, { name: \u0026#39;华为\u0026#39;, price: 6999 }, { name: \u0026#39;苹果\u0026#39;, price: 12999 } ] console.log(arr.every(item =\u0026gt; item.price \u0026gt;= 2999)) // true console.log(arr.every(item =\u0026gt; item.price \u0026gt;= 6999)) // false 实例方法some 检测数组中的元素是否满足指定条件 如果数组中有元素满足条件返回 true，否则返回 false\n实例方法 concat 合并两个数组，返回生成新数组\n实例方法 sort 对原数组单元值排序\n实例方法 splice 删除或替换原数组单元\n实例方法 reverse 反转数组\n实例方法 findIndex 查找元素的索引值\n实例方法reduce 返回函数累计处理的结果，经常用于求和等\n基本语法：数组.reduce(function(上一次值, 当前值){}, 初始值)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 数组reduce方法 const arr = [1, 2, 3] // 没有初始值时 const total = arr.reduce(function(prev, current) { return prev + current }) console.log(total) // 6 // 有初始值时 const total = arr.reduce(function(prev, current) { return prev + current }, 10) console.log(total) // 16 // 箭头函数的写法 const total = arr.reduce((prev, current) =\u0026gt; prev + current, 10) console.log(total) // 16 // 执行过程 // 1. 如果没有*初始值*，则*上一次值*为数组的第一个元素的值 // 2. 每一次循环，把返回值作为下一次循环的*上一次值* // 3. 如果有*初始值*，则初始值作为*上一次值* // 上面代码无初始值时的执行过程演示 // 上一次值 当前值 返回值 （第一次循环） // 1 2 3 // 上一次值 当前值 返回值 （第二次循环） // 3 3 6 // 上面代码无初始值时的执行过程演示 // 上一次值 当前值 返回值 （第一次循环） // 10 1 11 // 上一次值 当前值 返回值 （第二次循环） // 11 2 13 // 上一次值 当前值 返回值 （第三次循环） // 13 3 16 静态方法Array.from 将伪数组转换为真数组 1 2 3 4 5 6 7 const lisFake = document.querySelectorAll(\u0026#39;ul li\u0026#39;) console.log(lisFake) // NodeList(3) [li, li, li] // lisFake.pop() // 报错，伪数组无法调用数组方法 const lisReal = Array.from(lisFake) console.log(lisReal) // (3) [li, li, li] lisReal.pop() // pop()删除数组最后一个元素 console.log(lisReal) // (2) [li, li] 小练习：计算薪资 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const arr = [{ name: \u0026#39;张三\u0026#39;, salary: 10240 }, { name: \u0026#39;李四\u0026#39;, salary: 20480 }, { name: \u0026#39;王五\u0026#39;, salary: 4096 }, ] // 需求1：求出总薪资 // 因为设置了初始值，所以第一次循环的prev为0 const total = arr.reduce((prev, current) =\u0026gt; prev + current.salary, 0) console.log(total) // 34816 // 需求2：每个人涨薪30%，求出总薪资 const total = arr.reduce((prev, current) =\u0026gt; prev + current.salary * 1.3, 0) console.log(total) // 45260.8 小练习：将对象内的属性值转换为字符串，属性值中间用符号隔开 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 现有： const spec = {size: \u0026#39;40cm*40cm\u0026#39;, color: \u0026#39;黑色\u0026#39;} // 要求：在页面显示40cm*40cm/黑色 // 1. 将对象的属性值存成数组 const arr = Object.values(spec) // console.log(arr) // [\u0026#39;40cm*40cm\u0026#39;, \u0026#39;黑色\u0026#39;] // 2. 用join()将数组转换成字符串，并用想要的分割符隔开 const str = arr.join(\u0026#39;/\u0026#39;) // console.log(str) // 40cm*40cm/黑色 // 3. 将得到的字符串传给div document.querySelector(\u0026#39;div\u0026#39;).innerHTML = str 包装类型 在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，如下代码举例：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; // 字符串类型 const str = \u0026#39;hello world!\u0026#39; // 统计字符的长度（字符数量） console.log(str.length) // 数值类型 const price = 12.345 // 保留两位小数 price.toFixed(2) // 12.34 \u0026lt;/script\u0026gt; 之所以具有对象特征的原因是字符串、数值、布尔类型数据是 JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型。\nString String 是内置的构造函数，用于创建字符串。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; // 使用构造函数创建字符串 let str = new String(\u0026#39;hello world!\u0026#39;); // 字面量创建字符串 let str2 = \u0026#39;你好，世界！\u0026#39;; // 检测是否属于同一个构造函数 console.log(str.constructor === str2.constructor); // true console.log(str instanceof String); // false \u0026lt;/script\u0026gt; 总结：\n实例属性 length 用来获取字符串的度长(重点)\n实例方法 split('分隔符') 用来将字符串拆分成数组(重点)\n1 2 3 4 5 6 7 8 // split()和join()类似，不过一个是字符串转数组，一个是数组转字符串 const str1 = \u0026#39;pink, red\u0026#39; const arr1 = str1.split(\u0026#39;,\u0026#39;) console.log(arr1) // [\u0026#39;pink\u0026#39;, \u0026#39; red\u0026#39;] const str2 = \u0026#39;2024-11-10\u0026#39; const arr2 = str2.split(\u0026#39;-\u0026#39;) console.log(arr2) // [\u0026#39;2024\u0026#39;, \u0026#39;11\u0026#39;, \u0026#39;10\u0026#39;] 实例方法 substring(需要截取的第一个字符的索引[,结束的索引号]) 用于字符串截取(重点) 1 2 3 4 5 6 7 8 9 // 省略结束的索引号，默认取到最后 const str = \u0026#39;0123456789\u0026#39; const arr = str.substring(4) console.log(arr) // 456789 // 有结束索引号时，取到结束索引号前一个 const str = \u0026#39;0123456789\u0026#39; const arr = str.substring(4, 8) console.log(arr) // 4567 实例方法 startsWith(检测字符串[, 检测位置索引号]) 检测是否以某字符开头(重点) 1 2 3 4 5 6 7 // startsWith()判断是否以某字符开头 const str = \u0026#39;0123456789\u0026#39; console.log(str.startsWith(\u0026#39;0\u0026#39;)) // true console.log(str.startsWith(\u0026#39;0123\u0026#39;)) // true console.log(str.startsWith(\u0026#39;123\u0026#39;)) // false console.log(str.startsWith(\u0026#39;123\u0026#39;, 1)) // true console.log(str.startsWith(\u0026#39;56789\u0026#39;, 5)) // true 实例方法 includes(搜索的字符串[, 检测位置索引号]) 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点) 1 2 3 4 5 6 // includes()判断某字符是否包含在一个字符串内 const str = \u0026#39;0123456789\u0026#39; console.log(str.includes(\u0026#39;123\u0026#39;)) // true console.log(str.includes(\u0026#39;0123\u0026#39;)) // true console.log(str.includes(\u0026#39;0123\u0026#39;, 0)) // true console.log(str.includes(\u0026#39;0123\u0026#39;, 1)) // false 实例方法 toUpperCase 用于将字母转换成大写\n实例方法 toLowerCase 用于将就转换成小写\n实例方法 indexOf 检测是否包含某字符\n实例方法 endsWith 检测是否以某字符结尾\n实例方法 replace 用于替换字符串，支持正则匹配\n实例方法 match 用于查找字符串，支持正则匹配\n实例方法toString 将其他数据类型转换为字符串\n静态方法String(变量) 将其他数据类型转换为字符串\n注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。\n小练习：显示赠品 请将下面字符串渲染到准备好的 p标签内部，结构必须如左下图所示，展示效果如图所示：\nconst gift = \u0026lsquo;50g茶叶,清洗球\u0026rsquo;\n思路：\n①：把字符串拆分为数组，这样两个赠品就拆分开了 用split(\u0026rsquo;,')\n②：利用map遍历数组，同时把数组元素生成到span里面，并且返回\n③：因为返回的是数组，所以需要 转换为字符串, 用join(\u0026rsquo;')\n④：p的innerHTML 存放刚才的返回值\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const gift = \u0026#39;50g茶叶,清洗球\u0026#39; // 以,为分隔符，将字符串拆分成数组 const arr = gift.split(\u0026#39;,\u0026#39;) console.log(arr) // [\u0026#39;50g茶叶\u0026#39;, \u0026#39;清洗球\u0026#39;] // 利用map遍历数组，同时把数组元素生成到span里面 const newArr = arr.map(function(item) { return `\u0026lt;span\u0026gt;【赠品】${item}\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt;` }) console.log(newArr) // [\u0026#39;\u0026lt;span\u0026gt;【赠品】50g茶叶\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt;\u0026#39;, \u0026#39;\u0026lt;span\u0026gt;【赠品】清洗球\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt;\u0026#39;] // 将新数组转换成字符串,中间无需空格,所以用join(\u0026#39;\u0026#39;) const str = newArr.join(\u0026#39;\u0026#39;) console.log(str) // \u0026lt;span\u0026gt;【赠品】50g茶叶\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt;\u0026lt;span\u0026gt;【赠品】清洗球\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; // 将生成的字符串放入div中 document.querySelector(\u0026#39;div\u0026#39;).innerHTML = str // 上述代码可以简写为一行 document.querySelector(\u0026#39;div\u0026#39;).innerHTML = gift.split(\u0026#39;,\u0026#39;).map(item =\u0026gt; `\u0026lt;span\u0026gt;【赠品】${item}\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt;`).join(\u0026#39;\u0026#39;) Number Number 是内置的构造函数，用于创建数值。\n1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; // 使用构造函数创建数值 let x = new Number(\u0026#39;10\u0026#39;) let y = new Number(5) // 字面量创建数值 let z = 20 \u0026lt;/script\u0026gt; 总结：\n推荐使用字面量方式声明数值，而不是 Number 构造函数 实例方法 toFixed 用于设置保留小数位的长度，会四舍五入 综合案例：购物车展示 需求：\n根据后台提供的数据，渲染购物车页面\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; box-sizing: border-box; } .list { width: 990px; margin: 100px auto 0; } .item { padding: 15px; transition: all .5s; display: flex; border-top: 1px solid #e4e4e4; } .item:nth-child(4n) { margin-left: 0; } .item:hover { cursor: pointer; background-color: #f5f5f5; } .item img { width: 80px; height: 80px; margin-right: 10px; } .item .name { font-size: 18px; margin-right: 10px; color: #333; flex: 2; } .item .name .tag { display: block; padding: 2px; font-size: 12px; color: #999; } .item .price, .item .sub-total { font-size: 18px; color: firebrick; flex: 1; } .item .price::before, .item .sub-total::before, .amount::before { content: \u0026#34;¥\u0026#34;; font-size: 12px; } .item .spec { flex: 2; color: #888; font-size: 14px; } .item .count { flex: 1; color: #aaa; } .total { width: 990px; margin: 0 auto; display: flex; justify-content: flex-end; border-top: 1px solid #e4e4e4; padding: 20px; } .total .amount { font-size: 18px; color: firebrick; font-weight: bold; margin-right: 50px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://yanxuan-item.nosdn.127.net/84a59ff9c58a77032564e61f716846d6.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;name\u0026#34;\u0026gt;称心如意手摇咖啡磨豆机咖啡豆研磨机 \u0026lt;span class=\u0026#34;tag\u0026#34;\u0026gt;【赠品】10优惠券\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;spec\u0026#34;\u0026gt;白色/10寸\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;price\u0026#34;\u0026gt;289.90\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;count\u0026#34;\u0026gt;x2\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;sub-total\u0026#34;\u0026gt;579.80\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;total\u0026#34;\u0026gt; \u0026lt;div\u0026gt;合计：\u0026lt;span class=\u0026#34;amount\u0026#34;\u0026gt;1000.00\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const goodsList = [ { id: \u0026#39;4001172\u0026#39;, name: \u0026#39;称心如意手摇咖啡磨豆机咖啡豆研磨机\u0026#39;, price: 289.9, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/84a59ff9c58a77032564e61f716846d6.jpg\u0026#39;, count: 2, spec: { color: \u0026#39;白色\u0026#39; } }, { id: \u0026#39;4001009\u0026#39;, name: \u0026#39;竹制干泡茶盘正方形沥水茶台品茶盘\u0026#39;, price: 109.8, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/2d942d6bc94f1e230763e1a5a3b379e1.png\u0026#39;, count: 3, spec: { size: \u0026#39;40cm*40cm\u0026#39;, color: \u0026#39;黑色\u0026#39; } }, { id: \u0026#39;4001874\u0026#39;, name: \u0026#39;古法温酒汝瓷酒具套装白酒杯莲花温酒器\u0026#39;, price: 488, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/44e51622800e4fceb6bee8e616da85fd.png\u0026#39;, count: 1, spec: { color: \u0026#39;青色\u0026#39;, sum: \u0026#39;一大四小\u0026#39; } }, { id: \u0026#39;4001649\u0026#39;, name: \u0026#39;大师监制龙泉青瓷茶叶罐\u0026#39;, price: 139, picture: \u0026#39;https://yanxuan-item.nosdn.127.net/4356c9fc150753775fe56b465314f1eb.png\u0026#39;, count: 1, spec: { size: \u0026#39;小号\u0026#39;, color: \u0026#39;紫色\u0026#39; }, gift: \u0026#39;50g茶叶,清洗球\u0026#39; } ] // ***************自己写**************** // 根据数据渲染页面 document.querySelector(\u0026#39;.list\u0026#39;).innerHTML = goodsList.map(item =\u0026gt; { // 解构对象 const {picture, name, count, price, spec, gift} = item // 规格文字模块 // Object.values()返回的是数组，再用join()把数组拼接成字符串 const text = Object.values(spec).join(\u0026#39;/\u0026#39;) // 小计模块，保留两位小数，所以乘100就能化为整数 // 乘100再除100的原因：为了防止精度bug，先用整数计算，之后再除回来 // 精度bug：console.log(0.1 + 0.2) // 0.30000000000000004 const total = ((price * 100 * count ) / 100).toFixed(2) // 赠品模块 \u0026#39;50g茶叶,清洗球\u0026#39; ps:赠品模块详细写法可以见上方笔记的 小练习：显示赠品 // 并不是所有商品都有赠品，所以加一个判断 const str = gift ? gift.split(\u0026#39;,\u0026#39;).map(item =\u0026gt; `\u0026lt;span class=\u0026#34;tag\u0026#34;\u0026gt;【赠品】${item}\u0026lt;/span\u0026gt;`).join(\u0026#39;\u0026#39;) : \u0026#39;\u0026#39; return ` \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;${picture}\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;name\u0026#34;\u0026gt;${name} ${str}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;spec\u0026#34;\u0026gt;${text}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;price\u0026#34;\u0026gt;${price.toFixed(2)}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;count\u0026#34;\u0026gt;x${count}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;sub-total\u0026#34;\u0026gt;${total}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ` }).join(\u0026#39;\u0026#39;) // 合计价格模块 const amount = document.querySelector(\u0026#39;.amount\u0026#39;) const total = goodsList.reduce((prev, item) =\u0026gt; prev + (item.price * 100 * item.count ) / 100, 0) amount.innerHTML = total.toFixed(2) // ***************自己写**************** \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JavaScript 进阶 - 第3天笔记 了解构造函数原型对象的语法特征，掌握 JavaScript 中面向对象编程的实现方式，基于面向对象编程思想实现 DOM 操作的封装。\n了解面向对象编程的一般特征 掌握基于构造函数原型对象的逻辑封装 掌握基于原型对象实现的继承 理解什么原型链及其作用 能够处理程序异常提升程序执行的健壮性 编程思想 学习 JavaScript 中基于原型的面向对象编程序的语法实现，理解面向对象编程的特征。\n面向过程 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次\n调用就可以了。\n举个栗子：蛋炒饭\n面向对象 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。\n在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。\n面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。\n面向对象的特性：\n封装性\n继承性\n多态性\n构造函数 对比以下通过面向对象的构造函数实现的封装：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;script\u0026gt; function Person() { this.name = \u0026#39;佚名\u0026#39; // 设置名字 this.setName = function (name) { this.name = name } // 读取名字 this.getName = () =\u0026gt; { console.log(this.name) } } // 实例对像，获得了构造函数中封装的所有逻辑 let p1 = new Person() p1.setName(\u0026#39;小明\u0026#39;) console.log(p1.name) // 实例对象 let p2 = new Person() console.log(p2.name) \u0026lt;/script\u0026gt; 封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。\n同样的将变量和函数组合到了一起并能通过 this 实现数据的共享，所不同的是借助构造函数创建出来的实例对象之\n间是彼此不影响的\n总结：\n构造函数体现了面向对象的封装特性 构造函数实例创建的对象彼此独立、互不影响 封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。\n前面我们学过的构造函数方法很好用，但是 存在浪费内存的问题\n原型对象 构造函数通过原型分配的函数是所有对象所共享的。\nprototype 属性 JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象 这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。 构造函数和原型对象中的this 都指向 实例化的对象 一般在构造函数放公共的属性，原型对象内放公共的方法\n1 2 3 4 5 6 7 8 \u0026lt;script\u0026gt; function Person() { } // 每个函数都有 prototype 属性 console.log(Person.prototype) \u0026lt;/script\u0026gt; 构造函数内方法与原型对象内方法的优先级 了解了 JavaScript 中构造函数与原型对象的关系后，再来看原型对象具体的作用，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; function Person() { // 此处未定义任何方法 } // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () { console.log(\u0026#39;Hi~\u0026#39;); } // 实例化 let p1 = new Person(); p1.sayHi(); // 输出结果为 Hi~ \u0026lt;/script\u0026gt; 构造函数 Person 中未定义任何方法，这时实例对象调用了原型对象中的方法 sayHi，接下来改动一下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script\u0026gt; function Person() { // 此处定义同名方法 sayHi this.sayHi = function () { console.log(\u0026#39;嗨!\u0026#39;); } } // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () { console.log(\u0026#39;Hi~\u0026#39;); } let p1 = new Person(); p1.sayHi(); // 输出结果为 嗨! \u0026lt;/script\u0026gt; 构造函数 Person 中定义与原型对象中相同名称的方法，这时实例对象调用则是构造函中的方法 sayHi。\n通过以上两个简单示例不难发现 JavaScript 中对象的工作机制：当访问对象的属性或方法时，先在当前实例对象是查找，然后再去原型对象查找，并且原型对象被所有实例共享。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;script\u0026gt; function Person() { // 此处定义同名方法 sayHi this.sayHi = function () { console.log(\u0026#39;嗨!\u0026#39; + this.name) } } // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () { console.log(\u0026#39;Hi~\u0026#39; + this.name) } // 在构造函数的原型对象上添加属性 Person.prototype.name = \u0026#39;小明\u0026#39; let p1 = new Person() p1.sayHi(); // 输出结果为 嗨! let p2 = new Person() p2.sayHi() \u0026lt;/script\u0026gt; 原型对象也可以节约内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function Fn(name) { this.name = name this.say = function() {console.log(\u0026#39;hi\u0026#39;)} } const temp1 = new Fn(1) const temp2 = new Fn(2) console.log(temp1.say === temp2.say) // false // 所以一般把公共的属性写进构造函数内 function Star(name, age) { this.name = name this.age = age } // 把公共的方法写进原型对象内 Star.prototype.sing = function() { console.log(\u0026#39;唱歌\u0026#39;) } const ldh = new Star(\u0026#39;刘德华\u0026#39;, 18) const zxy = new Star(\u0026#39;张学友\u0026#39;, 19) console.log(ldh.sing === zxy.sing) // true 原型对象的this指向 构造函数和原型对象中的this 都指向实例化的对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 构造函数的this指向 let that function Person(name) { this.name = name that = this } const temp = new Person() console.log(that === temp) // true，说明构造函数的this指向实例对象 // 原型对象的this指向 let that function Person(name) { this.name = name } Person.prototype.sing = function() { that = this } const temp = new Person() temp.sing() // 要先调用一次原型对象，将this赋值给that console.log(temp === that) // true，说明原型对象的this也指向实例对象 总结：结合构造函数原型的特征，实际开发重往往会将封装的功能函数添加到原型对象中。\n小练习：给数组扩展方法 需求：\n①：给数组扩展求最大值方法和求和方法\n比如： 以前学过\nconst arr = [1,2,3]\narr.reverse() 结果是 [3,2,1]\n扩展完毕之后：\narr.sum() 返回的结果是 6\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const arr = [1, 2, 3] // 求最大值方法 Array.prototype.max = function() { // 利用展开运算符 console.log(...arr) // 1 2 3 // 但如果写形参...arr的话后续还需要传参，为了省事直接使用this // 因为this指向实例对象，所以就能省了传参的步骤 return Math.max(...this) } console.log(arr.max()) // 3 // 求和方法 Array.prototype.sum = function() { return this.reduce((prev, item) =\u0026gt; prev + item, 0) } console.log(arr.sum()) // 6 constructor 属性 在哪里？ 每个原型对象里面都有个constructor 属性（constructor 构造函数）\n作用：该属性指向该原型对象的构造函数， 简单理解，就是指向我的爸爸，我是有爸爸的孩子\n1 2 3 function Person() {} console.log(Person.prototype.constructor) // Person() {} console.log(Person.prototype.constructor === Person) // true 使用场景：\n如果有多个对象的方法，我们可以给原型对象采取对象形式赋值.\n但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了\n此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。\n1 2 3 4 5 6 7 8 function Person() {} console.log(Person.prototype) // 输出结果展开有constructor // 一次次给prototype赋值很不方便，所以要存多个时一般存成对象 Person.prototype = { sing: () =\u0026gt; {console.log(\u0026#39;唱歌\u0026#39;)}, dance: () =\u0026gt; {console.log(\u0026#39;跳舞\u0026#39;)}, } console.log(Person.prototype) // 发现输出结果展开没有constructor 输出结果：\n此时constructor就派上用场了\n1 2 3 4 5 6 7 8 9 function Person() {} console.log(Person.prototype) Person.prototype = { // 重新指回创造这个原型对象的构造函数 constructor: Person, sing: () =\u0026gt; {console.log(\u0026#39;唱歌\u0026#39;)}, dance: () =\u0026gt; {console.log(\u0026#39;跳舞\u0026#39;)}, } console.log(Person.prototype) // 此时就能从结果中看见constructor了 输出结果：\n对象原型 对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype\n原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。\n注意：\n__proto__ 是JS非标准属性 [[prototype]]和__proto__意义相同 用来表明当前实例对象指向哪个原型对象prototype __proto__对象原型里面也有一个 constructor属性，指向创建该实例对象的构造函数 1 2 3 4 5 6 function Person() {} const temp = new Person() // 对象原型 __proto__ 指向该构造函数的原型对象 console.log(temp.__proto__ === Person.prototype) // true // 对象原型里也有一个constructor指向该实例对象的构造函数 console.log(temp.__proto__.constructor === Person) // true 原型继承 继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承\n的特性。\n龙生龙、凤生凤、老鼠的儿子会打洞描述的正是继承的含义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 构造函数 new 出来的对象 结构一样，但是对象不一样 function Person() { this.eyes = 2 this.head = 1 } // console.log(new Person() === new Person()) // false // 女人 构造函数 继承 想要 继承 Person function Woman() { } // Woman 通过原型来继承 Person // 父构造函数（父类） 子构造函数（子类） // 子类的原型 = new 父类 // 右边必须写成new Person()，若写成Person，则后续若给Woman添加prototype方法时，会同步到Man身上，反之亦然，因为每次new Person()生成的都是不同的对象 Woman.prototype = new Person() // {eyes: 2, head: 1} // 指回原来的构造函数 Woman.prototype.constructor = Woman // 给女人添加一个方法 生孩子 Woman.prototype.baby = function () { console.log(\u0026#39;宝贝\u0026#39;) } const red = new Woman() console.log(red) // console.log(Woman.prototype) // 男人 构造函数 继承 想要 继承 Person function Man() { } // 通过 原型继承 Person Man.prototype = new Person() Man.prototype.constructor = Man const pink = new Man() console.log(pink) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 原型链 基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对\n象的链状结构关系称为原型链\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // function Objetc() {} console.log(Object.prototype) console.log(Object.prototype.__proto__) function Person() { } const ldh = new Person() // console.log(ldh.__proto__ === Person.prototype) // console.log(Person.prototype.__proto__ === Object.prototype) console.log(ldh instanceof Person) console.log(ldh instanceof Object) console.log(ldh instanceof Array) console.log([1, 2, 3] instanceof Array) console.log(Array instanceof Object) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 原型链的查找规则 ① 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。\n② 如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）\n③ 如果还没有就查找原型对象的原型（Object的原型对象）\n④ 依此类推一直找到 Object 为止（null）\n⑤ __proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线\n⑥ 可以使用 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\n总结 所有对象里面都有对象原型__proto__，并且指向原型对象 所有原型对象里面都有constructor，指向创造该原型对象的构造函数 综合案例 需求：\n分析需求：\n定义模态框 Modal 构造函数，用来创建对象 模态框具备 打开功能 open 方法 （按钮点击可以打开模态框） 模态框 具备关闭功能 close 方法 问：\nopen 和 close 方法 写到哪里？\n构造函数的原型对象上，共享方法\n所以可以分为三个模块， 构造函数， open方法， close方法\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;面向对象封装消息提示\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .modal { width: 300px; min-height: 100px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.2); border-radius: 4px; position: fixed; z-index: 999; left: 50%; top: 50%; transform: translate3d(-50%, -50%, 0); background-color: #fff; } .modal .header { line-height: 40px; padding: 0 10px; position: relative; font-size: 20px; } .modal .header i { font-style: normal; color: #999; position: absolute; right: 15px; top: -2px; cursor: pointer; } .modal .body { text-align: center; padding: 10px; } .modal .footer { display: flex; justify-content: flex-end; padding: 10px; } .modal .footer a { padding: 3px 8px; background: #ccc; text-decoration: none; color: #fff; border-radius: 2px; margin-right: 10px; font-size: 14px; } .modal .footer a.submit { background-color: #369; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;delete\u0026#34;\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;login\u0026#34;\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;!-- \u0026lt;div class=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt;温馨提示 \u0026lt;i\u0026gt;x\u0026lt;/i\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;body\u0026#34;\u0026gt;您没有删除权限操作\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; --\u0026gt; \u0026lt;script\u0026gt; // 定义构造函数Modal function Modal(title = \u0026#39;\u0026#39;, message = \u0026#39;\u0026#39;) { // 创建一个modalBox，并在其中创建一个div标签 this.modalBox = document.createElement(\u0026#39;div\u0026#39;) // 给div标签添加modal类 this.modalBox.className = \u0026#39;modal\u0026#39; this.modalBox.innerHTML = ` \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt;${title} \u0026lt;i\u0026gt;x\u0026lt;/i\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;body\u0026#34;\u0026gt;${message}\u0026lt;/div\u0026gt; ` } // 给构造函数的原型对象添加open方法 Modal.prototype.open = function() { // 解决多次点击出现多个盒子的bug // 先获取类名为modal的盒子 const box = document.querySelector(\u0026#39;.modal\u0026#39;) // 利用逻辑与的中断，若box为空，则不执行box.remove()，若box不为空，则会执行 box \u0026amp;\u0026amp; box.remove() // 把刚才创建的modalBox显示到页面的body中 document.body.append(this.modalBox) // 绑定关闭的点击事件的前提是盒子已经出现在页面中 // 调用了open方法，盒子就已经被添加到页面中了，所以写在open方法下面比较稳妥 this.modalBox.querySelector(\u0026#39;.modal i\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 这里需要使用箭头函数，因为箭头函数内没有this // 所以下方的this指向的是实例对象，而不是i标签 this.close() }) } // 给构造函数的原型对象添加close方法 Modal.prototype.close = function() { // 移除实例对象的modalBox this.modalBox.remove() } // 给删除按钮绑定事件 document.querySelector(\u0026#39;#delete\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 先实例化Modal构造函数 const del = new Modal(\u0026#39;温馨提示\u0026#39;, \u0026#39;您没有删除权限\u0026#39;) // 调用实例对象的open方法 del.open() }) // 给登录按钮绑定事件 document.querySelector(\u0026#39;#login\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 先实例化Modal构造函数 const log = new Modal(\u0026#39;暖心提示\u0026#39;, \u0026#39;您还没有注册\u0026#39;) // 调用实例对象的open方法 log.open() }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JavaScript 进阶 - 第4天 深浅拷贝 浅拷贝 首先浅拷贝和深拷贝只针对引用类型\n浅拷贝：拷贝的是地址\n常见方法：\n拷贝对象：Object.assgin() / 展开运算符 {\u0026hellip;obj} 拷贝对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const obj = { a: 10, b: 20 } const o = {...obj} o.b = 25 console.log(o) // {a: 10, b: 25} console.log(obj) // {a: 10, b: 20} const o = {} Object.assign(o, obj) o.b = 25 console.log(o) // {a: 10, b: 25} console.log(obj) // {a: 10, b: 20} // 缺点 const obj = { a: 10, b: 20, c: { d: \u0026#39;hi\u0026#39; } } const o = {} Object.assign(o, obj) o.c.d = \u0026#39;你好\u0026#39; console.log(o) // {a: 10, b: 20, c: {d: \u0026#39;你好\u0026#39;}} console.log(obj) // {a: 10, b: 20, c: {d: \u0026#39;你好\u0026#39;}} 拷贝数组：Array.prototype.concat() 或者 [\u0026hellip;arr] 如果是简单数据类型拷贝值，引用数据类型拷贝的是地址 (简单理解： 如果是单层对象，没问题，如果有多层就有问题)\n深拷贝 首先浅拷贝和深拷贝只针对引用类型\n深拷贝：拷贝的是对象，不是地址\n常见方法：\n通过递归实现深拷贝 lodash/cloneDeep 通过JSON.stringify()实现 递归实现深拷贝 函数递归：\n如果一个函数在内部可以调用其本身，那么这个函数就是递归函数\n简单理解:函数内部自己调用自己, 这个函数就是递归函数 递归函数的作用和循环效果类似 由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 简易版深拷贝，处理不了太复杂的情况 const obj = { uname: \u0026#39;pink\u0026#39;, age: 18, hobby: [\u0026#39;唱歌\u0026#39;,\u0026#39;跳舞\u0026#39;], family: { baby: \u0026#39;小pink\u0026#39; } } const o = {} function deepCopy(newObj, oldObj) { for (let k in oldObj) { // 最先处理数组的问题，必须先处理数组再处理对象 // 数组也属于对象，若先处理对象，会把数组当对象处理 // 所以先处理数组，把数组筛掉后，再处理对象 if (oldObj[k] instanceof Array) { // 判断是否是数组 // 数组特殊处理 // 已知此轮要存放数组，先声明空数组用于存放 newObj[k] = [] // 递归，进入数组内部复制 deepCopy(newObj[k], oldObj[k]) } // 处理对象的问题 else if (oldObj[k] instanceof Object) { // 对象特殊处理，与数组类似 // 已知此轮要存放对象，先声明空对象用于存放 newObj[k] = {} // 递归，进入对象内部复制 deepCopy(newObj[k], oldObj[k]) } // 普通简单数据类型处理 else { // k表示每轮的属性名，k是变量，所以必须用newObj[k]的形式，而不是newObj.k // newObj[k] === 属性名.属性值 newObj[k] = oldObj[k] } } } deepCopy(o, obj) // 测试 o.uname = \u0026#39;red\u0026#39; o.hobby[0] = \u0026#39;篮球\u0026#39; o.family.baby = \u0026#39;老pink\u0026#39; console.log(o) console.log(obj) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 输出结果：\njs库lodash里面cloneDeep内部实现了深拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;body\u0026gt; \u0026lt;!-- 先引用 --\u0026gt; \u0026lt;!-- \u0026lt;script src=\u0026#34;./lodash.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;!--没安装也可以用在线地址--\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const obj = { uname: \u0026#39;pink\u0026#39;, age: 18, hobby: [\u0026#39;乒乓球\u0026#39;, \u0026#39;足球\u0026#39;], family: { baby: \u0026#39;小pink\u0026#39; } } const o = _.cloneDeep(obj) console.log(o) o.family.baby = \u0026#39;老pink\u0026#39; console.log(obj) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; JSON序列化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; const obj = { uname: \u0026#39;pink\u0026#39;, age: 18, hobby: [\u0026#39;乒乓球\u0026#39;, \u0026#39;足球\u0026#39;], family: { baby: \u0026#39;小pink\u0026#39; } } // 把对象转换为 JSON 字符串 // console.log(JSON.stringify(obj)) // 再把 JSON 字符串转换为对象 // console.log(JSON.parse(JSON.stringify(obj))) const o = JSON.parse(JSON.stringify(obj)) console.log(o) o.family.baby = \u0026#39;123\u0026#39; console.log(obj) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 异常处理 了解 JavaScript 中程序异常处理的方法，提升代码运行的健壮性。\nthrow 异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行\n总结：\nthrow 抛出异常信息，程序也会终止执行 throw 后面跟的是错误提示信息 Error 对象配合 throw 使用，能够设置更详细的错误信息 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;script\u0026gt; function counter(x, y) { if(!x || !y) { // throw \u0026#39;参数不能为空!\u0026#39;; throw new Error(\u0026#39;参数不能为空!\u0026#39;) } return x + y } counter() \u0026lt;/script\u0026gt; 总结：\nthrow 抛出异常信息，程序也会终止执行 throw 后面跟的是错误提示信息 Error 对象配合 throw 使用，能够设置更详细的错误信息 try \u0026hellip; catch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script\u0026gt; function foo() { try { // 将可能出错的代码写到try中 const p = document.querySelector(\u0026#39;.p\u0026#39;) p.style.color = \u0026#39;red\u0026#39; } catch (error) { // try 代码段中执行有错误时，会执行 catch 代码段 // 查看错误信息，但是不会中断程序执行 console.log(error.message) // 利用return终止代码继续执行 return // 不写return也可以用throw中断程序 // throw new Error(\u0026#39;不写return时也能用throw中断程序\u0026#39;) } finally { // 不论程序对不对，都会执行 alert(\u0026#39;执行\u0026#39;) } console.log(\u0026#39;如果出现错误，我的语句不会执行\u0026#39;) } foo() \u0026lt;/script\u0026gt; 总结：\ntry...catch 用于捕获错误信息 将预估可能发生错误的代码写在 try 代码段中 如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息 debugger 相当于断点调试，执行到该语句时相当于遇到了断点调试\n处理this 了解函数中 this 在不同场景下的默认值，知道动态指定函数 this 值的方法。\nthis 是 JavaScript 最具“魅惑”的知识点，不同的应用场合 this 的取值可能会有意想不到的结果，在此我们对以往学习过的关于【 this 默认的取值】情况进行归纳和总结。\n普通函数 普通函数的调用方式决定了 this 的值，即【谁调用 this 的值指向谁】，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;script\u0026gt; // 普通函数 function sayHi() { console.log(this) } // 函数表达式 const sayHello = function () { console.log(this) } // 函数的调用方式决定了 this 的值 sayHi() // window window.sayHi() // 普通对象 const user = { name: \u0026#39;小明\u0026#39;, walk: function () { console.log(this) } } // 动态为 user 添加方法 user.sayHi = sayHi uesr.sayHello = sayHello // 函数调用方式，决定了 this 的值 user.sayHi() user.sayHello() \u0026lt;/script\u0026gt; 注： 普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined。\n箭头函数 箭头函数中的 this 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 this ！箭头函数中访问的 this 不过是箭头函数所在作用域的 this 变量。\n箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的\n箭头函数中的this引用的就是最近作用域中的this\n向外层作用域中，一层一层查找this，直到有this的定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;script\u0026gt; console.log(this) // 此处为 window // 箭头函数 const sayHi = function() { console.log(this) // 该箭头函数中的 this 为函数声明环境中 this 一致 } // 普通对象 const user = { name: \u0026#39;小明\u0026#39;, // 该箭头函数中的 this 为函数声明环境中 this 一致 walk: () =\u0026gt; { console.log(this) }, sleep: function () { let str = \u0026#39;hello\u0026#39; console.log(this) let fn = () =\u0026gt; { console.log(str) console.log(this) // 该箭头函数中的 this 与 sleep 中的 this 一致 } // 调用箭头函数 fn(); } } // 动态添加方法 user.sayHi = sayHi // 函数调用 user.sayHi() user.sleep() user.walk() \u0026lt;/script\u0026gt; 在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此DOM事件回调函数不推荐使用箭头函数，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; // DOM 节点 const btn = document.querySelector(\u0026#39;.btn\u0026#39;) // 箭头函数 此时 this 指向了 window btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { console.log(this) }) // 普通函数 此时 this 指向了 DOM 对象 btn.addEventListener(\u0026#39;click\u0026#39;, function () { console.log(this) }) \u0026lt;/script\u0026gt; 同样由于箭头函数 this 的原因，基于原型的面向对象也不推荐采用箭头函数，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; function Person() { } // 原型对像上添加了箭头函数 Person.prototype.walk = () =\u0026gt; { console.log(\u0026#39;人都要走路...\u0026#39;) console.log(this); // window } const p1 = new Person() p1.walk() \u0026lt;/script\u0026gt; 改变this指向 以上归纳了普通函数和箭头函数中关于 this 默认值的情形，不仅如此 JavaScript 中还允许指定函数中 this 的指向，有 3 个方法可以动态指定普通函数中 this 的指向：\ncall 使用 call 方法调用函数，同时指定函数中 this 的值，使用方法如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;script\u0026gt; // 普通函数 function sayHi() { console.log(this); } let user = { name: \u0026#39;小明\u0026#39;, age: 18 } let student = { name: \u0026#39;小红\u0026#39;, age: 16 } // 调用函数并指定 this 的值 sayHi.call(user); // this 值为 user sayHi.call(student); // this 值为 student // 求和函数 function counter(x, y) { return x + y; } // 调用 counter 函数，并传入参数 let result = counter.call(null, 5, 10); console.log(result); \u0026lt;/script\u0026gt; 总结：\ncall 方法能够在调用函数的同时指定 this 的值 使用 call 方法调用函数时，第1个参数为 this 指定的值 call 方法的其余参数会依次自动传入函数做为函数的参数 apply 使用 call 方法调用函数，同时指定函数中 this 的值，使用方法如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;script\u0026gt; // 普通函数 function sayHi() { console.log(this) } let user = { name: \u0026#39;小明\u0026#39;, age: 18 } let student = { name: \u0026#39;小红\u0026#39;, age: 16 } // 调用函数并指定 this 的值 sayHi.apply(user) // this 值为 user sayHi.apply(student) // this 值为 student // 求和函数 function counter(x, y) { return x + y } // 调用 counter 函数，并传入参数 let result = counter.apply(null, [5, 10]) console.log(result) // 求数组最大值 const arr = [123, 321, 111] const max = Math.max.apply(Math, arr) console.log(max) // 321 \u0026lt;/script\u0026gt; 总结：\napply 方法能够在调用函数的同时指定 this 的值 使用 apply 方法调用函数时，第1个参数为 this 指定的值 apply 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数 bind bind 方法并不会调用函数，而是创建一个指定了 this 值的新函数，使用方法如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;script\u0026gt; // 普通函数 function sayHi() { console.log(this) } let user = { name: \u0026#39;小明\u0026#39;, age: 18 } // 调用 bind 指定 this 的值 let sayHello = sayHi.bind(user); // 调用使用 bind 创建的新函数 sayHello() // 需求：有一个按钮，点击后就禁用，2秒后重新启用 const btn = document.querySelector(\u0026#39;button\u0026#39;) btn.addEventListener(\u0026#39;click\u0026#39;, function() { // 此处this指向btn this.disabled = true window.setTimeout(function() { this.disabled = false }.bind(this), 2000) // 将定时器中的函数中的this指向外部函数的this，即btn }) \u0026lt;/script\u0026gt; 注：bind 方法创建新的函数，与原函数的唯一的变化是改变了 this 的值。\ncall、apply、bind的总结 防抖节流 防抖（debounce） 所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间\n案例：利用防抖处理鼠标移动事件 要求：鼠标在盒子上移动，鼠标停止500ms之后，里面的数字才会+1\n效果图：\n实现方式有两种：\n①利用lodash提供的防抖函数来处理\n_.debounce(func, [wait=0], [options=])\n官方说明：创建一个 debounced（防抖动）函数，该函数会从上一次被调用后，延迟 wait 毫秒后调用 func 方法。 debounced（防抖动）函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。 可以提供一个 options（选项） 对象决定如何调用 func 方法，options.leading 与|或 options.trailing 决定延迟前后如何触发（注：是 先调用后等待 还是 先等待后调用）。 func 调用时会传入最后一次提供给 debounced（防抖动）函数 的参数。 后续调用的 debounced（防抖动）函数返回是最后一次 func 调用的结果。\n参数\nfunc (Function): 要防抖动的函数。 [wait=0] (number): 需要延迟的毫秒数。 [options=] (Object): 选项对象。 [options.leading=false] (boolean): 指定在延迟开始前调用。 [options.maxWait] (number): 设置 func 允许被延迟的最大值。 [options.trailing=true] (boolean): 指定在延迟结束后调用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;!-- 在线引入lodash库 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .box { height: 300px; width: 300px; margin: auto; border: 2px solid black; background-color: #ccc; font-size: 80px; line-height: 300px; text-align: center; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;0\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 利用防抖实现性能优化 const box = document.querySelector(\u0026#39;.box\u0026#39;) let i = 1 function mouseMove() { box.innerHTML = i++ } box.addEventListener(\u0026#39;mousemove\u0026#39;, _.debounce(mouseMove, 500)) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ②自己手写一个防抖函数来处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box { height: 300px; width: 300px; margin: auto; border: 2px solid black; background-color: #ccc; font-size: 80px; line-height: 300px; text-align: center; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;0\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 利用防抖实现性能优化 const box = document.querySelector(\u0026#39;.box\u0026#39;) let i = 1 function mouseMove() { box.innerHTML = i++ } box.addEventListener(\u0026#39;mousemove\u0026#39;, debounce(mouseMove, 500)) // 定义一个防抖函数 function debounce(fn, t) { let timer // 因为要传入参数，所以debounce必须带小括号 // 而回调函数（函数作为参数传入时）不能带小括号，带上小括号就会立即执行，之后就不再执行 // 所以在debounce内部再返回一个函数，相当于直接把这个函数写在了原本调用debounce()的位置 // 为什么要多此一举，不直接写这个函数？因为要清除定时器，而要清除定时器必须要保证timer在函数执行后不被清除，所以利用了闭包的方法 return function() { if (timer) clearTimeout(timer) timer = setTimeout(function() { fn() // 调用传入的函数 }, t) // t秒后调用 } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 节流（throttle） 所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数\n案例：利用节流处理鼠标移动事件 要求：鼠标在盒子上移动，不管移动多少次，每隔1500ms才+1\n利用lodash的效果图：（不知道为什么触发好像有点问题）\n利用自己写的函数的效果图：\n实现方式有两种：\n①利用lodash提供的节流函数来处理\n_.throttle(func, [wait=0], [options=])\n官方说明：创建一个节流函数，在 wait 秒内最多执行 func 一次的函数。 该函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。 可以提供一个 options 对象决定如何调用 func 方法， options.leading 与|或 options.trailing 决定 wait 前后如何触发。 func 会传入最后一次传入的参数给这个函数。 随后调用的函数返回是最后一次 func 调用的结果。\n参数\nfunc (Function): 要节流的函数。 [wait=0] (number): 需要节流的毫秒。 [options=] (Object): 选项对象。 [options.leading=true] (boolean): 指定调用在节流开始前。 [options.trailing=true] (boolean): 指定调用在节流结束后。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;!-- 在线引入lodash库 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .box { height: 300px; width: 300px; margin: auto; border: 2px solid black; background-color: #ccc; font-size: 80px; line-height: 300px; text-align: center; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;0\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 利用节流实现性能优化 const box = document.querySelector(\u0026#39;.box\u0026#39;) let i = 1 function mouseMove() { box.innerHTML = i++ } box.addEventListener(\u0026#39;mousemove\u0026#39;, _.throttle(mouseMove, 1500)) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ②自己手写一个节流函数来处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box { height: 300px; width: 300px; margin: auto; border: 2px solid black; background-color: #ccc; font-size: 80px; line-height: 300px; text-align: center; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;0\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 利用节流实现性能优化 const box = document.querySelector(\u0026#39;.box\u0026#39;) let i = 1 function mouseMove() { box.innerHTML = i++ } box.addEventListener(\u0026#39;mousemove\u0026#39;, throttle(mouseMove, 1500)) // 自己写的节流函数 function throttle(fn, t) { let timer = null return function() { // 没有定时器时才开启定时器 if (!timer) { // 先调用，再清空 fn() timer = setTimeout(function() { // 清空定时器，在定时器内无法使用clearTimeout() timer = null }, t) } } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 防抖和节流总结 综合案例：页面打开，可以记录上一次的视频播放位置 效果图：\n![](/assets/GIF 2024-11-14 20-14-33.gif)\n分析：\n两个事件:\n①：ontimeupdate 事件在视频/音频（audio/video）当前的播放位置发送改变时触发\n②：onloadeddata 事件在当前帧的数据加载完成且还没有足够的数据播放视频/音频（audio/video）的下一帧时触发\n谁需要节流？ontimeupdate ， 触发频次太高了，我们可以设定 1秒钟触发一次\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;referrer\u0026#34; content=\u0026#34;never\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;页面打开，可以记录上一次的视频播放位置\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { padding: 0; margin: 0; box-sizing: border-box; } .container { width: 1200px; margin: 0 auto; } .video video { width: 100%; padding: 20px 0; } .elevator { position: fixed; top: 280px; right: 20px; z-index: 999; background: #fff; border: 1px solid #e4e4e4; width: 60px; } .elevator a { display: block; padding: 10px; text-decoration: none; text-align: center; color: #999; } .elevator a.active { color: #1286ff; } .outline { padding-bottom: 300px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;http://pip.itcast.cn\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://pip.itcast.cn/img/logo_v3.29b9ba72.png\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;video\u0026#34;\u0026gt; \u0026lt;video src=\u0026#34;https://v.itheima.net/LapADhV6.mp4\u0026#34; controls\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;elevator\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;javascript:;\u0026#34; data-ref=\u0026#34;video\u0026#34;\u0026gt;视频介绍\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;javascript:;\u0026#34; data-ref=\u0026#34;intro\u0026#34;\u0026gt;课程简介\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;javascript:;\u0026#34; data-ref=\u0026#34;outline\u0026#34;\u0026gt;评论列表\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const video = document.querySelector(\u0026#39;video\u0026#39;) // 添加视频播放事件 video.addEventListener(\u0026#39;timeupdate\u0026#39;, _.throttle(() =\u0026gt; { // 把当前视频的播放时间存储到本地 localStorage.setItem(\u0026#39;videoCurrentTime\u0026#39;, video.currentTime) }, 1000)) // 利用节流，一秒执行一次 // 添加视频加载完成事件 video.addEventListener(\u0026#39;loadeddata\u0026#39;, () =\u0026gt; { // 利用逻辑或的中断，让本地没有数据时就取0，一般浏览器在没有本地数据时即便不加这段也会取0 video.currentTime = localStorage.getItem(\u0026#39;videoCurrentTime\u0026#39;) || 0 }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2024-03-27T15:07:19+08:00","permalink":"https://IAmYuanyu.github.io/p/javascript%E8%BF%9B%E9%98%B6/","title":"JavaScript进阶"},{"content":"Web APIs - 第1天笔记 了解 DOM 的结构并掌握其基本的操作，体验 DOM 的在开发中的作用\n知道 ECMAScript 与 JavaScript 的关系 了解 DOM 的相关概念及DOM 的本质是一个对象 掌握查找节点的基本方法 掌握节点属性和文本的操作 能够使用间歇函数创建定时任务 介绍 知道 ECMAScript 与 JavaScript 的关系，Web APIs 是浏览器扩展的功能。\n严格意义上讲，我们在 JavaScript 阶段学习的知识绝大部分属于 ECMAScript 的知识体系，ECMAScript 简称 ES 它提供了一套语言标准规范，如变量、数据类型、表达式、语句、函数等语法规则都是由 ECMAScript 规定的。浏览器将 ECMAScript 大部分的规范加以实现，并且在此基础上又扩展一些实用的功能，这些被扩展出来的内容我们称为 Web APIs。\nECMAScript 运行在浏览器中然后再结合 Web APIs 才是真正的 JavaScript，Web APIs 的核心是 DOM 和 BOM。\n扩展阅读：ECMAScript 规范在不断的更新中，存在多个不同的版本，早期的版本号采用数字顺序编号如 ECMAScript3、ECMAScript5，后来由于更新速度较快便采用年份做为版本号，如 ECMAScript2017、ECMAScript2018 这种格式，ECMAScript6 是 2015 年发布的，常叫做 EMCAScript2015。\n关于 JavaScript 历史的扩展阅读。\n知道 DOM 相关的概念，建立对 DOM 的初步认识，学习 DOM 的基本操作，体会 DOM 的作用\nDOM（Document Object Model）是将整个 HTML 文档的每一个标签元素视为一个对象，这个对象下包含了许多的属性和方法，通过操作这些属性或者调用这些方法实现对 HTML 的动态更新，为实现网页特效以及用户交互提供技术支撑。\n简言之 DOM 是用来动态修改 HTML 的，其目的是开发网页特效及用户交互。\n观察一个小例子：\n上述的例子中当用户分分别点击【开始】或【结束】按钮后，通过右侧调试窗口可以观察到 html 标签的内容在不断的发生改变，这便是通过 DOM 实现的。\n概念 DOM 树 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 文本 \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;链接名\u0026lt;/a\u0026gt; \u0026lt;div id=\u0026#34;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;文本\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如下图所示，将 HTML 文档以树状结构直观的表现出来，我们称之为文档树或 DOM 树，文档树直观的体现了标签与标签之间的关系。\nDOM 节点 节点是文档树的组成部分，每一个节点都是一个 DOM 对象，主要分为元素节点、属性节点、文本节点等。\n【元素节点】其实就是 HTML 标签，如上图中 head、div、body 等都属于元素节点。 【属性节点】是指 HTML 标签中的属性，如上图中 a 标签的 href 属性、div 标签的 class 属性。 【文本节点】是指 HTML 标签的文字内容，如 title 标签中的文字。 【根节点】特指 html 标签。 其它\u0026hellip; document document 是 JavaScript 内置的专门用于 DOM 的对象，该对象包含了若干的属性和方法，document 是学习 DOM 的核心。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;script\u0026gt; // document 是内置的对象 // console.log(typeof document); // 1. 通过 document 获取根节点 console.log(document.documentElement); // 对应 html 标签 // 2. 通过 document 节取 body 节点 console.log(document.body); // 对应 body 标签 // 3. 通过 document.write 方法向网页输出内容 document.write(\u0026#39;Hello World!\u0026#39;); \u0026lt;/script\u0026gt; 上述列举了 document 对象的部分属性和方法，我们先对 document 有一个整体的认识。\n获取DOM对象 querySelector ： 满足条件的第一个元素\n这种方式获取的元素可以直接修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3 id=\u0026#34;title\u0026#34;\u0026gt;查找元素类型节点\u0026lt;/h3\u0026gt; \u0026lt;p class=\u0026#34;para\u0026#34;\u0026gt;从整个 DOM 树中查找 DOM 节点是学习 DOM 的第一个步骤。\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; const h3 = document.querySelector(\u0026#39;#title\u0026#39;) h3.style.color = \u0026#39;red\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果： querySelectorAll ： 满足条件的元素集合，返回伪数组：有长度有索引号但没有pop()、push()等数组方法的数组\n这种方式获取的元素不能直接全部修改，若直接对数组修改会报错\n只能通过遍历的方式依次给里面的元素做修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3 id=\u0026#34;title\u0026#34;\u0026gt;查找元素类型节点\u0026lt;/h3\u0026gt; \u0026lt;p class=\u0026#34;para\u0026#34;\u0026gt;从整个 DOM 树中查找 DOM 节点是学习 DOM 的第一个步骤。\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;元素1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;元素2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;元素3\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;元素4\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; const lis = document.querySelectorAll(\u0026#39;li\u0026#39;) // 获取第一个li元素 console.log(lis) //lis.style.color = \u0026#39;red\u0026#39;\t// 会报错 lis[0].style.color = \u0026#39;red\u0026#39;\t// 每次只能具体修改数组内的某个元素 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n了解其他方式（因为目前已较少使用）\ngetElementById ： 根据id获取一个元素\n1 document.getElementById(\u0026#39;title\u0026#39;) // 获取id为title的元素，注意此时不用加#号 getElementsByTagName ： 根据标签获取一类元素，返回伪数组\n1 document.getElementsByTagName(\u0026#39;div\u0026#39;) // 获取页面所有的div getElementsByClassName ： 根据类名获取元素，返回伪数组\n1 document.getElementsByClassName(\u0026#39;head\u0026#39;) // 获取页面所有类名为head的元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;DOM - 查找节点\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3 id=\u0026#34;title\u0026#34;\u0026gt;查找元素类型节点\u0026lt;/h3\u0026gt; \u0026lt;p class=\u0026#34;para\u0026#34;\u0026gt;从整个 DOM 树中查找 DOM 节点是学习 DOM 的第一个步骤。\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;元素1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;元素2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;元素3\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;元素4\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; const p = document.querySelector(\u0026#39;p\u0026#39;) // 获取第一个p元素 const p = document.querySelector(\u0026#39;.para\u0026#39;) // 获取第一个类名为para的元素 const h3 = document.querySelector(\u0026#39;#title\u0026#39;)\t// 获取id为title的元素 const li = document.querySelector(\u0026#39;ul li\u0026#39;)\t// 获取第一个ul元素的第一个后代元素li const lis = document.querySelectorAll(\u0026#39;li\u0026#39;) // 获取所有li元素 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 总结：\nquerySelector和querySelectorAll的小括号内必须是字符串，即必须加引号\ndocument.getElementById 专门获取元素类型节点，根据标签的 id 属性查找\n任意 DOM 对象都包含 nodeType 属性，用来检检测节点类型\n操作元素内容 通过修改 DOM 的文本内容，动态改变网页的内容。\ninnerText 将文本内容添加/更新到任意标签位置，文本中包含的标签不会被解析。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;intro1\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;intro2\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // innerText 将文本内容添加/更新到任意标签位置 const intro1 = document.querySelector(\u0026#39;.intro1\u0026#39;) const intro2 = document.querySelector(\u0026#39;.intro2\u0026#39;) intro1.innerText = \u0026#39;嗨~ 我叫李雷！\u0026#39; intro2.innerText = \u0026#39;\u0026lt;h4\u0026gt;嗨~ 我叫李雷！\u0026lt;/h4\u0026gt;\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\ninnerHTML 将文本内容添加/更新到任意标签位置，文本中包含的标签会被解析。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;intro1\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;intro2\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // innerHTML 将文本内容添加/更新到任意标签位置 const intro1 = document.querySelector(\u0026#39;.intro1\u0026#39;) const intro2 = document.querySelector(\u0026#39;.intro2\u0026#39;) intro1.innerHTML = \u0026#39;嗨~ 我叫韩梅梅！\u0026#39; intro2.innerHTML = \u0026#39;\u0026lt;h4\u0026gt;嗨~ 我叫韩梅梅！\u0026lt;/h4\u0026gt;\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n总结：如果文本内容中包含 html 标签时推荐使用 innerHTML，否则建议使用 innerText 属性。\n年会抽奖案例 需求：从数组随机抽取一等奖、二等奖和三等奖，显示到对应的标签里面。\n分析：\n①：声明数组: const personArr = [\u0026lsquo;周杰伦\u0026rsquo;, \u0026lsquo;刘德华\u0026rsquo;, \u0026lsquo;周星驰\u0026rsquo;, \u0026lsquo;Pink老师\u0026rsquo;, \u0026lsquo;张学友\u0026rsquo;]\n②：一等奖:随机生成一个数字（0~数组长度），找到对应数组的名字\n③：通过innerText 或者 innerHTML 将名字写入span元素内部\n④： 二等奖依次类推\n效果图：\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;年会抽奖\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .wrapper { width: 840px; height: 420px; background: url(./images/bg01.jpg) no-repeat center / cover; padding: 100px 250px; box-sizing: border-box; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;strong\u0026gt;传智教育年会抽奖\u0026lt;/strong\u0026gt; \u0026lt;h1\u0026gt;一等奖：\u0026lt;span id=\u0026#34;one\u0026#34;\u0026gt;???\u0026lt;/span\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h3\u0026gt;二等奖：\u0026lt;span id=\u0026#34;two\u0026#34;\u0026gt;???\u0026lt;/span\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;h5\u0026gt;三等奖：\u0026lt;span id=\u0026#34;three\u0026#34;\u0026gt;???\u0026lt;/span\u0026gt;\u0026lt;/h5\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 声明数组 const personArr = [\u0026#39;周杰伦\u0026#39;, \u0026#39;刘德华\u0026#39;, \u0026#39;周星驰\u0026#39;, \u0026#39;Pink老师\u0026#39;, \u0026#39;张学友\u0026#39;] // 抽取一等奖 // 获取随机数，即数组下标 let random = Math.floor(Math.random() * personArr.length) // 获取页面中的一等奖 const one = document.querySelector(\u0026#39;#one\u0026#39;) // 把名字给一等奖 one.innerHTML = personArr[random] // 从数组中删除被抽中的人 personArr.splice(random,1) // 抽取二等奖 // 获取随机数，即数组下标 random = Math.floor(Math.random() * personArr.length) // 获取页面中的二等奖 const two = document.querySelector(\u0026#39;#two\u0026#39;) // 把名字给二等奖 two.innerHTML = personArr[random] // 从数组中删除被抽中的人 personArr.splice(random,1) // 抽取三等奖 // 获取随机数，即数组下标 random = Math.floor(Math.random() * personArr.length) // 获取页面中的三等奖 const three = document.querySelector(\u0026#39;#three\u0026#39;) // 把名字给三等奖 three.innerHTML = personArr[random] // 从数组中删除被抽中的人 personArr.splice(random,1) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 操作元素属性 有3种方式可以实现对属性的修改：\n常用属性修改 直接能过属性名修改，最简洁的语法 1 2 3 4 5 6 7 8 \u0026lt;script\u0026gt; // 1. 获取 img 对应的 DOM 元素 const pic = document.querySelector(\u0026#39;.pic\u0026#39;) // 2. 修改属性 pic.src = \u0026#39;./images/lion.webp\u0026#39; pic.width = 400; pic.alt = \u0026#39;图片不见了...\u0026#39; \u0026lt;/script\u0026gt; 控制样式属性 应用【修改样式】，通过修改行内样式 style 属性，实现对样式的动态修改。 通过元素节点获得的 style 属性本身的数据类型也是对象，如 box.style.color、box.style.width 分别用来获取元素节点 CSS 样式的 color 和 width 的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;练习 - 修改样式\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;随便一些文本内容\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 获取 DOM 节点 const box = document.querySelector(\u0026#39;.intro\u0026#39;) box.style.color = \u0026#39;red\u0026#39; box.style.width = \u0026#39;300px\u0026#39; // 记得加单位 // css 属性的 - 连接符与 JavaScript 的 减运算符 // 冲突，所以要改成驼峰法 box.style.backgroundColor = \u0026#39;pink\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 任何标签都有 style 属性，通过 style 属性可以动态更改网页标签的样式，如要遇到 css 属性中包含字符 - 时，要将 - 去掉并将其后面的字母改成大写，如 background-color 要写成 box.style.backgroundColor\n注：页面唯一元素，如body可以直接使用不用获取\n1 document.body.style.…… 操作类名(className) 操作CSS 如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于css类名的形式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;练习 - 修改样式\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .pink { background: pink; color: hotpink; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;随便一些文本内容\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 获取 DOM 节点 const box = document.querySelector(\u0026#39;.box\u0026#39;) // 把box的类名设置为\u0026#39;pink\u0026#39;的类，这样可以快速为box加上pink类的样式 // 注：会覆盖掉原类名 box.className = \u0026#39;pink\u0026#39; // 若想保留原来的类名，就在设置时把原类名加上 box.className = \u0026#39;box pink\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注意：\n1.由于class是关键字, 所以使用className去代替\n2.className是使用新值换旧值, 如果需要添加一个类,需要保留之前的类名\n通过 classList 操作类控制CSS 为了解决className 容易覆盖以前的类名，我们可以通过classList方式追加和删除类名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 200px; height: 200px; background-color: pink; } .active { width: 300px; height: 300px; background-color: hotpink; margin-left: 100px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;one\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 1.获取元素 const box = document.querySelector(\u0026#39;div\u0026#39;) // add是个方法添加类 box.classList.add(\u0026#39;active\u0026#39;) // remove() 移除类 box.classList.remove(\u0026#39;one\u0026#39;) // 切换类，有就删除该类名，没有就加上该类名 box.classList.toggle(\u0026#39;one\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 随机轮播图案例 需求：当我们刷新页面，页面中的轮播图会显示不同图片以及样式\n模块：\n①：图片会随机变换\n②：底部盒子背景颜色和文字内容会变换\n③：小圆点随机一个高亮显示\n分析：\n①： 准备一个数组对象，里面包含详细信息（素材包含）\n②： 随机选择一个数字，选出数组对应的对象，更换图片，底部盒子背景颜色，以及文字内容\n③： 利用这个随机数字，让小圆点添加高亮的类（addClass） 利用css 结构伪类选择器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;轮播图点击切换\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { box-sizing: border-box; } .slider { width: 560px; height: 400px; overflow: hidden; } .slider-wrapper { width: 100%; height: 320px; } .slider-wrapper img { width: 100%; height: 100%; display: block; } .slider-footer { height: 80px; background-color: rgb(100, 67, 68); padding: 12px 12px 0 12px; position: relative; } .slider-footer .toggle { position: absolute; right: 0; top: 12px; display: flex; } .slider-footer .toggle button { margin-right: 12px; width: 28px; height: 28px; appearance: none; border: none; background: rgba(255, 255, 255, 0.1); color: #fff; border-radius: 4px; cursor: pointer; } .slider-footer .toggle button:hover { background: rgba(255, 255, 255, 0.2); } .slider-footer p { margin: 0; color: #fff; font-size: 18px; margin-bottom: 10px; } .slider-indicator { margin: 0; padding: 0; list-style: none; display: flex; align-items: center; } .slider-indicator li { width: 8px; height: 8px; margin: 4px; border-radius: 50%; background: #fff; opacity: 0.4; cursor: pointer; } .slider-indicator li.active { width: 12px; height: 12px; opacity: 1; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;slider\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slider-wrapper\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./images/slider01.jpg\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;slider-footer\u0026#34;\u0026gt; \u0026lt;p\u0026gt;对人类来说会不会太超前了？\u0026lt;/p\u0026gt; \u0026lt;ul class=\u0026#34;slider-indicator\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;active\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;div class=\u0026#34;toggle\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;prev\u0026#34;\u0026gt;\u0026amp;lt;\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;next\u0026#34;\u0026gt;\u0026amp;gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 初始数据 const sliderData = [ { url: \u0026#39;./images/slider01.jpg\u0026#39;, title: \u0026#39;对人类来说会不会太超前了？\u0026#39;, color: \u0026#39;rgb(100, 67, 68)\u0026#39; }, { url: \u0026#39;./images/slider02.jpg\u0026#39;, title: \u0026#39;开启剑与雪的黑暗传说！\u0026#39;, color: \u0026#39;rgb(43, 35, 26)\u0026#39; }, { url: \u0026#39;./images/slider03.jpg\u0026#39;, title: \u0026#39;真正的jo厨出现了！\u0026#39;, color: \u0026#39;rgb(36, 31, 33)\u0026#39; }, { url: \u0026#39;./images/slider04.jpg\u0026#39;, title: \u0026#39;李玉刚：让世界通过B站看到东方大国文化\u0026#39;, color: \u0026#39;rgb(139, 98, 66)\u0026#39; }, { url: \u0026#39;./images/slider05.jpg\u0026#39;, title: \u0026#39;快来分享你的寒假日常吧~\u0026#39;, color: \u0026#39;rgb(67, 90, 92)\u0026#39; }, { url: \u0026#39;./images/slider06.jpg\u0026#39;, title: \u0026#39;哔哩哔哩小年YEAH\u0026#39;, color: \u0026#39;rgb(166, 131, 143)\u0026#39; }, { url: \u0026#39;./images/slider07.jpg\u0026#39;, title: \u0026#39;一站式解决你的电脑配置问题！！！\u0026#39;, color: \u0026#39;rgb(53, 29, 25)\u0026#39; }, { url: \u0026#39;./images/slider08.jpg\u0026#39;, title: \u0026#39;谁不想和小猫咪贴贴呢！\u0026#39;, color: \u0026#39;rgb(99, 72, 114)\u0026#39; }, ] function getRandomInt(N, M) { return Math.floor(Math.random() * (M - N + 1)) + N } // 获得一个随机数 const random = getRandomInt(0, sliderData.length - 1) // 获取图片 const img = document.querySelector(\u0026#39;.slider-wrapper img\u0026#39;) // 修改图片路径 img.src = sliderData[random].url // 获取文字 const p = document.querySelector(\u0026#39;.slider-footer p\u0026#39;) // 修改文字 p.innerHTML = sliderData[random].title // 获取背景 const footer = document.querySelector(\u0026#39;.slider-footer\u0026#39;) // 修改背景颜色 footer.style.backgroundColor = sliderData[random].color // 获取小圆点 const lis = document.querySelectorAll(\u0026#39;.slider-indicator li\u0026#39;) // 把原本小圆点的高亮取消 for (let i = 0; i \u0026lt; lis.length; i++) { lis[i].classList.remove(\u0026#39;active\u0026#39;) } // 修改对应小圆点高亮 lis[random].classList.toggle(\u0026#39;active\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n操作表单元素属性 表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框\n正常的有属性有取值的跟其他的标签属性没有任何区别\n获取：DOM对象.属性名\n设置：DOM对象.属性名= 新值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value=\u0026#34;请输入\u0026#34;\u0026gt; \u0026lt;button disabled\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; class=\u0026#34;agree\u0026#34;\u0026gt; \u0026lt;script\u0026gt; // 1. 获取元素 let input = document.querySelector(\u0026#39;input\u0026#39;) // 2. 取值或者设置值 得到input里面的值可以用 value // input.innerHTML 是获取不到东西的 input.value = \u0026#39;小米手机\u0026#39; input.type = \u0026#39;password\u0026#39; // 2. 启用按钮 let btn = document.querySelector(\u0026#39;button\u0026#39;) // disabled 不可用 = false 这样可以让按钮启用 btn.disabled = false // 3. 勾选复选框 let checkbox = document.querySelector(\u0026#39;.agree\u0026#39;) checkbox.checked = true // 注：checkbox.checked = \u0026#39;true\u0026#39; 时，也会选中，是因为\u0026#39;true\u0026#39;被隐式转换成true，属于歪打正着 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 自定义属性 标准属性: 标签天生自带的属性 比如class id title等, 可以直接使用点语法操作比如： disabled、checked、selected\n自定义属性：\n在html5中推出来了专门的data-自定义属性\n在标签上一律以data-开头\n在DOM对象上一律以dataset对象方式获取\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div data-id=\u0026#34;1\u0026#34;\u0026gt; 自定义属性 \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 1. 获取元素 let div = document.querySelector(\u0026#39;div\u0026#39;) // 2. 获取自定义属性值的集合 console.log(div.dataset) // 3. 获取自定义属性某个具体的值 console.log(div.dataset.id) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 间歇函数 知道间歇函数的作用，利用间歇函数创建定时任务。\nsetInterval 是 JavaScript 中内置的函数，它的作用是间隔固定的时间自动重复执行另一个函数，也叫定时器函数。\n1 2 3 setInterval(函数，间隔时间) // 作用：每隔一段时间调用这个函数 // 间隔时间单位是毫秒 例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;script\u0026gt; // 1. 定义一个普通函数 function repeat() { console.log(\u0026#39;不知疲倦的执行下去....\u0026#39;) } // 2. 使用 setInterval 调用 repeat 函数，开启定时器 // 间隔 1000 毫秒，重复调用 repeat let n = setInterval(repeat, 1000) let m = setInterval(repeat, 1000) console.log(n) // 1 console.log(m) // 2 // 注：1.函数名不需要加括号；2.定时器返回的是一个id数字 // 3. 关闭定时器 clearInterval(n)\t// 关闭id为n的定时器 // 4.重新开启 n = setInterval(repeat, 1000) \u0026lt;/script\u0026gt; 阅读用户协议案例 需求：按钮60秒之后才可以使用\n分析：\n①：开始先把按钮禁用（disabled 属性）\n②：一定要获取元素\n③：函数内处理逻辑\n秒数开始减减\n按钮里面的文字跟着一起变化\n如果秒数等于0 停止定时器 里面文字变为 同意 最后 按钮可以点击\n效果图：\n![](/assets/GIF 2024-10-22 17-14-45.gif)\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;textarea name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; cols=\u0026#34;30\u0026#34; rows=\u0026#34;10\u0026#34;\u0026gt; 用户注册协议 欢迎注册成为京东用户！在您注册过程中，您需要完成我们的注册流程并通过点击同意的形式在线签署以下协议，请您务必仔细阅读、充分理解协议中的条款内容后再点击同意（尤其是以粗体或下划线标识的条款，因为这些条款可能会明确您应履行的义务或对您的权利有所限制）。 【请您注意】如果您不同意以下协议全部或任何条款约定，请您停止注册。您停止注册后将仅可以浏览我们的商品信息但无法享受我们的产品或服务。如您按照注册流程提示填写信息，阅读并点击同意上述协议且完成全部注册流程后，即表示您已充分阅读、理解并接受协议的全部内容，并表明您同意我们可以依据协议内容来处理您的个人信息，并同意我们将您的订单信息共享给为完成此订单所必须的第三方合作方（详情查看 \u0026lt;/textarea\u0026gt; \u0026lt;br\u0026gt; \u0026lt;button class=\u0026#34;btn\u0026#34; disabled\u0026gt;我已经阅读用户协议(5)\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; // 获取元素 const btn = document.querySelector(\u0026#39;button\u0026#39;) // 倒计时 let i = 5 let n = setInterval(function() { i-- btn.innerHTML = `我已经阅读用户协议(${i})` if (i === 0) { // 5s后，关闭倒计时，并开启按钮 clearInterval(n) btn.innerHTML = \u0026#39;我已经阅读用户协议\u0026#39; btn.disabled = false } }, 1000) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 今日单词 单词 说明 解释 setInterval 定时器 setInterval(repeat, 1000) 综合案例 轮播图定时器版\n需求：每隔一秒钟切换一个图片\n分析：\n①：准备一个数组对象，里面包含详细信息（素材包含）\n②：获取元素\n③：设置定时器函数\n​\t设置一个变量++\n​\t找到变量对应的对象\n​\t更改图片、文字信息\n​\t激活小圆点：移除上一个高亮的类名，当前变量对应的小圆点添加类\n④：处理图片自动复原从头播放（放到变量++后面，紧挨）\n​\t如果图片播放到最后一张， 就是大于等于数组的长度\n​\t则把变量重置为0\n效果图：\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;综合5\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { box-sizing: border-box; } .slider { width: 560px; height: 400px; overflow: hidden; } .slider-wrapper { width: 100%; height: 320px; } .slider-wrapper img { width: 100%; height: 100%; display: block; } .slider-footer { height: 80px; background-color: rgb(100, 67, 68); padding: 12px 12px 0 12px; position: relative; } .slider-footer .toggle { position: absolute; right: 0; top: 12px; display: flex; } .slider-footer .toggle button { margin-right: 12px; width: 28px; height: 28px; appearance: none; border: none; background: rgba(255, 255, 255, 0.1); color: #fff; border-radius: 4px; cursor: pointer; } .slider-footer .toggle button:hover { background: rgba(255, 255, 255, 0.2); } .slider-footer p { margin: 0; color: #fff; font-size: 18px; margin-bottom: 10px; } .slider-indicator { margin: 0; padding: 0; list-style: none; display: flex; align-items: center; } .slider-indicator li { width: 8px; height: 8px; margin: 4px; border-radius: 50%; background: #fff; opacity: 0.4; cursor: pointer; } .slider-indicator li.active { width: 12px; height: 12px; opacity: 1; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;slider\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slider-wrapper\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./images/slider01.jpg\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;slider-footer\u0026#34;\u0026gt; \u0026lt;p\u0026gt;对人类来说会不会太超前了？\u0026lt;/p\u0026gt; \u0026lt;ul class=\u0026#34;slider-indicator\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;active\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;div class=\u0026#34;toggle\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;prev\u0026#34;\u0026gt;\u0026amp;lt;\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;next\u0026#34;\u0026gt;\u0026amp;gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 1. 初始数据 const sliderData = [ { url: \u0026#39;./images/slider01.jpg\u0026#39;, title: \u0026#39;对人类来说会不会太超前了？\u0026#39;, color: \u0026#39;rgb(100, 67, 68)\u0026#39; }, { url: \u0026#39;./images/slider02.jpg\u0026#39;, title: \u0026#39;开启剑与雪的黑暗传说！\u0026#39;, color: \u0026#39;rgb(43, 35, 26)\u0026#39; }, { url: \u0026#39;./images/slider03.jpg\u0026#39;, title: \u0026#39;真正的jo厨出现了！\u0026#39;, color: \u0026#39;rgb(36, 31, 33)\u0026#39; }, { url: \u0026#39;./images/slider04.jpg\u0026#39;, title: \u0026#39;李玉刚：让世界通过B站看到东方大国文化\u0026#39;, color: \u0026#39;rgb(139, 98, 66)\u0026#39; }, { url: \u0026#39;./images/slider05.jpg\u0026#39;, title: \u0026#39;快来分享你的寒假日常吧~\u0026#39;, color: \u0026#39;rgb(67, 90, 92)\u0026#39; }, { url: \u0026#39;./images/slider06.jpg\u0026#39;, title: \u0026#39;哔哩哔哩小年YEAH\u0026#39;, color: \u0026#39;rgb(166, 131, 143)\u0026#39; }, { url: \u0026#39;./images/slider07.jpg\u0026#39;, title: \u0026#39;一站式解决你的电脑配置问题！！！\u0026#39;, color: \u0026#39;rgb(53, 29, 25)\u0026#39; }, { url: \u0026#39;./images/slider08.jpg\u0026#39;, title: \u0026#39;谁不想和小猫咪贴贴呢！\u0026#39;, color: \u0026#39;rgb(99, 72, 114)\u0026#39; }, ] // 获取元素 const img = document.querySelector(\u0026#39;.slider-wrapper img\u0026#39;) const div = document.querySelector(\u0026#39;.slider-footer\u0026#39;) const p = document.querySelector(\u0026#39;.slider-footer p\u0026#39;) const lis = document.querySelectorAll(\u0026#39;.slider-indicator li\u0026#39;) // 开启定时器 let i = 0 let n = setInterval(function() { i++ // 切换图片和文字和文字的背景颜色 // 页面默认就是第一张图，所以从第二张图开始切换 img.src = sliderData[i].url p.innerHTML = sliderData[i].title div.style.backgroundColor = sliderData[i].color // 切换高亮的小圆点 document.querySelector(\u0026#39;.active\u0026#39;).classList.remove(\u0026#39;active\u0026#39;) // 删除当前高亮的小圆点 lis[i].classList.add(\u0026#39;active\u0026#39;) // 使与图文相匹配的小圆点高亮 if (i === sliderData.length - 1) {// 实现无限循环的效果 i = -1 } }, 1000) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Web APIs - 第2天 学会通过为DOM注册事件来实现可交互的网页特效。\n能够判断函数运行的环境并确字 this 所指代的对象 理解事件的作用，知道应用事件的 3 个步骤 学习会为 DOM 注册事件，实现简单可交互的网页特交。\n事件 事件是编程语言中的术语，它是用来描述程序的行为或状态的，一旦行为或状态发生改变，便立即调用一个函数。\n例如：用户使用【鼠标点击】网页中的一个按钮、用户使用【鼠标拖拽】网页中的一张图片\n事件监听 结合 DOM 使用事件时，需要为 DOM 对象添加事件监听，等待事件发生（触发）时，便立即调用一个函数。\naddEventListener 是 DOM 对象专门用来添加事件监听的方法，它的两个参数分别为【事件类型】和【事件回调】。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;事件监听\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;事件监听\u0026lt;/h3\u0026gt; \u0026lt;p id=\u0026#34;text\u0026#34;\u0026gt;为 DOM 元素添加事件监听，等待事件发生，便立即执行一个函数。\u0026lt;/p\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击改变文字颜色\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; // 1. 获取 button 对应的 DOM 对象 const btn = document.querySelector(\u0026#39;#btn\u0026#39;) // 2. 添加事件监听 btn.addEventListener(\u0026#39;click\u0026#39;, function () { console.log(\u0026#39;等待事件被触发...\u0026#39;) // 改变 p 标签的文字颜色 let text = document.getElementById(\u0026#39;text\u0026#39;) text.style.color = \u0026#39;red\u0026#39; }) // 3. 只要用户点击了按钮，事件便触发了！！！ \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 完成事件监听分成3个步骤：\n获取 DOM 元素 通过 addEventListener 方法为 DOM 节点添加事件监听 等待事件触发，如用户点击了某个按钮时便会触发 click 事件类型 事件触发后，相对应的回调函数会被执行 大白话描述：所谓的事件无非就是找个机会（事件触发）调用一个函数（回调函数）。\n事件类型 click 译成中文是【点击】的意思，它的含义是监听（等着）用户鼠标的单击操作，除了【单击】还有【双击】dblclick\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; // 双击事件类型 btn.addEventListener(\u0026#39;dblclick\u0026#39;, function () { console.log(\u0026#39;等待事件被触发...\u0026#39;); // 改变 p 标签的文字颜色 const text = document.querySelector(\u0026#39;.text\u0026#39;) text.style.color = \u0026#39;red\u0026#39; }) // 只要用户双击击了按钮，事件便触发了！！！ \u0026lt;/script\u0026gt; 结论：【事件类型】决定了事件被触发的方式，如 click 代表鼠标单击，dblclick 代表鼠标双击。\n事件处理程序 addEventListener 的第2个参数是函数，这个函数会在事件被触发时立即被调用，在这个函数中可以编写任意逻辑的代码，如改变 DOM 文本颜色、文本内容等。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; // 双击事件类型 btn.addEventListener(\u0026#39;dblclick\u0026#39;, function () { console.log(\u0026#39;等待事件被触发...\u0026#39;) const text = document.querySelector(\u0026#39;.text\u0026#39;) // 改变 p 标签的文字颜色 text.style.color = \u0026#39;red\u0026#39; // 改变 p 标签的文本内容 text.style.fontSize = \u0026#39;20px\u0026#39; }) \u0026lt;/script\u0026gt; 结论：【事件处理程序】决定了事件触发后应该执行的逻辑。\n案例：关闭广告 效果图：\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;style\u0026gt; .ad { height: 300px; width: 300px; background-color: #ccc; margin: auto; background-image: url(../双金！.jpg); } .close { height: 20px; width: 20px; text-align: center; background-color: #abc; border: 1px solid black; float: right; cursor: pointer; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;ad\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;close\u0026#34;\u0026gt;X\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const close = document.querySelector(\u0026#39;.close\u0026#39;) close.addEventListener(\u0026#39;click\u0026#39;,function() { const ad = document.querySelector(\u0026#39;.ad\u0026#39;) ad.style.display = \u0026#39;none\u0026#39; }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 案例：随机点名 业务分析：\n① 点击开始按钮随机抽取数组的一个数据，放到页面中\n② 点击结束按钮删除数组当前抽取的一个数据\n③ 当抽取到最后一个数据的时候，两个按钮同时禁用（写点开始里面，只剩最后一个数据不用抽了）\n核心：利用定时器快速展示，停止定时器结束展示\n效果图：\n![](/assets/GIF 2024-10-22 20-26-24.gif)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } h2 { text-align: center; } .box { width: 600px; margin: 50px auto; display: flex; font-size: 25px; line-height: 40px; } .name { width: 450px; height: 40px; color: red; } .btns { text-align: center; } .btns button { width: 120px; height: 35px; margin: 0 50px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;随机点名\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;span\u0026gt;名字是：\u0026lt;/span\u0026gt; \u0026lt;div class=\u0026#34;name\u0026#34;\u0026gt;这里显示姓名\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;btns\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;start\u0026#34;\u0026gt;开始\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;end\u0026#34;\u0026gt;结束\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 数据数组 const arr = [\u0026#39;马超\u0026#39;, \u0026#39;黄忠\u0026#39;, \u0026#39;赵云\u0026#39;, \u0026#39;关羽\u0026#39;, \u0026#39;张飞\u0026#39;] // 获取元素 const start = document.querySelector(\u0026#39;.start\u0026#39;) const end = document.querySelector(\u0026#39;.end\u0026#39;) const name = document.querySelector(\u0026#39;.name\u0026#39;) // 添加点击事件 let timerId let random start.addEventListener(\u0026#39;click\u0026#39;,function() { timerId = setInterval(function() { random = Math.floor(Math.random() * arr.length) name.innerHTML = arr[random] // 就剩一人时就不用再抽了，禁用按钮并关闭定时器 if (arr.length === 1) { start.disabled = end.disabled = true clearInterval(timerId) } }, 10) // 防止重复点击形成bug start.disabled = true }) end.addEventListener(\u0026#39;click\u0026#39;,function() { clearInterval(timerId) // 删除抽中的数组元素 arr.splice(random,1) // 解除开始按钮的禁用 start.disabled = false }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 事件类型 将众多的事件类型分类可分为：鼠标事件、键盘事件、表单事件、焦点事件等，我们逐一展开学习。\n鼠标事件 鼠标事件是指跟鼠标操作相关的事件，如单击、双击、移动等。\nmouseenter监听鼠标是否移入 DOM 元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;鼠标事件\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;监听与鼠标相关的操作\u0026lt;/p\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 需要事件监听的 DOM 元素 const box = document.querySelector(\u0026#39;.box\u0026#39;); // 监听鼠标是移入当前 DOM 元素 box.addEventListener(\u0026#39;mouseenter\u0026#39;, function () { // 修改文本内容 this.innerText = \u0026#39;鼠标移入了...\u0026#39;; // 修改光标的风格 this.style.cursor = \u0026#39;move\u0026#39;; }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; mouseleave 监听鼠标是否移出 DOM 元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;鼠标事件\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;监听与鼠标相关的操作\u0026lt;/p\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 需要事件监听的 DOM 元素 const box = document.querySelector(\u0026#39;.box\u0026#39;); // 监听鼠标是移出当前 DOM 元素 box.addEventListener(\u0026#39;mouseleave\u0026#39;, function () { // 修改文本内容 this.innerText = \u0026#39;鼠标移出了...\u0026#39;; }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 鼠标经过事件：\nmouseover 和 mouseout 会有冒泡效果\nmouseenter 和 mouseleave 没有冒泡效果 (推荐)\n键盘事件 keydown 键盘按下触发（按住不放会一直触发） keyup 键盘抬起触发\n焦点事件 focus 获得焦点\nblur 失去焦点\n文本框输入事件 input 用户输入事件\n案例：轮播图点击切换 需求：当点击左右的按钮，可以切换轮播图，鼠标不在轮播图上时自动轮播，鼠标在轮播图上时停止轮播，点击小圆点跳转至对应轮播图\n分析：\n①：右侧按钮点击，变量++，如果大于等于8，则复原0\n②：左侧按钮点击，变量\u0026ndash;，如果小于0，则复原最后一张\n③：鼠标经过暂停定时器\n④：鼠标离开开启定时器\n效果图：\n![](/assets/GIF 2024-10-22 22-20-03.gif)\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;轮播图点击切换\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { box-sizing: border-box; } .slider { width: 560px; height: 400px; overflow: hidden; } .slider-wrapper { width: 100%; height: 320px; } .slider-wrapper img { width: 100%; height: 100%; display: block; } .slider-footer { height: 80px; background-color: rgb(100, 67, 68); padding: 12px 12px 0 12px; position: relative; } .slider-footer .toggle { position: absolute; right: 0; top: 12px; display: flex; } .slider-footer .toggle button { margin-right: 12px; width: 28px; height: 28px; appearance: none; border: none; background: rgba(255, 255, 255, 0.1); color: #fff; border-radius: 4px; cursor: pointer; } .slider-footer .toggle button:hover { background: rgba(255, 255, 255, 0.2); } .slider-footer p { margin: 0; color: #fff; font-size: 18px; margin-bottom: 10px; } .slider-indicator { margin: 0; padding: 0; list-style: none; display: flex; align-items: center; } .slider-indicator li { width: 8px; height: 8px; margin: 4px; border-radius: 50%; background: #fff; opacity: 0.4; cursor: pointer; } .slider-indicator li.active { width: 12px; height: 12px; opacity: 1; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;slider\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slider-wrapper\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./images/slider01.jpg\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;slider-footer\u0026#34;\u0026gt; \u0026lt;p\u0026gt;对人类来说会不会太超前了？\u0026lt;/p\u0026gt; \u0026lt;ul class=\u0026#34;slider-indicator\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;active\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;div class=\u0026#34;toggle\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;prev\u0026#34;\u0026gt;\u0026amp;lt;\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;next\u0026#34;\u0026gt;\u0026amp;gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 初始数据 const data = [ { url: \u0026#39;./images/slider01.jpg\u0026#39;, title: \u0026#39;对人类来说会不会太超前了？\u0026#39;, color: \u0026#39;rgb(100, 67, 68)\u0026#39; }, { url: \u0026#39;./images/slider02.jpg\u0026#39;, title: \u0026#39;开启剑与雪的黑暗传说！\u0026#39;, color: \u0026#39;rgb(43, 35, 26)\u0026#39; }, { url: \u0026#39;./images/slider03.jpg\u0026#39;, title: \u0026#39;真正的jo厨出现了！\u0026#39;, color: \u0026#39;rgb(36, 31, 33)\u0026#39; }, { url: \u0026#39;./images/slider04.jpg\u0026#39;, title: \u0026#39;李玉刚：让世界通过B站看到东方大国文化\u0026#39;, color: \u0026#39;rgb(139, 98, 66)\u0026#39; }, { url: \u0026#39;./images/slider05.jpg\u0026#39;, title: \u0026#39;快来分享你的寒假日常吧~\u0026#39;, color: \u0026#39;rgb(67, 90, 92)\u0026#39; }, { url: \u0026#39;./images/slider06.jpg\u0026#39;, title: \u0026#39;哔哩哔哩小年YEAH\u0026#39;, color: \u0026#39;rgb(166, 131, 143)\u0026#39; }, { url: \u0026#39;./images/slider07.jpg\u0026#39;, title: \u0026#39;一站式解决你的电脑配置问题！！！\u0026#39;, color: \u0026#39;rgb(53, 29, 25)\u0026#39; }, { url: \u0026#39;./images/slider08.jpg\u0026#39;, title: \u0026#39;谁不想和小猫咪贴贴呢！\u0026#39;, color: \u0026#39;rgb(99, 72, 114)\u0026#39; }, ] // 获取元素 const img = document.querySelector(\u0026#39;.slider-wrapper img\u0026#39;) const p = document.querySelector(\u0026#39;.slider-footer p\u0026#39;) const lis = document.querySelectorAll(\u0026#39;.slider-indicator li\u0026#39;) const slider_footer = document.querySelector(\u0026#39;.slider-footer\u0026#39;) const prev = document.querySelector(\u0026#39;.prev\u0026#39;) const next = document.querySelector(\u0026#39;.next\u0026#39;) const slider = document.querySelector(\u0026#39;.slider\u0026#39;) // 声明一个渲染函数方便复用 function sliderChange(i) { // 更换图片、文字和背景颜色 img.src = data[i].url p.innerHTML = data[i].title slider_footer.style.backgroundColor = data[i].color // 修改高亮的小圆点 document.querySelector(\u0026#39;.slider-indicator .active\u0026#39;).classList.remove(\u0026#39;active\u0026#39;) document.querySelector(`.slider-indicator li:nth-child(${i + 1})`).classList.add(\u0026#39;active\u0026#39;) } // 点击事件 let i = 0 // 右边按钮被点击时 next.addEventListener(\u0026#39;click\u0026#39;, function() { i++ // 若i大于等于数组长度（即超过最后一个时）就复原为0 // 为什么不用等于，而用大于等于？防止点太快，程序没反应过来就到再下一个了导致bug i = i \u0026gt;= data.length ? 0 : i // 调用渲染函数 sliderChange(i) }) // 左边按钮被点击时 prev.addEventListener(\u0026#39;click\u0026#39;,function() { i-- // 若i小于0（比第一个还前面）就回到最后一个 i = i \u0026lt; 0 ? data.length - 1 : i // 调用渲染函数 sliderChange(i) }) // 自动播放 let timerId = setInterval(function() { // 自动播放和点击右按钮效果一样，可以利用JS自动调用点击事件 next.click() }, 2000) // 鼠标事件 // 鼠标经过大盒子时停止定时器 slider.addEventListener(\u0026#39;mouseenter\u0026#39;, function() { clearInterval(timerId) }) // 鼠标离开大盒子时开启定时器 slider.addEventListener(\u0026#39;mouseleave\u0026#39;, function() { // 这里也写一次关闭定时器，防止某些情况下出现bug，反正加上没坏处 clearInterval(timerId) // 重新开启定时器 timerId = setInterval(function() { // 自动播放和点击右按钮效果一样，可以利用JS自动调用点击事件 next.click() }, 2000) }) // 点击小圆点跳转至对应轮播图 for (let j = 0; j \u0026lt; data.length; j++) { lis[j].addEventListener(\u0026#39;click\u0026#39;, function() { // 把全局变量i和当前被点击的j匹配上 // 不匹配上就会出现各玩各的bug i = j sliderChange(i) }) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 案例：搜索框 需求：当表单得到焦点，显示下拉菜单，失去焦点隐藏下来菜单\n分析：\n①：开始下拉菜单要进行隐藏\n②：表单获得焦点 focus，则显示下拉菜单，并且文本框变色（添加类）\n③：表单失去焦点，反向操作\n效果图：\n![](/assets/GIF 2024-10-22 23-28-21.gif)\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; box-sizing: border-box; } ul { list-style: none; } .mi { position: relative; width: 223px; margin: 100px auto; } .mi input { width: 223px; height: 48px; padding: 0 10px; font-size: 14px; line-height: 48px; border: 1px solid #e0e0e0; outline: none; } .mi .search { border: 1px solid #ff6700; } .result-list { display: none; position: absolute; left: 0; top: 48px; width: 223px; border: 1px solid #ff6700; border-top: 0; background: #fff; } .result-list a { display: block; padding: 6px 15px; font-size: 12px; color: #424242; text-decoration: none; } .result-list a:hover { background-color: #eee; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;mi\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;search\u0026#34; placeholder=\u0026#34;小米笔记本\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;result-list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;全部商品\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;小米11\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;小米10S\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;小米笔记本\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;小米手机\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;黑鲨4\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;空调\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 获取元素 const input = document.querySelector(\u0026#39;[type=search]\u0026#39;) const ul = document.querySelector(\u0026#39;.result-list\u0026#39;) // 监听事件：获得焦点 input.addEventListener(\u0026#39;focus\u0026#39;, function() { // 显示ul ul.style.display = \u0026#39;block\u0026#39; // 原本是none // 添加一个带有颜色边框的类名 input.classList.add(\u0026#39;search\u0026#39;) }) // 监听事件：失去焦点 input.addEventListener(\u0026#39;blur\u0026#39;, function() { ul.style.display = \u0026#39;none\u0026#39; input.classList.remove(\u0026#39;search\u0026#39;) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 案例：评论字数统计 需求：用户输入文字，可以计算用户输入的字数\n分析：\n①：判断用输入事件 input\n②：不断取得文本框里面的字符长度, 文本域.value.length\n③：把获得数字给下面文本框\n效果图：\n![](/assets/GIF 2024-10-22 23-48-35.gif)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;评论字数统计\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .wrapper { min-width: 400px; max-width: 800px; display: flex; justify-content: flex-end; } .avatar { width: 48px; height: 48px; border-radius: 50%; overflow: hidden; background: url(./images/avatar.jpg) no-repeat center / cover; margin-right: 20px; } .wrapper textarea { outline: none; border-color: transparent; resize: none; background: #f5f5f5; border-radius: 4px; flex: 1; padding: 10px; transition: all 0.5s; height: 30px; } .wrapper textarea:focus { border-color: #e4e4e4; background: #fff; height: 50px; } .wrapper button { background: #00aeec; color: #fff; border: none; border-radius: 4px; margin-left: 10px; width: 70px; cursor: pointer; } .wrapper .total { margin-right: 80px; color: #999; margin-top: 5px; opacity: 0; transition: all 0.5s; } .list { min-width: 400px; max-width: 800px; display: flex; } .list .item { width: 100%; display: flex; } .list .item .info { flex: 1; border-bottom: 1px dashed #e4e4e4; padding-bottom: 10px; } .list .item p { margin: 0; } .list .item .name { color: #FB7299; font-size: 14px; font-weight: bold; } .list .item .text { color: #333; padding: 10px 0; } .list .item .time { color: #999; font-size: 12px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;avatar\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;textarea id=\u0026#34;tx\u0026#34; placeholder=\u0026#34;发一条友善的评论\u0026#34; rows=\u0026#34;2\u0026#34; maxlength=\u0026#34;200\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;button\u0026gt;发布\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;total\u0026#34;\u0026gt;0/200字\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34; style=\u0026#34;display: none;\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;avatar\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;div class=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;name\u0026#34;\u0026gt;清风徐来\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;text\u0026#34;\u0026gt;大家都辛苦啦，感谢各位大大的努力，能圆满完成真是太好了[笑哭][支持]\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;time\u0026#34;\u0026gt;2022-10-10 20:29:21\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const tx = document.querySelector(\u0026#39;#tx\u0026#39;) const total = document.querySelector(\u0026#39;.total\u0026#39;) // 当文本域获得了焦点，就让 total 显示出来 tx.addEventListener(\u0026#39;focus\u0026#39;, function() { total.style.opacity = 1 }) // 当文本域失去了焦点，就让 total 隐藏起来 tx.addEventListener(\u0026#39;blur\u0026#39;, function() { total.style.opacity = 0 }) // 检测用户输入 tx.addEventListener(\u0026#39;input\u0026#39;, function() { total.innerHTML = `${tx.value.length}/200字` }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 事件对象 任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;事件对象\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。\u0026lt;/p\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 获取 .box 元素 const box = document.querySelector(\u0026#39;.box\u0026#39;) // 添加事件监听 box.addEventListener(\u0026#39;click\u0026#39;, function (e) { console.log(\u0026#39;任意事件类型被触发后，相关信息会以对象形式被记录下来...\u0026#39;); // 事件回调函数的第1个参数即所谓的事件对象 console.log(e) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 事件对象效果展示：\n事件回调函数的【第1个参数】即所谓的事件对象，通常习惯性的将这个对数命名为 event、ev 、e 。\n接下来简单看一下事件对象中包含了哪些有用的信息：\ne.type 获取当前事件的类型 e.clientX/e.clientY 获取光标相对浏览器可见窗口左上角的位置 e.offsetX/e.offsetY 获取光标相于当前 DOM 元素左上角的位置 e.key 获取用户按下的键盘键的值 注：在事件回调函数内部通过 window.event 同样可以获取事件对象。\n例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;script\u0026gt; const input = document.querySelector(\u0026#39;input\u0026#39;) input.addEventListener(\u0026#39;keyup\u0026#39;, function(e) { if (e.key == \u0026#39;Enter\u0026#39;) { console.log(\u0026#39;按了回车键才触发\u0026#39;) } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n![](/assets/GIF 2024-10-23 0-07-07.gif)\n补充：trim方法 作用：去除文本最前面与最后面的所有空格\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; const str = \u0026#39; 你 好 \u0026#39; console.log(str) // 你 好 console.log(str.trim()) //你 好 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 案例：回车发布评论 需求：按下回车键盘，可以发布信息\n分析：\n①：用到按下键盘事件 keydown 或者 keyup 都可以\n②：如果用户按下的是回车键盘，则发布信息\n③：让留言信息模块显示，把拿到的数据渲染到对应标签内部\n效果图：\n![](/assets/GIF 2024-10-23 21-10-32.gif)\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;回车发布评论\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .wrapper { min-width: 400px; max-width: 800px; display: flex; justify-content: flex-end; } .avatar { width: 48px; height: 48px; border-radius: 50%; overflow: hidden; background: url(./images/avatar.jpg) no-repeat center / cover; margin-right: 20px; } .wrapper textarea { outline: none; border-color: transparent; resize: none; background: #f5f5f5; border-radius: 4px; flex: 1; padding: 10px; transition: all 0.5s; height: 30px; } .wrapper textarea:focus { border-color: #e4e4e4; background: #fff; height: 50px; } .wrapper button { background: #00aeec; color: #fff; border: none; border-radius: 4px; margin-left: 10px; width: 70px; cursor: pointer; } .wrapper .total { margin-right: 80px; color: #999; margin-top: 5px; opacity: 0; transition: all 0.5s; } .list { min-width: 400px; max-width: 800px; display: flex; } .list .item { width: 100%; display: flex; } .list .item .info { flex: 1; border-bottom: 1px dashed #e4e4e4; padding-bottom: 10px; } .list .item p { margin: 0; } .list .item .name { color: #FB7299; font-size: 14px; font-weight: bold; } .list .item .text { color: #333; padding: 10px 0; } .list .item .time { color: #999; font-size: 12px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;avatar\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;textarea id=\u0026#34;tx\u0026#34; placeholder=\u0026#34;发一条友善的评论\u0026#34; rows=\u0026#34;2\u0026#34; maxlength=\u0026#34;200\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;button\u0026gt;发布\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;total\u0026#34;\u0026gt;0/200字\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34; style=\u0026#34;display: none;\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;avatar\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;div class=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;name\u0026#34;\u0026gt;清风徐来\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;text\u0026#34;\u0026gt;大家都辛苦啦，感谢各位大大的努力，能圆满完成真是太好了[笑哭][支持]\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;time\u0026#34;\u0026gt;2022-10-10 20:29:21\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const tx = document.querySelector(\u0026#39;#tx\u0026#39;) const total = document.querySelector(\u0026#39;.total\u0026#39;) const item = document.querySelector(\u0026#39;.list .item\u0026#39;) const text = document.querySelector(\u0026#39;.info .text\u0026#39;) const time = document.querySelector(\u0026#39;.info .time\u0026#39;) // 当文本域获得了焦点，就让 total 显示出来 tx.addEventListener(\u0026#39;focus\u0026#39;, function() { total.style.opacity = 1 }) // 当文本域失去了焦点，就让 total 隐藏起来 tx.addEventListener(\u0026#39;blur\u0026#39;, function() { total.style.opacity = 0 }) // 检测用户输入 tx.addEventListener(\u0026#39;input\u0026#39;, function() { total.innerHTML = `${tx.value.length}/200字` }) // 按下回车发布评论 tx.addEventListener(\u0026#39;keyup\u0026#39;, function(e) { // 只有按下的是回车键才触发 if (e.key === \u0026#39;Enter\u0026#39;) { // 如果用户除了空格什么也没输入tx.value.trim()返回的就是空 if (tx.value.trim() !== \u0026#39;\u0026#39;) { // 把评论的内容替换为文本域的内容，并且此时文本域的内容以及被清空了首尾的空格 text.innerHTML = tx.value // 显示评论,原本是设为none隐藏起来的 item.style.display = \u0026#39;block\u0026#39; } // 按下回车清空文本域 tx.value = \u0026#39;\u0026#39; // 把字数统计也复原 total.innerHTML = `${tx.value.length}/200字` } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 环境对象 能够分析判断函数运行在不同环境中 this 所指代的对象。\n环境对象指的是函数内部特殊的变量 this ，它代表着当前函数运行时所处的环境。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;script\u0026gt; // 声明函数 function sayHi() { // this 是一个变量 console.log(this); } // 声明一个对象 let user = { name: \u0026#39;张三\u0026#39;, sayHi: sayHi // 此处把 sayHi 函数，赋值给 sayHi 属性 } let person = { name: \u0026#39;李四\u0026#39;, sayHi: sayHi } // 直接调用 sayHi() // window window.sayHi() // window // 做为对象方法调用 user.sayHi()// user person.sayHi()// person \u0026lt;/script\u0026gt; 结论：\nthis 本质上是一个变量，数据类型为对象 函数的调用方式不同 this 变量的值也不同 【谁调用 this 就是谁】是判断 this 值的粗略规则 函数直接调用时实际上 window.sayHi() 所以 this 的值为 window 用法示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; const btn = document.querySelector(\u0026#39;button\u0026#39;) // 点击按钮，按钮自己变红 btn.addEventListener(\u0026#39;click\u0026#39;, function(e) { this.style.color = \u0026#39;red\u0026#39; }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 回调函数 如果将函数 A 做为参数传递给函数 B 时，我们称函数 A 为回调函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;script\u0026gt; // 声明 foo 函数 function foo(arg) { console.log(arg); } // 普通的值做为参数 foo(10); foo(\u0026#39;hello world!\u0026#39;); foo([\u0026#39;html\u0026#39;, \u0026#39;css\u0026#39;, \u0026#39;javascript\u0026#39;]); function bar() { console.log(\u0026#39;函数也能当参数...\u0026#39;); } // 函数也可以做为参数！！！！ foo(bar); \u0026lt;/script\u0026gt; 函数 bar 做参数传给了 foo 函数，bar 就是所谓的回调函数了！！！\n我们回顾一下间歇函数 setInterval\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; function fn() { console.log(\u0026#39;我是回调函数...\u0026#39;); } // 调用定时器 setInterval(fn, 1000); \u0026lt;/script\u0026gt; fn 函数做为参数传给了 setInterval ，这便是回调函数的实际应用了，结合刚刚学习的函数表达式上述代码还有另一种更常见写法。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; // 调用定时器，匿名函数做为参数 setInterval(function () { console.log(\u0026#39;我是回调函数...\u0026#39;); }, 1000); // 监听函数也是回调函数 btn.addEventListener(\u0026#39;click\u0026#39;, function(e) { console.log(\u0026#39;我也是回调函数\u0026#39;) }) \u0026lt;/script\u0026gt; 结论：\n回调函数本质还是函数，只不过把它当成参数使用 使用匿名函数做为回调函数比较常见 综合案例：Tab栏切换 需求：鼠标经过不同的选项卡，底部可以显示 不同的内容\n分析：\n①：主要核心是类的切换， 设定一个当前类，可以让当前元素高亮\n②：鼠标经过当前选项卡，先移除其余元素身上的当前类，而只给当前元素添加类，\n③：注意，当前类只能有一个\n效果图：\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;综合6：tab栏切换\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } .tab { width: 590px; height: 340px; margin: 20px; border: 1px solid #e4e4e4; } .tab-nav { width: 100%; height: 60px; line-height: 60px; display: flex; justify-content: space-between; } .tab-nav h3 { font-size: 24px; font-weight: normal; margin-left: 20px; } .tab-nav ul { list-style: none; display: flex; justify-content: flex-end; } .tab-nav ul li { margin: 0 20px; font-size: 14px; } .tab-nav ul li a { text-decoration: none; border-bottom: 2px solid transparent; color: #333; } .tab-nav ul li a.active { border-color: #e1251b; color: #e1251b; } .tab-content { padding: 0 16px; } .tab-content .item { display: none; } .tab-content .item.active { display: block; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;tab\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;tab-nav\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;每日特价\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a class=\u0026#34;active\u0026#34; href=\u0026#34;javascript:;\u0026#34;\u0026gt;精选\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;美食\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;百货\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;个护\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;预告\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tab-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item active\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;./images/tab00.png\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;./images/tab01.png\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;./images/tab02.png\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;./images/tab03.png\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;./images/tab04.png\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 给五个链接绑定鼠标经过事件 const as = document.querySelectorAll(\u0026#39;.tab-nav ul li a\u0026#39;) for (let i = 0; i \u0026lt; as.length; i++) { // 当鼠标经过时发生变化 as[i].addEventListener(\u0026#39;mouseenter\u0026#39;,function() { // 先移除之前的高亮链接 document.querySelector(\u0026#39;.tab-nav .active\u0026#39;).classList.remove(\u0026#39;active\u0026#39;) // 把鼠标经过的链接设为高亮，此时的this是as[i] this.classList.add(\u0026#39;active\u0026#39;) // 让下方的图片也替换为对应的图片 // 先把之前的图片隐藏 document.querySelector(\u0026#39;.tab-content .active\u0026#39;).classList.remove(\u0026#39;active\u0026#39;) // 把鼠标经过的链接的对应图片显示 document.querySelector(`.tab-content .item:nth-child(${i + 1})`).classList.add(\u0026#39;active\u0026#39;) }) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 综合案例：全选按钮 需求：用户点击全选，则下面复选框全部选择，取消全选则全部取消；当下方复选框全部被勾选时，全选框也自动被勾选，当有至少一个复选框没勾选时，自动取消全选框的勾选状态\n分析：\n①：全选复选框点击，可以得到当前按钮的 checked\n②：把下面所有的小复选框状态checked，改为和全选复选框一致\n③：遍历下面的所有的checkbox,添加点击事件\n④：检查小复选框选中的个数，是不是等于 小复选框总的个数，\n⑤： 把结果给全选按钮\n⑥： 利用css 复选框选择器 input:checked\n效果图：\n![](/assets/GIF 2024-10-27 16-42-14.gif)\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } table { border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; width: 500px; margin: 100px auto; text-align: center; } th { background-color: #09c; font: bold 16px \u0026#34;微软雅黑\u0026#34;; color: #fff; height: 24px; } td { border: 1px solid #d0d0d0; color: #404060; padding: 10px; } .allCheck { width: 80px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th class=\u0026#34;allCheck\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;checkAll\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;all\u0026#34;\u0026gt;全选\u0026lt;/span\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商家\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;价格\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;check\u0026#34; class=\u0026#34;ck\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;小米手机\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;小米\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;￥1999\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;check\u0026#34; class=\u0026#34;ck\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;小米净水器\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;小米\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;￥4999\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;check\u0026#34; class=\u0026#34;ck\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;小米电视\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;小米\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;￥5999\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;script\u0026gt; // 获取全选框（大复选框） const checkAll = document.querySelector(\u0026#39;#checkAll\u0026#39;) // 获取所有小复选框 const cks = document.querySelectorAll(\u0026#39;.ck\u0026#39;) // 点击全选框事件 checkAll.addEventListener(\u0026#39;click\u0026#39;, function() { // 使小复选框的状态与多选框保持一致 for (let i = 0; i \u0026lt; cks.length; i++) { cks[i].checked = this.checked } }) // 小复选框控制全选框 // 给所有的小复选框添加点击事件 for (let i = 0; i \u0026lt; cks.length; i++) { cks[i].addEventListener(\u0026#39;click\u0026#39;, function() { // 判断选中的小复选框个数是否等于小复选框总数 if (document.querySelectorAll(\u0026#39;.ck:checked\u0026#39;).length === cks.length) { checkAll.checked = true } else { checkAll.checked = false } // 上述判断语句可以浓缩为下方代码，但为了便于理解，使用if语句 // checkAll.checked = document.querySelectorAll(\u0026#39;.ck:checked\u0026#39;).length === cks.length }) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Web APIs - 第3天 进一步学习 事件进阶，实现更多交互的网页特效，结合事件流的特征优化事件执行的效率\n掌握阻止事件冒泡的方法 理解事件委托的实现原理 事件流 事件流是对事件执行过程的描述，了解事件的执行过程有助于加深对事件的理解，提升开发实践中对事件运用的灵活度。\n如上图所示，任意事件被触发时总会经历两个阶段：【捕获阶段】和【冒泡阶段】。\n简言之，捕获阶段是【从父到子】的传导过程，冒泡阶段是【从子向父】的传导过程。\n捕获和冒泡 了解了什么是事件流之后，我们来看事件流是如何影响事件执行的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;事件流\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;outer\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 获取嵌套的3个节点 const outer = document.querySelector(\u0026#39;.outer\u0026#39;); const inner = document.querySelector(\u0026#39;.inner\u0026#39;); const child = document.querySelector(\u0026#39;.child\u0026#39;); // html 元素添加事件 document.documentElement.addEventListener(\u0026#39;click\u0026#39;, function () { console.log(\u0026#39;html...\u0026#39;) }) // body 元素添加事件 document.body.addEventListener(\u0026#39;click\u0026#39;, function () { console.log(\u0026#39;body...\u0026#39;) }) // 外层的盒子添加事件 outer.addEventListener(\u0026#39;click\u0026#39;, function () { console.log(\u0026#39;outer...\u0026#39;) }) // 中间的盒子添加事件 outer.addEventListener(\u0026#39;click\u0026#39;, function () { console.log(\u0026#39;inner...\u0026#39;) }) // 内层的盒子添加事件 outer.addEventListener(\u0026#39;click\u0026#39;, function () { console.log(\u0026#39;child...\u0026#39;) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 执行上述代码后发现，当单击事件触发时，其祖先元素的单击事件也【相继触发】，这是为什么呢？\n结合事件流的特征，我们知道当某个元素的事件被触发时，事件总是会先经过其祖先才能到达当前元素，然后再由当前元素向祖先传递，事件在流动的过程中遇到相同的事件便会被触发。\n再来关注一个细节就是事件相继触发的【执行顺序】，事件的执行顺序是可控制的，即可以在捕获阶段被执行，也可以在冒泡阶段被执行。\n如果事件是在冒泡阶段执行的，我们称为冒泡模式，它会先执行子盒子事件再去执行父盒子事件，默认是冒泡模式。\n如果事件是在捕获阶段执行的，我们称为捕获模式，它会先执行父盒子事件再去执行子盒子事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;事件流\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;outer\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 获取嵌套的3个节点 const outer = document.querySelector(\u0026#39;.outer\u0026#39;) const inner = document.querySelector(\u0026#39;.inner\u0026#39;) // 外层的盒子 outer.addEventListener(\u0026#39;click\u0026#39;, function () { console.log(\u0026#39;outer...\u0026#39;) }, true) // true 表示在捕获阶段执行事件 // 中间的盒子 outer.addEventListener(\u0026#39;click\u0026#39;, function () { console.log(\u0026#39;inner...\u0026#39;) }, true) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 结论：\naddEventListener 第3个参数决定了事件是在捕获阶段触发还是在冒泡阶段触发 addEventListener 第3个参数为 true 表示捕获阶段触发，false 表示冒泡阶段触发，默认值为 false 事件流只会在父子元素具有相同事件类型时才会产生影响 绝大部分场景都采用默认的冒泡模式（其中一个原因是早期 IE 不支持捕获） 阻止冒泡 阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;阻止冒泡\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素。\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;outer\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 获取嵌套的3个节点 const outer = document.querySelector(\u0026#39;.outer\u0026#39;) const inner = document.querySelector(\u0026#39;.inner\u0026#39;) const child = document.querySelector(\u0026#39;.child\u0026#39;) // 外层的盒子 outer.addEventListener(\u0026#39;click\u0026#39;, function () { console.log(\u0026#39;outer...\u0026#39;) }) // 中间的盒子 inner.addEventListener(\u0026#39;click\u0026#39;, function (ev) { console.log(\u0026#39;inner...\u0026#39;) // 阻止事件冒泡 ev.stopPropagation() }) // 内层的盒子 child.addEventListener(\u0026#39;click\u0026#39;, function (ev) { console.log(\u0026#39;child...\u0026#39;) // 借助事件对象，阻止事件向上冒泡 ev.stopPropagation() }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 结论：事件对象中的 ev.stopPropagation 方法，专门用来阻止事件冒泡。\n鼠标经过事件：\nmouseover 和 mouseout 会有冒泡效果\nmouseenter 和 mouseleave 没有冒泡效果 (推荐)\n阻止默认行为 在某些情况下，我们需要阻止默认行为的发生，比如在为满足特定条件时，阻止链接的跳转\n语法：e.preventDefault()\n1 2 3 4 5 6 7 8 9 form.addEventListener(\u0026#39;submit\u0026#39;, function(e) { // 阻止表单默认提交行为 e.preventDefault() }) a.addEventListener(\u0026#39;click\u0026#39;, function(e) { // 阻止超链接默认跳转行为 e.preventDefault() }) 解绑事件 解绑后，不会再触发事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 绑定事件1 btn.onclick = function() { alert(\u0026#39;点击了\u0026#39;) } // 解绑事件1 btn.onclick = null // 绑定事件2 function fn() { alert(\u0026#39;点击了\u0026#39;) } btn.addEventListener(\u0026#39;click\u0026#39;, fn)//回调函数，即函数作为参数时无需加() // 解绑事件2 // 注：匿名函数无法被解绑 btn.removeEventListener(\u0026#39;click\u0026#39;, fn) 事件委托 事件委托是利用事件流的特征解决一些现实开发需求的知识技巧，主要的作用是提升程序效率。\n大量的事件监听是比较耗费性能的，如下代码所示\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; // 假设页面中有 10000 个 button 元素 const buttons = document.querySelectorAll(\u0026#39;table button\u0026#39;); for(let i = 0; i \u0026lt;= buttons.length; i++) { // 为 10000 个 button 元素添加了事件 buttons.addEventListener(\u0026#39;click\u0026#39;, function () { // 省略具体执行逻辑... }) } \u0026lt;/script\u0026gt; 利用事件流的特征，可以对上述的代码进行优化，事件的的冒泡模式总是会将事件流向其父元素的，如果父元素监听了相同的事件类型，那么父元素的事件就会被触发并执行，正是利用这一特征对上述代码进行优化，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; // 假设页面中有 10000 个 button 元素 let buttons = document.querySelectorAll(\u0026#39;table button\u0026#39;); // 假设上述的 10000 个 buttom 元素共同的祖先元素是 table let parents = document.querySelector(\u0026#39;table\u0026#39;); parents.addEventListener(\u0026#39;click\u0026#39;, function () { console.log(\u0026#39;点击任意子元素都会触发事件...\u0026#39;); }) \u0026lt;/script\u0026gt; 我们的最终目的是保证只有点击 button 子元素才去执行事件的回调函数，如何判断用户点击是哪一个子元素呢？\n事件对象中的属性 target 或 srcElement属性表示真正触发事件的元素，它是一个元素类型的节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; // 假设页面中有 10000 个 button 元素 const buttons = document.querySelectorAll(\u0026#39;table button\u0026#39;) // 假设上述的 10000 个 buttom 元素共同的祖先元素是 table const parents = document.querySelector(\u0026#39;table\u0026#39;) parents.addEventListener(\u0026#39;click\u0026#39;, function (ev) { // console.log(ev.target); // 只有 button 元素才会真正去执行逻辑 if(ev.target.tagName === \u0026#39;BUTTON\u0026#39;) { // 执行的逻辑 ev.target.style.color = \u0026#39;red\u0026#39; } }) \u0026lt;/script\u0026gt; 优化过的代码只对祖先元素添加事件监听，相比对 10000 个元素添加事件监听执行效率要高许多！！！\n案例练习：tab栏切换优化版 需求：优化程序，将tab切换案例改为事件委托写法\n思路：\n①：给a的父级 注册点击事件，采取事件委托方式\n②： 如果点击的是A , 则进行排他思想，删除添加类\n③： 注意判断的方式 利用 e.target.tagName\n④： 因为没有索引号了，所以这里我们可以自定义属性，给5个链接添加序号\n⑤： 下面大盒子获取索引号的方式 e.target.dataset.id 号， 然后进行排他思想\n效果图：\n![](/assets/GIF 2024-10-27 18-48-31.gif)\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;tab栏切换\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } .tab { width: 590px; height: 340px; margin: 20px; border: 1px solid #e4e4e4; } .tab-nav { width: 100%; height: 60px; line-height: 60px; display: flex; justify-content: space-between; } .tab-nav h3 { font-size: 24px; font-weight: normal; margin-left: 20px; } .tab-nav ul { list-style: none; display: flex; justify-content: flex-end; } .tab-nav ul li { margin: 0 20px; font-size: 14px; } .tab-nav ul li a { text-decoration: none; border-bottom: 2px solid transparent; color: #333; } .tab-nav ul li a.active { border-color: #e1251b; color: #e1251b; } .tab-content { padding: 0 16px; } .tab-content .item { display: none; } .tab-content .item.active { display: block; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;tab\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;tab-nav\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;每日特价\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a class=\u0026#34;active\u0026#34; href=\u0026#34;javascript:;\u0026#34; data-id=\u0026#34;1\u0026#34;\u0026gt;精选\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; data-id=\u0026#34;2\u0026#34;\u0026gt;美食\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; data-id=\u0026#34;3\u0026#34;\u0026gt;百货\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; data-id=\u0026#34;4\u0026#34;\u0026gt;个护\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; data-id=\u0026#34;5\u0026#34;\u0026gt;预告\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tab-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item active\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;./images/tab00.png\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;./images/tab01.png\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;./images/tab02.png\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;./images/tab03.png\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;./images/tab04.png\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 采取事件委托的形式进行切换 // 获取顶部链接的父元素ul const ul = document.querySelector(\u0026#39;.tab-nav ul\u0026#39;) // 为ul添加事件 ul.addEventListener(\u0026#39;click\u0026#39;, function(e) { // 判断点击的是否是想要的 if (e.target.tagName === \u0026#39;A\u0026#39;) { // 修改高亮的链接 document.querySelector(\u0026#39;.tab-nav .active\u0026#39;).classList.remove(\u0026#39;active\u0026#39;) e.target.classList.add(\u0026#39;active\u0026#39;) // 修改下方的图片 document.querySelector(\u0026#39;.tab-content .active\u0026#39;).classList.remove(\u0026#39;active\u0026#39;) const i = e.target.dataset.id document.querySelector(`.tab-content .item:nth-child(${i})`).classList.add(\u0026#39;active\u0026#39;) } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 其他事件 页面加载事件 有些时候需要等页面资源全部处理完了做一些事情\n为什么要学？ ​\t有些时候需要等页面资源全部处理完了做一些事情\n​\t老代码喜欢把 script 写在 head 中，这时候直接找 dom 元素找不到\n第一种：事件名：load 加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件\n监听页面所有资源加载完毕：给 window 添加 load 事件\n1 2 3 window.addEventListener(\u0026#39;load\u0026#39;, function() { // xxxxx }) 注意：不光可以监听整个页面资源加载完毕，也可以针对某个资源绑定load事件\n第二种：事件名：DOMContentLoaded 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像等完全加载\n监听页面DOM加载完毕：给 document 添加 DOMContentLoaded 事件\n1 2 3 document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function() { // 执行的操作 }) 元素滚动事件 滚动条在滚动的时候持续触发的事件\n1 2 3 window.addEventListener(\u0026#39;scroll\u0026#39;, function() { // xxxxx }) 获取位置：\nscrollLeft和scrollTop（属性） ​\t获取被卷去的大小\n​\t获取元素内容往左、往上滚出去看不到的距离\n​\t这两个值是可读写的\n尽量在scroll事件里面获取被卷去的距离 1 2 3 div.addEventListener(\u0026#39;scroll\u0026#39;, function() { console.log(this.scrollTop) }) 开发中，我们经常检测页面滚动的距离，比如页面滚动100像素，就可以显示一个元素，或者固定一个元素\n1 2 3 4 5 window.addEventListener(\u0026#39;scroll\u0026#39;, function() { // 获取html的写法:document.documentElement const n = document.documentElement.scrollTop // 得到的是不带单位的数字 console.log(n) }) 滚动到指定的坐标 scrollTo() 方法可把内容滚动到指定的坐标\n语法：元素.scrollTo(x, y)\n1 2 // 让页面滚动到y轴1000像素的位置 window.scrollTo(0, 1000) 案例：页面滚动显示隐藏侧边栏 需求：当页面滚动大于300像素的距离时候，就显示侧边栏，否则隐藏侧边栏\n分析：\n①：需要用到页面滚动事件\n②：检测页面被卷去的头部，如果大于300，就让侧边栏显示\n③：显示和隐藏配合css过渡，利用opacity加渐变效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 获取元素 const elevator = document.querySelector(\u0026#39;.xtx-elevator\u0026#39;) const backTop = document.querySelector(\u0026#39;#backTop\u0026#39;) // 当页面滚动大于300像素，就显示电梯导航 // 给页面添加滚动事件 window.addEventListener(\u0026#39;scroll\u0026#39;, function() { // 被卷去的头部大于300时显示导航，否则隐藏 const n = document.documentElement.scrollTop elevator.style.opacity = n \u0026gt;= 300 ? 1 : 0 }) // 导航的点击返回页面顶部按钮 backTop.addEventListener(\u0026#39;click\u0026#39;, function() { document.documentElement.scrollTop = 0 }) 页面尺寸事件 会在窗口尺寸改变的时候触发事件：\n1 2 3 window.addEventListener(\u0026#39;resize\u0026#39;, function() { // xxxxx }) 获取元素宽高 获取宽高：\n​\t获取元素的可见部分宽高（不包含边框，margin，滚动条等，包含padding）\n​\tclientWidth和clientHeight\n1 2 3 4 window.addEventListener(\u0026#39;resize\u0026#39;, function() { let w = document.documentElement.clientWidth console.log(w) // 以数字形式输出当前的窗口宽度，隐藏单位是像素 }) 元素尺寸与位置 使用场景： ​\t前面案例滚动多少距离，都是我们自己算的，最好是页面滚动到某个元素，就可以做某些事。\n​\t简单说，就是通过js的方式，得到元素在页面中的位置\n​\t这样我们可以做，页面滚动到这个位置，就可以做某些操作，省去计算了\n获取宽高： ​\t获取元素的自身宽高、包含元素自身设置的宽高、padding、border\n​\t通过：offsetWidth和offsetHeight\n​\t获取出来的是数值,方便计算\n​\t注意：获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0\n获取位置： 法1：\n​\t获取元素距离自己定位父级元素的左、上距离，即受祖先元素影响（类似绝对定位）\n​\toffsetLeft和offsetTop 注意是只读属性\n例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 200px; height: 200px; background-color: pink; margin: 100px; position: relative; } p { width: 100px; height: 100px; background-color: wheat; margin: 50px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const div = document.querySelector(\u0026#39;div\u0026#39;) const p = document.querySelector(\u0026#39;p\u0026#39;) console.log(p.offsetLeft) //父亲开启定位前:158,开启定位后50 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 法2：\n​\telement.getBoundingClientRect()方法返回元素的大小及其相对于视口的位置\n例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 200px; height: 200px; background-color: pink; margin: 100px; position: relative; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const div = document.querySelector(\u0026#39;div\u0026#39;) console.log(div.getBoundingClientRect()) // 返回值见图 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果图：\n总结：\n案例练习：仿京东固定导航栏 需求：当页面滚动到秒杀模块，导航栏自动滑入，否则滑出\n分析：\n①：用到页面滚动事件\n②：检测页面滚动大于等于 秒杀模块的位置 则滑入，否则滑出\n③：主要移动的是秒杀模块的顶部位置\n效果图：\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; box-sizing: border-box; } .content { overflow: hidden; width: 1000px; height: 3000px; background-color: pink; margin: 0 auto; } .backtop { display: none; width: 50px; left: 50%; margin: 0 0 0 505px; position: fixed; bottom: 60px; z-index: 100; } .backtop a { height: 50px; width: 50px; background: url(./images/bg2.png) 0 -600px no-repeat; opacity: 0.35; overflow: hidden; display: block; text-indent: -999em; cursor: pointer; } .header { position: fixed; top: -80px; left: 0; width: 100%; height: 80px; background-color: purple; text-align: center; color: #fff; line-height: 80px; font-size: 30px; transition: all .3s; } .sk { width: 300px; height: 300px; background-color: skyblue; margin-top: 500px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt;我是顶部导航栏\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;sk\u0026#34;\u0026gt;秒杀模块\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;backtop\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./images/close2.png\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const sk = document.querySelector(\u0026#39;.sk\u0026#39;) const header = document.querySelector(\u0026#39;.header\u0026#39;) // 页面滚动事件 window.addEventListener(\u0026#39;scroll\u0026#39;, function() { // 当页面滚动到秒杀模块的时候，就改变顶部导航栏的top值 // 页面被卷去的头部 \u0026gt;= 秒杀模块的位置(offsetTop)时，显示导航栏 const n = document.documentElement.scrollTop if (n \u0026gt;= sk.offsetTop) { header.style.top = 0 } else { header.style.top = \u0026#39;-80px\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 案例练习：b站个人主页导航栏 需求：导航条会随着鼠标位置移动，鼠标离开后，导航条会自动回到当前访问栏下面\n效果图：\n![](/assets/GIF 2024-10-31 20-57-43.gif)\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;导航栏\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { margin: 0; padding: 0; } .clearfix::after { content: \u0026#39;\u0026#39;; display: block; clear: both; } .navigation { width: 100%; height: 90px; background-color: pink; position: relative; } a { float: left; color: rgb(255, 246, 246); text-decoration: none; margin-right: 40px; font-size: 20px; line-height: 90px; } .wrapper { width: 90%; margin: auto; text-align: center; } .cursor { position: absolute; bottom: 10px; height: 3px; background-color: #00a1d6; transition: all .2s ease; width: 0px; left: 0px; } .active { color: rgb(122, 190, 203); } a:hover { color: rgb(122, 190, 203); } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;navigation\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;wrapper clearfix\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34; class=\u0026#34;active\u0026#34;\u0026gt;主页\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;动态\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;投稿\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;合集和列表\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;收藏\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;追番追剧\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;设置\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;cursor\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const cursor = document.querySelector(\u0026#39;.cursor\u0026#39;) const wrapper = document.querySelector(\u0026#39;.wrapper\u0026#39;) // 设置导航条的默认位置 cursor.style.left = `${document.querySelector(\u0026#39;.active\u0026#39;).offsetLeft}px` // 设置导航条的默认宽度 cursor.style.width = `${document.querySelector(\u0026#39;.active\u0026#39;).offsetWidth}px` // 当鼠标进入wrapper时触发事件 wrapper.addEventListener(\u0026#39;mouseover\u0026#39;, function(e) { // 当目标是a标签时执行 if (e.target.tagName === \u0026#39;A\u0026#39;) { // 当前导航条距离左边的距离 const nowLeft = parseInt(cursor.style.left) // 需要移动的距离 const changeX = e.target.offsetLeft - nowLeft // 下面的导航条移动到对应位置 cursor.style.transform = `translateX(${changeX}px)` // 宽度也变成元素的宽度 cursor.style.width = `${e.target.offsetWidth}px` } }) // 当鼠标离开wrapper时触发事件 wrapper.addEventListener(\u0026#39;mouseleave\u0026#39;, function() { // 当前导航条距离左边的距离 const nowLeft = parseInt(cursor.style.left) // 需要移动的距离 const changeX = document.querySelector(\u0026#39;.active\u0026#39;).offsetLeft - nowLeft // 导航条回到active类所在元素的位置 cursor.style.transform = `translateX(${changeX}px)` // 导航条长度也变成active类所在元素的宽度 cursor.style.width = `${document.querySelector(\u0026#39;.active\u0026#39;).offsetWidth}px` }) // 当鼠标点击wrapper时触发事件 wrapper.addEventListener(\u0026#39;click\u0026#39;, function(e) { // 当目标是a标签时执行 if (e.target.tagName === \u0026#39;A\u0026#39;) { // 先删除原本的active类 document.querySelector(\u0026#39;.active\u0026#39;).classList.remove(\u0026#39;active\u0026#39;) // 为点击的元素添加active类 e.target.classList.add(\u0026#39;active\u0026#39;) // 当前导航条距离左边的距离 const nowLeft = parseInt(cursor.style.left) // 需要移动的距离 const changeX = e.target.offsetLeft - nowLeft // 下面的导航条移动到对应位置 cursor.style.transform = `translateX(${changeX}px)` // 宽度也变成元素的宽度 cursor.style.width = `${e.target.offsetWidth}px` } // 阻止页面跳转 e.preventDefault() }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 综合案例：电梯导航完整版 需求：点击不同的模块，页面可以自动跳转不同的位置\n模块分析1： ①：显示隐藏电梯盒子和返回顶部已经完成，可以放到自执行函数里面，防止变量污染\n②：电梯模块单独放到自执行函数里面\n③：点击每个模块，页面自动滚动到对应模块，使用事件委托方法更加简单\n④：页面滚动到对应位置，电梯导航对应模块自动发生变化\n模块分析2：点击每个模块，页面自动滚动到对应模块，使用事件委托方法更加简单 ①：点击小模块，当前添加 active这个类\n②：解决处理初次获取不到active 报错的问题\n解决方案：\n①： 不能直接获取这个类，然后移除，这样会报错\n②： 先获取这个类，然后加个判断\n- 如果有这个类，就移除\n- 如果么有这个类，返回为 null， 就不执行移除，就不报错了\n点击小盒子li，页面跳转到对应大盒子位置\n核心思想： 把对应大盒子的offfsetTop 给document.documentElement.scrollTop\n①： 我们发现小盒子li 的自定义属性里面值 跟 大盒子 后面一致\n②： 利用模板字符串 把点击的 自定义属性值 给 大盒子，就找到对应的大盒子了，\n③：然后拿到这个大盒子的 offsetTop 值 给 document.documentElement.scrollTop 即可\n模块分析3：页面滚动到大盒子位置，电梯导航小盒子对应模块自动处于选中状态 ①： 当页面滚动了，先移除所有小li 里面a 的状态 active 防止有多个 active\n②： 因为页面滚动需要不断获取大盒子的位置，所以需要把所有的大盒子都获取过来\n③： 开始进行滚动判断\n- 如果页面滚动大于 新鲜好物大盒子的offsetTop 并且小于 人气推荐盒子的\noffsetTop 就把 对应的小盒子先出来添加类\n- 依次类推\n- 最后一个，如果大于等于最新专题模块， 就选出最后一个对应小盒子（更精确）\n效果图：点下方代码链接自己体会\n点击导航跳转后，发现高亮的是上一个导航模块的bug产生原因：系统缩放不是100%\n代码：\nWeb APIs - 第4天 进一步学习 DOM 相关知识，实现可交互的网页特效\n能够插入、删除和替换元素节点 能够依据元素节点关系查找节点 日期对象 掌握 Date 日期对象的使用，动态获取当前计算机的时间。\nECMAScript 中内置了获取系统时间的对象 Date，使用 Date 时与之前学习的内置对象 console 和 Math 不同，它需要借助 new 关键字才能使用。\n实例化 1 2 3 4 5 // 1. 实例化 // const date = new Date(); // 系统默认当前时间 const date = new Date(\u0026#39;2020-05-01\u0026#39;) // 指定时间 // date 变量即所谓的时间对象 console.log(typeof date) 方法 1 2 3 4 5 6 // 1. 实例化 const date = new Date(); // 2. 调用时间对象方法 // 通过方法分别获取年、月、日，时、分、秒 const year = date.getFullYear(); // 四位年份 const month = date.getMonth(); // 0 ~ 11 getFullYear() 获取四位年份\ngetMonth() 获取月份，取值为 0 ~ 11，所以要+1才是实际月份\ngetDate() 获取月份中的每一天，不同月份取值也不相同\ngetDay() 获取星期，取值为 0 ~ 6，所以要+1才是实际星期几\ngetHours() 获取小时，取值为 0 ~ 23\ngetMinutes() 获取分钟，取值为 0 ~ 59\ngetSeconds() 获取秒，取值为 0 ~ 59\n小练习：页面显示时间 需求：将当前时间以：YYYY-MM-DD HH:mm 形式显示在页面如 2008-08-08 08:08，并且实时刷新\n案例\n分析：\n①：调用日期对象方法进行转换\n②：记得数字要补0\n③：字符串拼接后，通过 innerText 给 标签\n④：开启定时器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;页面显示时间\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 300px; height: 40px; border: 1px solid pink; text-align: center; line-height: 40px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; function getMyDate() { const date = new Date() const year = date.getFullYear() let month = date.getMonth() + 1 let day = date.getDate() let hour = date.getHours() let min = date.getMinutes() let sec = date.getSeconds() month = month \u0026gt;= 10 ? month : \u0026#39;0\u0026#39; + month day = day \u0026gt;= 10 ? day : \u0026#39;0\u0026#39; + day hour = hour \u0026gt;= 10 ? hour : \u0026#39;0\u0026#39; + hour min = min \u0026gt;= 10 ? min : \u0026#39;0\u0026#39; + min sec = sec \u0026gt;= 10 ? sec : \u0026#39;0\u0026#39; + sec return `当前时间：${year}-${month}-${day} ${hour}:${min}:${sec}` } // 获取div元素 const div = document.querySelector(\u0026#39;div\u0026#39;) // 定时器1s后才运行，会导致1s的空白，所以在外面也写一个，使网页一打开就有时间 div.innerHTML = getMyDate() // 开启定时器，时间实时更新 setInterval(function() { div.innerHTML = getMyDate() }, 1000) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果图：\n补充：\n当对当前时间的显示格式要求不高，只是想知道当前时间时，可以直接调用Date()自带的方法\n1 2 3 4 5 const date = new Date() const div = document.querySelector(\u0026#39;div\u0026#39;) div.innerHTML = date.toLocaleString() // 2024/10/30 17:52:38 div.innerHTML = date.toLocaleDateString() // 2024/10/30 div.innerHTML = date.toLocaleTimeString() // 17:52:38 时间戳 l 使用场景： 如果计算倒计时效果，前面方法无法直接计算，需要借助于时间戳完成\n时间戳是指1970年01月01日00时00分00秒起至现在的总秒数或毫秒数，它是一种特殊的计量时间的方式。\n注：ECMAScript 中时间戳是以毫秒计的。\nl 算法：\nØ 将来的时间戳 - 现在的时间戳 = 剩余时间毫秒数\nØ 剩余时间毫秒数 转换为 剩余时间的 年月日时分秒 就是 倒计时时间\nØ 比如 将来时间戳 2000ms - 现在时间戳 1000ms = 1000ms\nØ 1000ms 转换为就是 0小时0分1秒\n1 2 3 4 5 6 7 8 // 1. 实例化 const date = new Date() // 2. 获取时间戳 console.log(date.getTime())// 1730282471873，这是注释这行代码的时间，仅用于展示时间戳的打印效果 // 还有一种获取时间戳的方法 console.log(+new Date())\t// 1730282471873，这是注释这行代码的时间，仅用于展示时间戳的打印效果 // 还有一种获取时间戳的方法 console.log(Date.now())\t//1730282471873，这是注释这行代码的时间，仅用于展示时间戳的打印效果 获取时间戳的方法，分别为 getTime() 和 Date.now() 和 +new Date()\n+new Date()可以在括号内添加想要的日期，来获取对应的时间戳\n1 console.log(+new Date(\u0026#39;2024-10-30\u0026#39;))// 1730246400000 小练习：倒计时 需求：计算到指定时间还有多久\n分析：\n①：用将来时间减去现在时间就是剩余的时间\n②：核心： 使用将来的时间戳减去现在的时间戳\n③：把剩余的时间转换为 天 时 分 秒\n注意：\n通过时间戳得到是毫秒，需要转换为秒在计算 转换公式： Ø d = parseInt(总秒数/ 60/60 /24); // 计算天数\nØ h = parseInt(总秒数/ 60/60 %24) // 计算小时\nØ m = parseInt(总秒数 /60 %60 ); // 计算分数\nØ s = parseInt(总秒数%60); // 计算当前秒数\n效果图：\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .countdown { width: 240px; height: 305px; text-align: center; line-height: 1; color: #fff; background-color: brown; /* background-size: 240px; */ /* float: left; */ overflow: hidden; } .countdown .next { font-size: 16px; margin: 25px 0 14px; } .countdown .title { font-size: 33px; } .countdown .tips { margin-top: 80px; font-size: 23px; } .countdown small { font-size: 17px; } .countdown .clock { width: 160px; margin: 18px auto 0; overflow: hidden; } .countdown .clock span, .countdown .clock i { display: block; text-align: center; line-height: 34px; font-size: 23px; float: left; } .countdown .clock span { /* width: 34px; */ height: 34px; border-radius: 2px; background-color: #303430; padding: 0 3px; } .countdown .clock i { width: 20px; font-style: normal; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;countdown\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;next\u0026#34;\u0026gt;今天是2024年10月30日\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;双十一倒计时\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;clock\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;hour\u0026#34;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;i\u0026gt;:\u0026lt;/i\u0026gt; \u0026lt;span id=\u0026#34;minute\u0026#34;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;i\u0026gt;:\u0026lt;/i\u0026gt; \u0026lt;span id=\u0026#34;second\u0026#34;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;tips\u0026#34;\u0026gt;11月11号双十一\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 函数封装，获取现在的时间 function getMyDate() { const date = new Date() const year = date.getFullYear() let month = date.getMonth() + 1 let day = date.getDate() day = day \u0026gt;= 10 ? day : \u0026#39;0\u0026#39; + day return `今天是${year}年${month}月${day}日` } // 传入当前时间 const next = document.querySelector(\u0026#39;.countdown .next\u0026#39;) next.innerHTML = getMyDate() // 函数封装，获取剩余时间 function getRemainTime() { // 得到当前的时间戳 const now = +new Date() // 得到将来的时间戳 const last = +new Date(\u0026#39;2024-11-11 00:00:00\u0026#39;) // 得到剩余的时间戳，并转换为秒数 const remain = (last - now) / 1000 // 转换时间 let h = parseInt(remain / 60 / 60) // 计算小时 let m = parseInt(remain / 60 % 60); // 计算分数 let s = parseInt(remain % 60); // 计算当前秒数 // 补0 h = h \u0026gt;= 10 ? h : \u0026#39;0\u0026#39; + h m = m \u0026gt;= 10 ? m : \u0026#39;0\u0026#39; + m s = s \u0026gt;= 10 ? s : \u0026#39;0\u0026#39; + s // 把时间传入对应的盒子 const hour = document.querySelector(\u0026#39;#hour\u0026#39;) const minute = document.querySelector(\u0026#39;#minute\u0026#39;) const second = document.querySelector(\u0026#39;#second\u0026#39;) hour.innerHTML = h minute.innerHTML = m second.innerHTML = s } // 主动执行一次函数，避免定时器开启第一秒时间的空白 getRemainTime() // 开启定时器 setInterval(getRemainTime, 1000) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; DOM 节点 掌握元素节点创建、复制、插入、删除等操作的方法，能够依据元素节点的结构关系查找节点\n回顾之前 DOM 的操作都是针对元素节点的属性或文本的，除此之外也有专门针对元素节点本身的操作，如插入、复制、删除、替换等。\n插入节点 在已有的 DOM 节点中插入新的 DOM 节点时，需要关注两个关键因素：首先要得到新的 DOM 节点，其次在哪个位置插入这个节点。\n如下代码演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;插入节点\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;在现有 dom 结构基础上插入新的元素节点\u0026lt;/p\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;!-- 普通盒子 --\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 点击按钮向 box 盒子插入节点 --\u0026gt; \u0026lt;button class=\u0026#34;btn\u0026#34;\u0026gt;插入节点\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; // 点击按钮，在网页中插入节点 const btn = document.querySelector(\u0026#39;.btn\u0026#39;) btn.addEventListener(\u0026#39;click\u0026#39;, function () { // 1. 获得一个 DOM 元素节点 const p = document.createElement(\u0026#39;p\u0026#39;) p.innerText = \u0026#39;创建的新的p标签\u0026#39; p.className = \u0026#39;info\u0026#39; // 复制原有的 DOM 节点 const p2 = document.querySelector(\u0026#39;p\u0026#39;).cloneNode(true) p2.style.color = \u0026#39;red\u0026#39; // 2. 插入盒子 box 盒子 document.querySelector(\u0026#39;.box\u0026#39;).appendChild(p) document.querySelector(\u0026#39;.box\u0026#39;).appendChild(p2) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 结论：\ncreateElement() 动态创建任意 DOM 节点\ncloneNode() 复制现有的 DOM 节点，传入参数 true 会复制所有子节点，传入false只会复制元素节点\nappendChild() 在末尾（结束标签前）插入节点\n再来看另一种情形的代码演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;插入节点\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;在现有 dom 结构基础上插入新的元素节点\u0026lt;/p\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;button class=\u0026#34;btn1\u0026#34;\u0026gt;在任意节点前插入\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;HTML\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;JavaScript\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; // 点击按钮，在已有 DOM 中插入新节点 const btn1 = document.querySelector(\u0026#39;.btn1\u0026#39;) btn1.addEventListener(\u0026#39;click\u0026#39;, function () { // 第 2 个 li 元素 const relative = document.querySelector(\u0026#39;li:nth-child(2)\u0026#39;) // 1. 动态创建新的节点 const li1 = document.createElement(\u0026#39;li\u0026#39;) li1.style.color = \u0026#39;red\u0026#39; li1.innerText = \u0026#39;Web APIs\u0026#39; // 复制现有的节点 const li2 = document.querySelector(\u0026#39;li:first-child\u0026#39;).cloneNode(true) li2.style.color = \u0026#39;blue\u0026#39; // 2. 在 relative 节点前插入 document.querySelector(\u0026#39;ul\u0026#39;).insertBefore(li1, relative) document.querySelector(\u0026#39;ul\u0026#39;).insertBefore(li2, relative) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 结论：\ncreateElement() 动态创建任意 DOM 节点\ncloneNode() 复制现有的 DOM 节点，传入参数 true 会复制所有子节点，传入false只会复制元素节点\ninsertBefore(要插入的元素,在哪个元素前面) 在父节点中任意子节点之前插入新节点\n小练习：网页在线渲染 需求：按照数据渲染页面\n分析：\n①：准备好空的ul 结构\n②：根据数据的个数，创建一个新的空li\n③：li里面添加内容 img 标题等\n④：追加给ul\n重点练习：创建节点和追加节点\n请在下方基础上渲染出如图所示效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;学车在线首页\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } .w { width: 1200px; margin: auto; } body { background-color: #f3f5f7; } li { list-style: none; } a { text-decoration: none; } .clearfix:before,.clearfix:after { content:\u0026#34;\u0026#34;; display:table; } .clearfix:after { clear:both; } .clearfix { zoom:1; } .box { margin-top: 30px; } .box-hd { height: 45px; } .box-hd h3 { float: left; font-size: 20px; color: #494949; } .box-hd a { float: right; font-size: 12px; color: #a5a5a5; margin-top: 10px; margin-right: 30px; } /* 把li 的父亲ul 修改的足够宽一行能装开5个盒子就不会换行了 */ .box-bd ul { width: 1225px; } .box-bd ul li { position: relative; top: 0; float: left; width: 228px; height: 270px; background-color: #fff; margin-right: 15px; margin-bottom: 15px; transition: all .3s; } .box-bd ul li a { display: block; } .box-bd ul li:hover { top: -8px; box-shadow: 0 15px 30px rgb(0 0 0 / 10%); } .box-bd ul li img { width: 100%; } .box-bd ul li h4 { margin: 20px 20px 20px 25px; font-size: 14px; color: #050505; font-weight: 400; } .box-bd .info { margin: 0 20px 0 25px; font-size: 12px; color: #999; } .box-bd .info span { color: #ff7c2d; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 4. box核心内容区域开始 --\u0026gt; \u0026lt;div class=\u0026#34;box w\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box-hd\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;精品推荐\u0026lt;/h3\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;查看全部\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box-bd\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;clearfix\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 重构 // 已知数据 let data = [ { src: \u0026#39;images/course01.png\u0026#39;, title: \u0026#39;Think PHP 5.0 博客系统实战项目演练\u0026#39;, num: 1125 }, { src: \u0026#39;images/course02.png\u0026#39;, title: \u0026#39;Android 网络动态图片加载实战\u0026#39;, num: 357 }, { src: \u0026#39;images/course03.png\u0026#39;, title: \u0026#39;Angular2 大前端商城实战项目演练\u0026#39;, num: 22250 }, { src: \u0026#39;images/course04.png\u0026#39;, title: \u0026#39;Android APP 实战项目演练\u0026#39;, num: 389 }, { src: \u0026#39;images/course05.png\u0026#39;, title: \u0026#39;UGUI 源码深度分析案例\u0026#39;, num: 124 }, { src: \u0026#39;images/course06.png\u0026#39;, title: \u0026#39;Kami2首页界面切换效果实战演练\u0026#39;, num: 432 }, { src: \u0026#39;images/course07.png\u0026#39;, title: \u0026#39;UNITY 从入门到精通实战案例\u0026#39;, num: 888 }, { src: \u0026#39;images/course08.png\u0026#39;, title: \u0026#39;Cocos 深度学习你不会错过的实战\u0026#39;, num: 590 }, ] // 在此进行代码补充 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果图：\n删除节点 l 若一个节点在页面中已不需要时，可以删除它\nl 在 JavaScript 原生DOM操作中，要删除元素必须通过父元素删除\nl 语法\n父元素.removeChild(要删除的元素)\n删除现有的 DOM 节点，也需要关注两个因素：首先由父节点删除子节点，其次是要删除哪个子节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;body\u0026gt; \u0026lt;!-- 点击按钮删除节点 --\u0026gt; \u0026lt;button\u0026gt;删除节点\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;HTML\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Web APIs\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; const btn = document.querySelector(\u0026#39;button\u0026#39;) btn.addEventListener(\u0026#39;click\u0026#39;, function () { // 获取 ul 父节点 let ul = document.querySelector(\u0026#39;ul\u0026#39;) // 待删除的子节点 let lis = document.querySelectorAll(\u0026#39;li\u0026#39;) // 删除节点 ul.removeChild(lis[0]) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 结论：removeChild() 删除节点时一定是由父子关系。\nl 注：\nØ 如不存在父子关系则删除不成功\nØ 删除节点和隐藏节点（display:none） 有区别的： 隐藏节点还是存在的，但是删除，则从html中删除节点\n查找节点 DOM 树中的任意节点都不是孤立存在的，它们要么是父子关系，要么是兄弟关系，不仅如此，我们可以依据节点之间的关系查找节点。\n父子关系 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;body\u0026gt; \u0026lt;button class=\u0026#34;btn1\u0026#34;\u0026gt;所有的子节点\u0026lt;/button\u0026gt; \u0026lt;!-- 获取 ul 的子节点 --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;HTML\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;JavaScript 基础\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Web APIs\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; const btn1 = document.querySelector(\u0026#39;.btn1\u0026#39;) btn1.addEventListener(\u0026#39;click\u0026#39;, function () { // 父节点 const ul = document.querySelector(\u0026#39;ul\u0026#39;) // 所有的子节点 console.log(ul.childNodes) // 只包含元素子节点 console.log(ul.children) // 得到伪数组 }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 结论：\nchildNodes 获取全部的子节点，回车换行会被认为是空白文本节点 children 只获取元素类型节点（常用这个） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td width=\u0026#34;60\u0026#34;\u0026gt;序号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;课程名\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;难度\u0026lt;/td\u0026gt; \u0026lt;td width=\u0026#34;80\u0026#34;\u0026gt;操作\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;span\u0026gt;HTML\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;初级\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;button\u0026gt;变色\u0026lt;/button\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;span\u0026gt;CSS\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;初级\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;button\u0026gt;变色\u0026lt;/button\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;span\u0026gt;Web APIs\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;中级\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;button\u0026gt;变色\u0026lt;/button\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;script\u0026gt; // 获取所有 button 节点，并添加事件监听 const buttons = document.querySelectorAll(\u0026#39;table button\u0026#39;) for(let i = 0; i \u0026lt; buttons.length; i++) { buttons[i].addEventListener(\u0026#39;click\u0026#39;, function () { // console.log(this.parentNode); // 父节点 td // console.log(this.parentNode.parentNode); // 爷爷节点 tr this.parentNode.parentNode.style.color = \u0026#39;red\u0026#39; }) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 结论：parentNode 获取父节点，以相对位置查找节点，实际应用中非常灵活。\n兄弟关系 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;body\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;HTML\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;JavaScript 基础\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Web APIs\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; // 获取所有 li 节点 const lis = document.querySelectorAll(\u0026#39;ul li\u0026#39;) // 对所有的 li 节点添加事件监听 for(let i = 0; i \u0026lt; lis.length; i++) { lis[i].addEventListener(\u0026#39;click\u0026#39;, function () { // 前一个节点 console.log(this.previousSibling) // 下一下节点 console.log(this.nextSibling) }) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 结论：\npreviousSibling 获取前一个节点，以相对位置查找节点，实际应用中非常灵活。\nnextSibling 获取后一个节点，以相对位置查找节点，实际应用中非常灵活。\n上面两个都是获取全部的子节点，回车换行会被认为是空白文本节点\n一般下面的两个更常用，下面两个只获取元素节点\npreviousElementSibling\nnextElementSibling\n移动端事件 目标：了解M端常见的事件\n移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android 和 IOS 都有。\n触屏事件 touch（也称触摸事件），Android 和 IOS 都有。\ntouch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。\n常见的触屏事件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 300px; height: 300px; background-color: pink; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const div = document.querySelector(\u0026#39;div\u0026#39;) // 1. 触摸 div.addEventListener(\u0026#39;touchstart\u0026#39;, function () { console.log(\u0026#39;开始摸我了\u0026#39;) }) // 2. 离开 div.addEventListener(\u0026#39;touchend\u0026#39;, function () { console.log(\u0026#39;离开了\u0026#39;) }) // 3. 移动 div.addEventListener(\u0026#39;touchmove\u0026#39;, function () { console.log(\u0026#39;一直摸，移动\u0026#39;) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; swiper插件的使用 l 插件: 就是别人写好的一些代码,我们只需要复制对应的代码,就可以直接实现对应的效果\nl 学习插件的基本过程\nØ 熟悉官网,了解这个插件可以完成什么需求 https://www.swiper.com.cn/\nØ 看在线演示,找到符合自己需求的demo https://www.swiper.com.cn/demo/index.html\nØ 查看基本使用流程 https://www.swiper.com.cn/usage/index.html\nØ 查看APi文档,去配置自己的插件 https://www.swiper.com.cn/api/index.html\nØ 注意: 多个swiper同时使用的时候, 类名需要注意区分\n综合案例：学生信息表 业务模块：\n①： 点击录入按钮可以录入数据\n②： 点击删除可以删除当前的数据\n说明：\n本次案例，我们尽量减少dom操作，采取操作数据的形式\n增加和删除都是针对于数组的操作，然后根据数组数据渲染页面\n①： 声明一个空的数组\n②： 点击录入模块\n​\t(1). 首先取消表单默认提交事件\n​\t(2). 创建新的对象，里面存储 表单获取过来的数据，格式如右图\n​\t(3). 追加给数组\n​\t(4). 渲染数据。 遍历数组， 动态生成tr， 里面填写对应td数据， 并追加给 tbody\n​\t(5). 重置表单\n​\t(6). 注意防止多次生成多条数据，先清空 tbody\n③： 点击删除模块\n​\t(1). 采用事件委托形式，给 tbody 注册点击事件\n​\t(2). 点击链接，要删除的是对应数组里面的这个数据，而不是删除dom节点，如何找到这个数据？\n​\t(3). 前面渲染数据的时候，动态给a链接添加 自定义属性 data-id=“0”,这样点击当前对象就知道索引号了\n​\t(4). 根据索引号，利用 splice 删除这条数据\n​\t(5). 重新渲染\n④： 点击新增需要验证表单\n​\t(1). 获取所有需要填写的表单， 他们共同特点都有 name属性\n​\t(2). 遍历这些表单，如果有一个值为空，则return 返回提示输入为空中断程序\n​\t(3). 注意书写的位置，应该放到新增数据的前面， 阻止默认行为的后面\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;学生信息管理\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } a { text-decoration: none; color:#721c24; } h1 { text-align: center; color:#333; margin: 20px 0; } table { margin:0 auto; width: 800px; border-collapse: collapse; color:#004085; } th { padding: 10px; background: #cfe5ff; font-size: 20px; font-weight: 400; } td,th { border:1px solid #b8daff; } td { padding:10px; color:#666; text-align: center; font-size: 16px; } tbody tr { background: #fff; } tbody tr:hover { background: #e1ecf8; } .info { width: 900px; margin: 50px auto; text-align: center; } .info input, .info select { width: 80px; height: 27px; outline: none; border-radius: 5px; border:1px solid #b8daff; padding-left: 5px; box-sizing: border-box; margin-right: 15px; } .info button { width: 60px; height: 27px; background-color: #004085; outline: none; border: 0; color: #fff; cursor: pointer; border-radius: 5px; } .info .age { width: 50px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;新增学员\u0026lt;/h1\u0026gt; \u0026lt;form class=\u0026#34;info\u0026#34; autocomplete=\u0026#34;off\u0026#34;\u0026gt; 姓名：\u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;uname\u0026#34; name=\u0026#34;uname\u0026#34; /\u0026gt; 年龄：\u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;age\u0026#34; name=\u0026#34;age\u0026#34; /\u0026gt; 性别: \u0026lt;select name=\u0026#34;gender\u0026#34; class=\u0026#34;gender\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;男\u0026#34;\u0026gt;男\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;女\u0026#34;\u0026gt;女\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; 薪资：\u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;salary\u0026#34; name=\u0026#34;salary\u0026#34; /\u0026gt; 就业城市：\u0026lt;select name=\u0026#34;city\u0026#34; class=\u0026#34;city\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;北京\u0026#34;\u0026gt;北京\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;上海\u0026#34;\u0026gt;上海\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;广州\u0026#34;\u0026gt;广州\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;深圳\u0026#34;\u0026gt;深圳\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;曹县\u0026#34;\u0026gt;曹县\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;button class=\u0026#34;add\u0026#34;\u0026gt;录入\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;h1\u0026gt;就业榜\u0026lt;/h1\u0026gt; \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;学号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;薪资\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;就业城市\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;操作\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;!-- \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1001\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;欧阳霸天\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;19\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;男\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;15000\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;上海\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026#34;javascript:\u0026#34;\u0026gt;删除\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; --\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;script\u0026gt; // 获取元素 const uname = document.querySelector(\u0026#39;.uname\u0026#39;) const age = document.querySelector(\u0026#39;.age\u0026#39;) const gender = document.querySelector(\u0026#39;.gender\u0026#39;) const salary = document.querySelector(\u0026#39;.salary\u0026#39;) const city = document.querySelector(\u0026#39;.city\u0026#39;) const tbody = document.querySelector(\u0026#39;tbody\u0026#39;) // 获取所有带有name属性的元素 const items = document.querySelectorAll(\u0026#39;[name]\u0026#39;) // 声明一个空数组，后续增加和删除都是对这个数组进行操作 const arr = [] // 录入模块 // 表单提交事件 const info = document.querySelector(\u0026#39;.info\u0026#39;) info.addEventListener(\u0026#39;submit\u0026#39;, function(e) { // 阻止表单跳转 e.preventDefault() // 判断表单是否填写完整，若有数据未填写，则中断函数 // 遍历表单内需要填写的元素，即带有name属性的元素 for (let i = 0; i \u0026lt; items.length; i++) { if (items[i].value.trim() === \u0026#39;\u0026#39;) {// 用trim()来消除空格 return alert(\u0026#39;输入内容不能为空\u0026#39;) } } // 通过获取的元素内容创建对象 const obj = { stuId: arr.length + 1,// 一开始数组是空的，所以长度是0 uname: uname.value, age: age.value, gender: gender.value, salary: salary.value, city: city.value, } // 把对象内的数据存入数组 arr.push(obj) // 清空表单，方便下次填写 this.reset() // 调用自己写的渲染函数，渲染页面 render(arr) }) // 删除操作 // 事件委托tbody tbody.addEventListener(\u0026#39;click\u0026#39;, function(e) { if (e.target.tagName === \u0026#39;A\u0026#39;) { // 得到点击元素的自定义属性，即这条数据在数组中的下标 const id = e.target.dataset.id // 删除数组中对应的数据 arr.splice(id, 1) // 从id的位置(要删除数据在数组中的下标)开始，删除一个 // 调用渲染函数，重新渲染页面 render(arr) } }) // 写一个渲染页面函数，便于使用 function render(arr = []) { // 先清空tbody已有的行，因为渲染时是把数组的所有内容都打印出来，不清空就会有冗余bug tbody.innerHTML = \u0026#39;\u0026#39; // 遍历数组 for (let i = 0; i \u0026lt; arr.length; i++) { // 生成tr const tr = document.createElement(\u0026#39;tr\u0026#39;) // 给a加自定义属性，并把自定义属性的值设得与这条数据在数组中的下标相同 // 是为了后续删除时方便找到具体是哪一条 tr.innerHTML = ` \u0026lt;td\u0026gt;${arr[i].stuId}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${arr[i].uname}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${arr[i].age}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${arr[i].gender}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${arr[i].salary}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${arr[i].city}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026#34;javascript:\u0026#34; data-id=\u0026#34;${i}\u0026#34;\u0026gt;删除\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; ` // 将生成的tr追加到tbody中 tbody.appendChild(tr) } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Web APIs - 第5天笔记 目标： 能够利用JS操作浏览器,具备利用本地存储实现学生就业表的能力\nBOM操作 综合案例 js组成 JavaScript的组成\nECMAScript:\n规定了js基础语法核心知识。 比如：变量、分支语句、循环语句、对象等等 Web APIs :\nDOM 文档对象模型， 定义了一套操作HTML文档的API BOM 浏览器对象模型，定义了一套操作浏览器窗口的API window对象 BOM (Browser Object Model ) 是浏览器对象模型\nwindow对象是一个全局对象，也可以说是JavaScript中的顶级对象 像document、alert()、console.log()这些都是window的属性，基本BOM的属性和方法都是window的 所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法 window对象下的属性和方法调用的时候可以省略window 定时器-延迟函数 JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout\n语法：\n1 setTimeout(回调函数, 延迟时间) setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行, 平时省略window\n间歇函数 setInterval : 每隔一段时间就执行一次， , 平时省略window\n清除延时函数：\n1 clearTimeout(timerId) 注意点\n延时函数需要等待,所以后面的代码先执行 返回值是一个正整数，表示定时器的编号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 定时器之延迟函数 // 1. 开启延迟函数 let timerId = setTimeout(function () { console.log(\u0026#39;我只执行一次\u0026#39;) }, 3000) // 1.1 延迟函数返回的还是一个正整数数字，表示延迟函数的编号 console.log(timerId) // 1.2 延迟函数需要等待时间，所以下面的代码优先执行 // 2. 关闭延迟函数 clearTimeout(timerId) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 小练习：5秒后自动消失的广告 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; img { position: fixed; right: 0; bottom: 0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img src=\u0026#34;./images/ad.png\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;script\u0026gt; const img = document.querySelector(\u0026#39;img\u0026#39;) // 5秒后执行函数 setTimeout(function() { img.style.display = \u0026#39;none\u0026#39; }, 5000) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JS执行机制 JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。\n这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。\n单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：\n如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程。于是，JS 中出现了同步和异步。\n同步\n前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。\n异步\n你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。\n他们的本质区别： 这条流水线上各个流程的执行顺序不同。\n同步任务\n同步任务都在主线程上执行，形成一个执行栈。\n异步任务\nJS 的异步是通过回调函数实现的。\n一般而言，异步任务有以下三种类型:\n1、普通事件，如 click、resize 等\n2、资源加载，如 load、error 等\n3、定时器，包括 setInterval、setTimeout 等\n异步任务相关添加到任务队列中（任务队列也称为消息队列）。\n执行机制\n先执行执行栈中的同步任务。 异步任务放入任务队列中。 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。 由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（event loop）。\nlocation对象 location (地址) 它拆分并保存了 URL 地址的各个组成部分， 它是一个对象\n属性/方法 说明 href 属性，获取完整的 URL 地址，赋值时用于地址的跳转 search 属性，获取地址中携带的参数，符号 ？后面部分 hash 属性，获取地址中的啥希值，符号 # 后面部分 reload() 方法，用来刷新当前页面，传入参数 true 时表示强制刷新 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;body\u0026gt; \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;search\u0026#34;\u0026gt; \u0026lt;button\u0026gt;搜索\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;a href=\u0026#34;#/music\u0026#34;\u0026gt;音乐\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;#/download\u0026#34;\u0026gt;下载\u0026lt;/a\u0026gt; \u0026lt;button class=\u0026#34;reload\u0026#34;\u0026gt;刷新页面\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; // location 对象 // 1. href属性 （重点） 得到完整地址，赋值则是跳转到新地址 console.log(location.href) // location.href = \u0026#39;http://www.itcast.cn\u0026#39; // 2. search属性 得到 ? 后面的地址 console.log(location.search) // ?search=笔记本 // 3. hash属性 得到 # 后面的地址 console.log(location.hash) // 4. reload 方法 刷新页面 const btn = document.querySelector(\u0026#39;.reload\u0026#39;) btn.addEventListener(\u0026#39;click\u0026#39;, function () { // location.reload() // 页面刷新 location.reload(true) // 强制页面刷新 ctrl+f5 }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 小练习：5秒之后跳转的页面 需求：用户点击可以跳转，如果不点击，则5秒之后自动跳转，要求里面有秒数倒计时\n分析：\n①：目标元素是链接\n②：利用定时器设置数字倒计时\n③：时间到了，自动跳转到新的页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; span { color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;a href=\u0026#34;https://www.bilibili.com/\u0026#34;\u0026gt;\u0026lt;span\u0026gt;5\u0026lt;/span\u0026gt;秒后将会跳转\u0026lt;/a\u0026gt; \u0026lt;script\u0026gt; // 获取元素 const a = document.querySelector(\u0026#39;a\u0026#39;) // 声明倒计时变量 let num = 5 // 开启定时器 let timerId = setInterval(function() { num-- a.innerHTML = `\u0026lt;span\u0026gt;${num}\u0026lt;/span\u0026gt;秒后将会跳转` // 当num为0时停止定时器，并进行跳转 if (num === 0) { clearInterval(timerId) location.href = \u0026#39;https://www.bilibili.com/\u0026#39; } }, 1000) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; navigator对象 navigator是对象，该对象下记录了浏览器自身的相关信息\n常用属性和方法：\n通过 userAgent 检测浏览器的版本及平台 1 2 3 4 5 6 7 8 9 10 11 // 检测 userAgent（浏览器信息） (function () { const userAgent = navigator.userAgent // 验证是否为Android或iPhone const android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/) const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/) // 如果是Android或iPhone，则跳转至移动站点 if (android || iphone) { location.href = \u0026#39;http://m.itcast.cn\u0026#39; } })(); 立即执行函数写法补充 之前已知有两种立即执行函数写法\n1 2 3 4 // 方法一 (function(形参) {函数方法})(实参) // 方法二 (function(形参) {函数方法} (实参)) 现补充第三种写法，也可以说是第二种写法简略版\n1 2 3 // 第三种写法，就是第二种写法不写最外面的括号 // 而是在最前面加上!或+、-、~、=等等算数符都行，让编译器识别出这是个立即执行函数 !function(){}() histroy对象 history (历史)是对象，主要管理历史记录， 该对象与浏览器地址栏的操作相对应，如前进、后退等\n使用场景\nhistory对象一般在实际开发中比较少用，但是会在一些OA 办公系统中见到。\n常见方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;body\u0026gt; \u0026lt;button class=\u0026#34;back\u0026#34;\u0026gt;←后退\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;forward\u0026#34;\u0026gt;前进→\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; // histroy对象 // 1.前进 const forward = document.querySelector(\u0026#39;.forward\u0026#39;) forward.addEventListener(\u0026#39;click\u0026#39;, function () { // history.forward() history.go(1) }) // 2.后退 const back = document.querySelector(\u0026#39;.back\u0026#39;) back.addEventListener(\u0026#39;click\u0026#39;, function () { // history.back() history.go(-1) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 本地存储（今日重点） 本地存储：将数据存储在本地浏览器中\n常见的使用场景：\nhttps://todomvc.com/examples/vanilla-es6/ 页面刷新数据不丢失\n好处：\n1、页面刷新或者关闭不丢失数据，实现数据持久化\n2、容量较大，sessionStorage和 localStorage 约 5M 左右\nlocalStorage（重点） 作用: 数据可以长期保留在本地浏览器中，刷新页面和关闭页面，数据也不会丢失\n**特性：**同一浏览器共享，以键值对的形式存储，并且存储的是字符串， 省略了window\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;本地存储-localstorage\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 本地存储 - localstorage 存储的是字符串, key(键)一定要带\u0026#39;\u0026#39;号 // 1. 存储，非字符串类型会自动转换为字符串 localStorage.setItem(\u0026#39;age\u0026#39;, 18) // 2. 获取 console.log(typeof localStorage.getItem(\u0026#39;age\u0026#39;)) // 3. 删除 localStorage.removeItem(\u0026#39;age\u0026#39;) // 4.修改，对已有的键进行存储操作就是修改 localStorage.setItem(\u0026#39;age\u0026#39;, 20) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; sessionStorage（了解） 特性：\n用法跟localStorage基本相同 区别是：当页面浏览器被关闭时，存储在 sessionStorage 的数据会被清除 存储：sessionStorage.setItem(key,value)\n获取：sessionStorage.getItem(key)\n删除：sessionStorage.removeItem(key)\nlocalStorage 存储复杂数据类型 **问题：**本地只能存储字符串,无法存储复杂数据类型.\n**解决：**需要将复杂数据类型转换成 JSON字符串,在存储到本地\n语法：JSON.stringify(复杂数据类型)\nJSON字符串：\n首先是1个字符串 属性名使用双引号引起来，不能单引号 属性值如果是字符串型也必须双引号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 本地存储复杂数据类型 const goods = { name: \u0026#39;小米\u0026#39;, price: 1999 } // localStorage.setItem(\u0026#39;goods\u0026#39;, goods) // console.log(localStorage.getItem(\u0026#39;goods\u0026#39;)) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem(\u0026#39;goods\u0026#39;, JSON.stringify(goods)) // console.log(typeof localStorage.getItem(\u0026#39;goods\u0026#39;)) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; **问题：**因为本地存储里面取出来的是字符串，不是对象，无法直接使用\n**解决： **把取出来的字符串转换为对象\n语法：JSON.parse(JSON字符串)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 本地存储复杂数据类型 const goods = { name: \u0026#39;小米\u0026#39;, price: 1999 } // localStorage.setItem(\u0026#39;goods\u0026#39;, goods) // console.log(localStorage.getItem(\u0026#39;goods\u0026#39;)) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem(\u0026#39;goods\u0026#39;, JSON.stringify(goods)) // console.log(typeof localStorage.getItem(\u0026#39;goods\u0026#39;)) // 2. 把JSON字符串转换为对象 JSON.parse console.log(JSON.parse(localStorage.getItem(\u0026#39;goods\u0026#39;))) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 综合案例 数组map 方法 使用场景：\nmap 可以遍历数组处理数据，并且返回新的数组\n语法：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; const arr = [\u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;pink\u0026#39;] // 1. 数组 map方法 处理数据并且 返回一个数组 const newArr = arr.map(function (ele, index) { // console.log(ele) // 数组元素 // console.log(index) // 索引号 return ele + \u0026#39;颜色\u0026#39; }) console.log(newArr) // [\u0026#39;red颜色\u0026#39;, \u0026#39;blue颜色\u0026#39;, \u0026#39;pink颜色\u0026#39;] \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; map 也称为映射。映射是个术语，指两个元素的集之间元素相互“对应”的关系。\nmap重点在于有返回值，forEach没有返回值（undefined）\n数组join方法 **作用：**join() 方法用于把数组中的所有元素转换一个字符串\n语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; const arr = [\u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;pink\u0026#39;] // 1. 数组 map方法 处理数据并且 返回一个数组 const newArr = arr.map(function (ele, index) { // console.log(ele) // 数组元素 // console.log(index) // 索引号 return ele + \u0026#39;颜色\u0026#39; }) console.log(newArr) // 2. 数组join方法 把数组转换为字符串 // 小括号为空则逗号分割 console.log(newArr.join()) // red颜色,blue颜色,pink颜色 // 小括号是空字符串，则元素之间没有分隔符 console.log(newArr.join(\u0026#39;\u0026#39;)) //red颜色blue颜色pink颜色 console.log(newArr.join(\u0026#39;|\u0026#39;)) //red颜色|blue颜色|pink颜色 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 综合练习：学生就业统计表 需求： 录入学生信息，页面刷新数据不丢失\n模块分析：\n①：新增模块， 输入学生信息，数据会存储到本地存储中\n如果本地存储有数据，则返回 JSON.parse() 之后的对象\n如果本地存储没有数据，则声明一个空的数组\n②：渲染模块，数据会渲染到页面中\n(1) 遍历数组， td里面填写对应td数据， 并追加给 tbody\n(2) 尽量减少dom操作，所以此处我们不在使用创建节点，追加节点方式（后面vue的做法）\n(3) 我们使用map方法遍历数组，直接返回 整个tr， 里面包含所有修改后的 tr 标签， 里面更换数据\n(4) 但是map方法返回的是一个修改后的数组，怎么办？所以我们通过join方法转换为字符串\n(5) 把返回的结果， 通过 innerHTML 赋值给 tbody\n③：录入模块，将页面输入的数据录入数组\n(1) 事件是提交事件，同样阻止默认提交事件\n(2) 非空判断。\n- 获取所有需要填写的表单， 他们共同特点都有 name属性\n- 遍历这些表单，如果有一个值为空，则return 返回提示输入为空中断程序\n(3) 创建新的对象，里面存储表单获取过来的数据\n- 创建一个空的对象\n- 给对象追加一个 stuId\n- 利用刚才非空判断的循环，采取对象追加 属性 = 值的方式，顺便 把表单值 赋值给相应的对象\n(4) 追加给数组\n(5) 放入本地存储里面， 记得一定要把数组 利用 JSON.stringify()存储为字符串\n(6) 渲染页面\n(7) 重置表单\n④：删除模块，点击删除按钮，会删除对应的数据\n(1) 采用事件委托形式，给 tbody 注册点击事件\n(2) 点击链接，要删除的是对应数组里面的这个数据，而不是删除dom节点，如何找到这个数据？\n(3) 前面渲染数据的时候，动态给a链接添加 自定义属性 data-id=“0”,这样点击当前对象就知道索引号了\n(4) 根据索引号，利用 splice 删除这条数据\n(5) 写入本地存储， 记得一定要把数组 利用 JSON.stringify()存储为字符串\n(6) 重新渲染\n需求⑤： 关于stuId 处理的问题\n当有多条数据时，删除前面的数据，再添加新数据时会导致新数据的id与之前的相同的bug\n(1) 最好的做法： 新增加序号应该是最后一条数据的序号 + 1\n即，数组[数组的长度-1].stuId + 1\n(2) 但是要判断， 如果数组中没有数据则是直接赋值为1，否则就采用上面的做法\n效果图：\n![](/assets/GIF 2024-11-2 14-44-41.gif)\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;学生就业统计表\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./iconfont/iconfont.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css/index.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;学生就业统计表\u0026lt;/h1\u0026gt; \u0026lt;form class=\u0026#34;info\u0026#34; autocomplete=\u0026#34;off\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;uname\u0026#34; name=\u0026#34;uname\u0026#34; placeholder=\u0026#34;姓名\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;age\u0026#34; name=\u0026#34;age\u0026#34; placeholder=\u0026#34;年龄\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;salary\u0026#34; name=\u0026#34;salary\u0026#34; placeholder=\u0026#34;薪资\u0026#34; /\u0026gt; \u0026lt;select name=\u0026#34;gender\u0026#34; class=\u0026#34;gender\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;男\u0026#34;\u0026gt;男\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;女\u0026#34;\u0026gt;女\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;select name=\u0026#34;city\u0026#34; class=\u0026#34;city\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;北京\u0026#34;\u0026gt;北京\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;上海\u0026#34;\u0026gt;上海\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;广州\u0026#34;\u0026gt;广州\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;深圳\u0026#34;\u0026gt;深圳\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;曹县\u0026#34;\u0026gt;曹县\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;button class=\u0026#34;add\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;iconfont icon-tianjia\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;添加 \u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;共有数据\u0026lt;span\u0026gt;0\u0026lt;/span\u0026gt;条\u0026lt;/div\u0026gt; \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;ID\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;薪资\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;就业城市\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;录入时间\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;操作\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;!-- \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;迪丽热巴\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;23\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;女\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;12000\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;北京\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2099/9/9 08:08:08\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026#34;javascript:\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;iconfont icon-shanchu\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 删除 \u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; --\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;script\u0026gt; // 封装一个渲染函数，方便多次使用 function render(arr = []) { // 利用map和join方法来渲染页面 // 利用map遍历数组，放回对应tr的数组 // 给删除按钮一个与数组下标相同的自定义属性值，方便删除时定位数据位置 const trArr = arr.map(function(ele, index) { return ` \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;${ele.stuId}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${ele.uname}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${ele.age}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${ele.gender}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${ele.salary}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${ele.city}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${ele.time}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026#34;javascript:\u0026#34; data-id=\u0026#34;${index}\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;iconfont icon-shanchu\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 删除 \u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; ` }) // 再把数组用join转换为字符串 // 把生成的字符串追加给tbody const tbody = document.querySelector(\u0026#39;tbody\u0026#39;) tbody.innerHTML = trArr.join(\u0026#39;\u0026#39;) // 修改页面上的共有几条数据 document.querySelector(\u0026#39;.title span\u0026#39;).innerHTML = arr.length } // 渲染模块 // 读取本地数据并存入数组，读取时把字符串还原成复杂数据类型 // 为了防止本地无数据时导致数组出现bug，利用逻辑中断的原理，当本地数据为空(false)时，将生成空数组 const arr = JSON.parse(localStorage.getItem(\u0026#39;data\u0026#39;)) || [] // 读取完数据，渲染一下页面，这样才能保证刷新后数据不丢失 render(arr) // 录入模块 const info = document.querySelector(\u0026#39;.info\u0026#39;) const uname = document.querySelector(\u0026#39;.uname\u0026#39;) const age = document.querySelector(\u0026#39;.age\u0026#39;) const salary = document.querySelector(\u0026#39;.salary\u0026#39;) const gender = document.querySelector(\u0026#39;.gender\u0026#39;) const city = document.querySelector(\u0026#39;.city\u0026#39;) const time = new Date().toLocaleString()// 获取当前时间 // 设置表单提交事件 info.addEventListener(\u0026#39;submit\u0026#39;, function(e) { // 阻止表单的默认提交行为 e.preventDefault() // 非空判断 if (!uname.value || !age.value || !salary.value) {// 三者有一个为空就会满足条件 return alert(\u0026#39;输入内容不能为空\u0026#39;) } // 给arr数组追加对象，对象里存储着从表单中获取的信息 arr.push({ // 为了防止出现id重复的bug，stuId为数组中最后一条数据的id+1 // 但是要判断， 如果数组中没有数据则是直接赋值为1，否则就采用上面的做法 stuId: arr.length ? arr[arr.length - 1].stuId + 1 : 1, uname: uname.value, age: age.value, salary: salary.value, gender: gender.value, city: city.value, time: time }) // 渲染页面并重置表单 render(arr) this.reset() // 把数组重新存入本地数据，存入是要把对象转换为JSON字符串 localStorage.setItem(\u0026#39;data\u0026#39;, JSON.stringify(arr)) }) // 删除模块 const tbody = document.querySelector(\u0026#39;tbody\u0026#39;) // 采用事件委托形式，给tbody注册点击事件 tbody.addEventListener(\u0026#39;click\u0026#39;, function(e) { // 判断点击的是否是删除按钮（删除按钮被a标签包裹） if (e.target.tagName === \u0026#39;A\u0026#39;) { // 为了防止误操作，点击后弹出确认框 if (confirm(\u0026#39;您确定要删除这条数据吗？\u0026#39;)) { // 得到当前点击链接的索引号，利用渲染数据时给的自定义属性获取 const deleIndex = e.target.dataset.id // 根据得到的索引号进行删除，利用splice方法进行删除 arr.splice(deleIndex, 1) // 把进行删除操作后的新数组重新存入本地数据，对本地数据进行更新 localStorage.setItem(\u0026#39;data\u0026#39;, JSON.stringify(arr)) // 重新渲染页面 render(arr) } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; css部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 * { margin: 0; padding: 0; } a { text-decoration: none; color: #721c24; } h1 { text-align: center; color: #333; margin: 20px 0; } .title { width: 933px; height: 50px; line-height: 50px; padding-right: 15px; border: 1px solid #ebebeb; margin: 10px auto; background-color: #f2f2f2; text-align: right; } .title span { display: inline-block; vertical-align: middle; height: 20px; margin: -3px 5px 0; text-align: center; line-height: 20px; color: #f26934; font-weight: 700; } table { margin: 0 auto; width: 950px; border-collapse: collapse; color: #3c3637; } th { padding: 10px; background: #f2f2f2; font-size: 18px; text-align: left; } td, th { border: 1px solid #ebebeb; padding: 15px; } td { color: #666; font-size: 16px; } tbody tr { background: #fff; } tbody tr:hover { background: #fbfafa; } tbody a { display: inline-block; width: 80px; height: 30px; text-align: center; line-height: 30px; color: #fff; background-color: #f26934; } .info { width: 900px; margin: 50px auto; text-align: center; } .info input, .info select { width: 100px; height: 30px; outline: none; border: 1px solid #ebebeb; padding-left: 5px; box-sizing: border-box; margin-right: 10px; } .info button { width: 70px; height: 30px; background-color: #5dbfd8; outline: none; border: 0; color: #fff; cursor: pointer; font-size: 14px; } .info button:hover { background-color: #52abc1; } Web APIs - 第6天笔记 目标：能够利用正则表达式完成小兔鲜注册页面的表单验证，具备常见的表单验证能力\n正则表达式 综合案例 阶段案例 正则表达式 正则表达式（Regular Expression）是一种字符串匹配的模式（规则）\n使用场景：\n例如验证表单：手机号表单要求用户只能输入11位的数字 (匹配) 过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 正则基本使用 定义规则\n1 const reg = /表达式/ 其中/ /是正则表达式字面量 正则表达式也是对象 使用正则\ntest()方法 用来查看正则表达式与指定的字符串是否匹配 如果正则表达式与指定的字符串匹配 ，返回true，否则false 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 正则表达式的基本使用 const str = \u0026#39;web前端开发\u0026#39; // 1. 定义规则 const reg = /web/ // 2. 使用正则 test() console.log(reg.test(str)) // true 如果符合规则匹配上则返回true console.log(reg.test(\u0026#39;java开发\u0026#39;)) // false 如果不符合规则匹配上则返回 false \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 3.检索（查找）符合规则的字符串：\nexec() 方法 在一个指定字符串中执行一个搜索匹配 元字符 普通字符: 大多数的字符仅能够描述它们本身，这些字符称作普通字符，例如所有的字母和数字。 普通字符只能够匹配字符串中与它们相同的字符。 比如，规定用户只能输入英文26个英文字母，普通字符的话 /[abcdefghijklmnopqrstuvwxyz]/ 元字符(特殊字符） 是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。 比如，规定用户只能输入英文26个英文字母，换成元字符写法： /[a-z]/ 参考文档：\nØ MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\nØ 正则测试工具: http://tool.oschina.net/regex\n边界符 正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符\n如果 ^ 和 $ 在一起，表示必须是精确匹配\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 元字符之边界符 // 1. 匹配开头的位置 ^ const reg = /^web/ console.log(reg.test(\u0026#39;web前端\u0026#39;)) // true console.log(reg.test(\u0026#39;前端web\u0026#39;)) // false console.log(reg.test(\u0026#39;前端web学习\u0026#39;)) // false console.log(reg.test(\u0026#39;we\u0026#39;)) // false // 2. 匹配结束的位置 $ const reg1 = /web$/ console.log(reg1.test(\u0026#39;web前端\u0026#39;)) // false console.log(reg1.test(\u0026#39;前端web\u0026#39;)) // true console.log(reg1.test(\u0026#39;前端web学习\u0026#39;)) // false console.log(reg1.test(\u0026#39;we\u0026#39;)) // false // 3. 精确匹配 ^ $ const reg2 = /^web$/ console.log(reg2.test(\u0026#39;web前端\u0026#39;)) // false console.log(reg2.test(\u0026#39;前端web\u0026#39;)) // false console.log(reg2.test(\u0026#39;前端web学习\u0026#39;)) // false console.log(reg2.test(\u0026#39;we\u0026#39;)) // false console.log(reg2.test(\u0026#39;web\u0026#39;)) // true console.log(reg2.test(\u0026#39;webweb\u0026#39;)) // flase \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 量词 量词用来设定某个模式重复次数\n注意： 逗号左右两侧千万不要出现空格\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 元字符之量词 // 1. * 重复次数 \u0026gt;= 0 次 const reg1 = /^w*$/ console.log(reg1.test(\u0026#39;\u0026#39;)) // true console.log(reg1.test(\u0026#39;w\u0026#39;)) // true console.log(reg1.test(\u0026#39;ww\u0026#39;)) // true console.log(reg1.test(\u0026#39;waw\u0026#39;)) // false console.log(\u0026#39;-----------------------\u0026#39;) // 2. + 重复次数 \u0026gt;= 1 次 const reg2 = /^w+$/ console.log(reg2.test(\u0026#39;\u0026#39;)) // false console.log(reg2.test(\u0026#39;w\u0026#39;)) // true console.log(reg2.test(\u0026#39;ww\u0026#39;)) // true console.log(\u0026#39;-----------------------\u0026#39;) // 3. ? 重复次数 0 || 1 const reg3 = /^w?$/ console.log(reg3.test(\u0026#39;\u0026#39;)) // true console.log(reg3.test(\u0026#39;w\u0026#39;)) // true console.log(reg3.test(\u0026#39;ww\u0026#39;)) // false console.log(\u0026#39;-----------------------\u0026#39;) // 4. {n} 重复 n 次 const reg4 = /^w{3}$/ console.log(reg4.test(\u0026#39;\u0026#39;)) // false console.log(reg4.test(\u0026#39;w\u0026#39;)) // flase console.log(reg4.test(\u0026#39;ww\u0026#39;)) // false console.log(reg4.test(\u0026#39;www\u0026#39;)) // true console.log(reg4.test(\u0026#39;wwww\u0026#39;)) // false console.log(\u0026#39;-----------------------\u0026#39;) // 5. {n,} 重复次数 \u0026gt;= n const reg5 = /^w{2,}$/ console.log(reg5.test(\u0026#39;\u0026#39;)) // false console.log(reg5.test(\u0026#39;w\u0026#39;)) // false console.log(reg5.test(\u0026#39;ww\u0026#39;)) // true console.log(reg5.test(\u0026#39;www\u0026#39;)) // true console.log(\u0026#39;-----------------------\u0026#39;) // 6. {n,m} n =\u0026lt; 重复次数 \u0026lt;= m const reg6 = /^w{2,4}$/ console.log(reg6.test(\u0026#39;w\u0026#39;)) // false console.log(reg6.test(\u0026#39;ww\u0026#39;)) // true console.log(reg6.test(\u0026#39;www\u0026#39;)) // true console.log(reg6.test(\u0026#39;wwww\u0026#39;)) // true console.log(reg6.test(\u0026#39;wwwww\u0026#39;)) // false // 7. 注意事项： 逗号两侧千万不要加空格否则会匹配失败 \u0026lt;/script\u0026gt; 范围 表示字符的范围，定义的规则限定在某个范围，比如只能是英文字母，或者数字等等，用表示范围\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 元字符之范围 [] // 1. [abc] 匹配包含的单个字符， 多选1 const reg1 = /^[abc]$/ console.log(reg1.test(\u0026#39;a\u0026#39;)) // true console.log(reg1.test(\u0026#39;b\u0026#39;)) // true console.log(reg1.test(\u0026#39;c\u0026#39;)) // true console.log(reg1.test(\u0026#39;d\u0026#39;)) // false console.log(reg1.test(\u0026#39;ab\u0026#39;)) // false // 2. [a-z] 连字符 单个 const reg2 = /^[a-z]$/ console.log(reg2.test(\u0026#39;a\u0026#39;)) // true console.log(reg2.test(\u0026#39;p\u0026#39;)) // true console.log(reg2.test(\u0026#39;0\u0026#39;)) // false console.log(reg2.test(\u0026#39;A\u0026#39;)) // false // 想要包含小写字母，大写字母 ，数字 const reg3 = /^[a-zA-Z0-9]$/ console.log(reg3.test(\u0026#39;B\u0026#39;)) // true console.log(reg3.test(\u0026#39;b\u0026#39;)) // true console.log(reg3.test(9)) // true console.log(reg3.test(\u0026#39;,\u0026#39;)) // flase // 用户名可以输入英文字母，数字，可以加下划线，要求 6~16位 const reg4 = /^[a-zA-Z0-9_]{6,16}$/ console.log(reg4.test(\u0026#39;abcd1\u0026#39;)) // false console.log(reg4.test(\u0026#39;abcd12\u0026#39;)) // true console.log(reg4.test(\u0026#39;ABcd12\u0026#39;)) // true console.log(reg4.test(\u0026#39;ABcd12_\u0026#39;)) // true // 3. [^a-z] 取反符 const reg5 = /^[^a-z]$/ console.log(reg5.test(\u0026#39;a\u0026#39;)) // false console.log(reg5.test(\u0026#39;A\u0026#39;)) // true console.log(reg5.test(8)) // true \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 字符类 某些常见模式的简写方式，区分字母和数字\n补充：. (点)匹配除换行符之外的任何单个字符\n小练习：用户名验证案例 需求：用户名要求用户英文字母,数字,下划线或者短横线组成，并且用户名长度为 6~16位\n分析：\n①：首先准备好这种正则表达式模式 /^[a-zA-Z0-9-_]{6,16}$/\n②：当表单失去焦点就开始验证.\n③：如果符合正则规范, 则让后面的span标签添加 right 类.\n④：如果不符合正则规范, 则让后面的span标签添加 wrong 类\n效果图：\n![](/assets/GIF 2024-11-3 23-36-56.gif)\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;用户名验证案例\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; span { display: inline-block; width: 250px; height: 30px; vertical-align: middle; line-height: 30px; padding-left: 15px; } .error { color: red; background: url(./images/error1.png) no-repeat left center; } .right { color: green; background: url(./images/right.png) no-repeat left center; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;script\u0026gt; const reg = /^[a-zA-Z0-9-_]{6,16}$/ const input = document.querySelector(\u0026#39;input\u0026#39;) const span = document.querySelector(\u0026#39;span\u0026#39;) // 输入框失去焦点时触发事件 input.addEventListener(\u0026#39;blur\u0026#39;, function() { if(reg.test(this.value)) { span.innerHTML = \u0026#39;输入正确\u0026#39; span.className = \u0026#39;right\u0026#39; }else { span.innerHTML = \u0026#39;请输入6~16位英文、数字或下划线\u0026#39; span.className = \u0026#39;error\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 替换和修饰符 replace() 替换方法，可以完成字符的替换\n1 2 3 4 5 6 7 8 9 10 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 替换和修饰符 const str = \u0026#39;欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神\u0026#39; // 1. 替换 replace 需求：把前端替换为 web // 1.1 replace 返回值是替换完毕的字符串 const strEnd = str.replace(/前端/, \u0026#39;web\u0026#39;) // 欢迎大家学习web，相信大家一定能学好前端，都成为前端大神 // 只能替换一个 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等\ni 是单词 ignore 的缩写，正则匹配时字母不区分大小写 1 2 3 console.log(/a/.test(\u0026#39;a\u0026#39;)) // true console.log(/a/.test(\u0026#39;A\u0026#39;)) // false console.log(/a/i.test(\u0026#39;A\u0026#39;)) // true g 是单词 global 的缩写，匹配所有满足正则表达式的结果 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 替换和修饰符 const str = \u0026#39;欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神\u0026#39; // 1. 替换 replace 需求：把前端替换为 web // 1.1 replace 返回值是替换完毕的字符串 // const strEnd = str.replace(/前端/, \u0026#39;web\u0026#39;) 只能替换一个 // 2. 修饰符 g 全部替换 const strEnd = str.replace(/前端/g, \u0026#39;web\u0026#39;) console.log(strEnd) // 欢迎大家学习web，相信大家一定能学好web，都成为web大神 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 注： i 和 g 可以同时写\n小练习：过滤敏感字 需求：要求用户不能输入敏感字\n比如，pink老师上课很有**\n分析：\n①：用户输入内容\n②：内容进行正则替换查找，找到敏感词，进行**\n③：要全局替换使用修饰符 g\n效果图：\n![](/assets/GIF 2024-11-4 22-24-58.gif)\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;textarea cols=\u0026#34;30\u0026#34; rows=\u0026#34;10\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;button\u0026gt;发布\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const tx = document.querySelector(\u0026#39;textarea\u0026#39;) const btn = document.querySelector(\u0026#39;button\u0026#39;) const div = document.querySelector(\u0026#39;div\u0026#39;) btn.addEventListener(\u0026#39;click\u0026#39;, function() { // 过滤所有敏感词 div.innerHTML = tx.value.replace(/敏感词|敏感/g, \u0026#39;***\u0026#39;) // 清空文本区 tx.value = \u0026#39;\u0026#39; }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 正则插件 change 事件 给input注册 change 事件，值被修改并且失去焦点后触发\n判断是否有类 元素.classList.contains() 看看有没有包含某个类，如果有则返回true，么有则返回false\n综合案例：页面注册 分析业务模块：\n①： 发送验证码模块\n②： 各个表单验证模块\n③： 勾选已经阅读同意模块\n④： 下一步验证全部模块\n只要上面有一个input验证不通过就不同意提交\n需求①： 发送验证码 用户点击之后，显示 05秒后重新获取\n时间到了，自动改为 重新获取\n需求②： 用户名验证（注意封装函数 verifyxxx） , 失去焦点触发这个函数 正则 /^[a-zA-Z0-9-_]{6,10}$/\n如果不符合要求，则出现提示信息 并 return false 中断程序\n否则 则返回return true\n之所以返回 布尔值，是为了 最后的提交按钮做准备\n侦听使用change事件，当鼠标离开了表单，并且表单值发生了变化时触发（类似京东效果）\n需求③： 手机号验证 正则: /^1(3\\d|4[5-9]|5[0-35-9]|6[567]|7[0-8]|8\\d|9[0-35-9])\\d{8}$/\n其余同上\n需求④： 验证码验证 正则 /^\\d{6}$/\n其余同上\n需求⑤： 密码验证 正则 /^[a-zA-Z0-9-_]{6,20}$/\n其余同上\n需求⑥： 再次密码验证 如果本次密码不等于上面输入的密码则返回错误信息\n其余同上\n需求⑦： 我同意模块 添加类 .icon-queren2 则是默认选中样式 可以使用 toggle切换类\n需求⑧： 表单提交模块 使用 submit 提交事件\n如果没有勾选同意协议，则提示 需要勾选\nclassList.contains()看看有没有包含某个类，如果有则返回true，么有则返回false\n如果上面input表单 只要有模块，返回的是 false 则 阻止提交\n效果图：\n代码：\n","date":"2024-03-27T15:07:06+08:00","permalink":"https://IAmYuanyu.github.io/p/javascriptapis/","title":"JavaScriptAPIs"},{"content":"JavaScript 基础 - 第1天 了解变量、数据类型、运算符等基础概念，能够实现数据类型的转换，结合四则运算体会如何编程。\n体会现实世界中的事物与计算机的关系 理解什么是数据并知道数据的分类 理解变量存储数据的“容器” 掌握常见运算符的使用，了解优先级关系 知道 JavaScript 数据类型隐式转换的特征 介绍 掌握 JavaScript 的引入方式，初步认识 JavaScript 的作用\n引入方式 JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 script 标签将 JavaScript 代码引入到 HTML 中，有两种方式：\n内部方式 通过 script 标签包裹 JavaScript 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 引入方式\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 内联形式：通过 script 标签包裹 JavaScript 代码 --\u0026gt; \u0026lt;script\u0026gt; alert(\u0026#39;嗨，欢迎来传智播学习前端技术！\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 外部形式 一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 script 标签的 src 属性引入\n1 2 // demo.js document.write(\u0026#39;嗨，欢迎来传智播学习前端技术！\u0026#39;) 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 引入方式\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --\u0026gt; \u0026lt;script src=\u0026#34;demo.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如果 script 标签使用 src 属性引入了某 .js 文件，那么标签内的代码会被忽略！！！如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 引入方式\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --\u0026gt; \u0026lt;script src=\u0026#34;demo.js\u0026#34;\u0026gt; // 此处的代码会被忽略掉！！！！ alert(666); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注：一般把写在上方（并无硬性要求）\n注释和结束符 通过注释可以屏蔽代码被执行或者添加备注信息，JavaScript 支持两种形式注释语法：\n单行注释 使用 // 注释单行代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 注释\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 这种是单行注释的语法 // 一次只能注释一行 // 可以重复注释 document.write(\u0026#39;嗨，欢迎来传智播学习前端技术！\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 多行注释 使用 /* */ 注释多行代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 注释\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; /* 这种的是多行注释的语法 */ /* 更常见的多行注释是这种写法 在些可以任意换行 多少行都可以 */ document.write(\u0026#39;嗨，欢迎来传智播学习前端技术！\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注：编辑器中单行注释的快捷键为 ctrl + /\n结束符 在 JavaScript 中 ; 代表一段代码的结束，多数情况下可以省略 ; 使用回车（enter）替代。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 结束符\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; alert(1); alert(2); alert(1) alert(2) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实际开发中有许多人主张书写 JavaScript 代码时省略结束符 ;\n输入和输出 输出和输入也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程。\n举例说明：如按键盘上的方向键，向上/下键可以滚动页面，按向上/下键这个动作叫作输入，页面发生了滚动了这便叫输出。\n输出 JavaScript 可以接收用户的输入，然后再将输入的结果输出：\nalert()、document.wirte()、console.log()\n以数字为例，向 alert() 或 document.write()输入任意数字，他都会以弹窗形式展示（输出）给用户。\n例子1：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; alert(\u0026#39;这是一个对话框\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n例子2：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; document.write(\u0026#39;这是一句话\u0026#39;) document.write(\u0026#39;\u0026lt;h1\u0026gt;我是h1标题\u0026lt;/h1\u0026gt;\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n例子3：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; console.log(\u0026#39;在这呢\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n输入 向 prompt() 输入任意内容会以弹窗形式出现在浏览器中，一般提示用户输入一些内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 输入输出\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 1. 输入的任意数字，都会以弹窗形式展示 document.write(\u0026#39;要输出的内容\u0026#39;) alert(\u0026#39;要输出的内容\u0026#39;); // 2. 以弹窗形式提示用户输入姓名，注意这里的文字使用英文的引号 prompt(\u0026#39;请输入您的姓名:\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 例1：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; prompt(\u0026#39;请输入\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n变量 理解变量是计算机存储数据的“容器”，掌握变量的声明方式\n变量是计算机中用来存储数据的“容器”，它可以让计算机变得有记忆，通俗的理解变量就是使用【某个符号】来代表【某个具体的数值】（数据）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; // x 符号代表了 5 这个数值 x = 5 // y 符号代表了 6 这个数值 y = 6 //举例： 在 JavaScript 中使用变量可以将某个数据（数值）记录下来！ // 将用户输入的内容保存在 num 这个变量（容器）中 num = prompt(\u0026#39;请输入一数字!\u0026#39;) // 通过 num 变量（容器）将用户输入的内容输出出来 alert(num) document.write(num) \u0026lt;/script\u0026gt; 声明 声明(定义)变量有两部分构成：声明关键字、变量名（标识）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 声明和赋值\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // let 变量名 // 声明(定义)变量有两部分构成：声明关键字、变量名（标识） // let 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语 // age 即变量的名称，也叫标识符 let age \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 关键字是 JavaScript 中内置的一些英文词汇（单词或缩写），它们代表某些特定的含义，如 let 的含义是声明变量的，看到 let 后就可想到这行代码的意思是在声明变量，如 let age;\nlet 和 var 都是 JavaScript 中的声明变量的关键字，推荐使用 let 声明变量！！！\n赋值 声明（定义）变量相当于创造了一个空的“容器”，通过赋值向这个容器中添加数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 声明和赋值\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 声明(定义)变量有两部分构成：声明关键字、变量名（标识） // let 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语 // age 即变量的名称，也叫标识符 let age // 赋值，将 18 这个数据存入了 age 这个“容器”中 age = 18 // 这样 age 的值就成了 18 document.write(age) // 也可以声明和赋值同时进行 let str = \u0026#39;hello world!\u0026#39; alert(str); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 例：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let temp = prompt(\u0026#39;请输入\u0026#39;) document.write(temp) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n![](/assets/GIF 2024-10-14 21-43-12.gif)\n关键字 JavaScript 使用专门的关键字 let 和 var 来声明（定义）变量，在使用时需要注意一些细节：\n以下是使用 let 时的注意事项：\n允许声明和赋值同时进行 不允许重复声明 允许同时声明多个变量并赋值 JavaScript 中内置的一些关键字不能被当做变量名 以下是使用 var 时的注意事项：\n允许声明和赋值同时进行 允许重复声明 允许同时声明多个变量并赋值 大部分情况使用 let 和 var 区别不大，但是 let 相较 var 更严谨，因此推荐使用 let，后期会更进一步介绍二者间的区别。\n变量名命名规则 关于变量的名称（标识符）有一系列的规则需要遵守：\n只能是字母、数字、下划线_、$，且不能能数字开头 字母区分大小写，如 Age 和 age 是不同的变量 JavaScript 内部已占用于单词（关键字或保留字）不允许使用 尽量保证变量具有一定的语义，见字知义 注：所谓关键字是指 JavaScript 内部使用的词语，如 let 和var，保留字是指 JavaScript 内部目前没有使用的词语，但是将来可能会使用词语。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 变量名命名规则\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let age = 18 // 正确 let age1 = 18 // 正确 let _age = 18 // 正确 // let 1age = 18; // 错误，不可以数字开头 let $age = 18 // 正确 let Age = 24 // 正确，它与小写的 age 是不同的变量 // let let = 18; // 错误，let 是关键字 let int = 123 // 不推荐，int 是保留字 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 数组 1.声明语法：let 数组名 = [数据1,数据2,……,数据n]\n例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let arr = [\u0026#39;小明\u0026#39;, \u0026#39;小日\u0026#39;, \u0026#39;小月\u0026#39;, 1, 2, 3] document.write(arr) document.write(\u0026#39;\u0026lt;br/\u0026gt;\u0026#39;,arr[2]) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n2.数组长度：可以通过length属性获得\n例：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let arr = [\u0026#39;小明\u0026#39;,\u0026#39;小日\u0026#39;,\u0026#39;小月\u0026#39;,1,2,3] document.write(arr.length) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n常量（const的声明） 概念：使用 const 声明的变量称为“常量”。\n使用场景：当某个变量永远不会改变的时候，就可以使用 const 来声明，而不是let。\n命名规范：和变量一致\n1 const PI = 3.14 注意： 常量不允许重新赋值,声明的时候必须赋值（初始化）\n补充：\n在声明一些未来不太会被修改的变量时，一般使用const\n对于复杂类型数据，比如数组一般可以使用const声明，因为此时栈中存放的是数组对象实例所在的地址，对该数组进行增加、删除或修改等操作时，数组依旧是原来的数组，地址并不会变，因此对数组进行增加、删除或修改等操作时并不会报错（但如果修改了数组的地址就会报错）\n如下情况中，就可以把let改为const\n而下列左边的情况就不能用const，否则会报错\n数据类型 计算机世界中的万事成物都是数据。\n计算机程序可以处理大量的数据，为了方便数据的管理，将数据分成了不同的类型：\nnumber数字型、string字符串型、boolean布尔型、undefined未定义型、null空类型\n注：通过 typeof 关键字检测数据类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 数据类型\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 检测 1 是什么类型数据，结果为 number document.write(typeof 1) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 数值类型 即我们数学中学习到的数字，可以是整数、小数、正数、负数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 数据类型\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let score = 100 // 正整数 let price = 12.345 // 小数 let temperature = -40 // 负数 document.write(typeof score) // 结果为 number document.write(typeof price) // 结果为 number document.write(typeof temperature) // 结果为 number \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JavaScript 中的数值类型与数学中的数字是一样的，分为正数、负数、小数等。\n输入不符合规范的计算时，会输出NaN（Not a Number）\n例：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let num = \u0026#39;你好\u0026#39; * 2 document.write(num) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n字符串类型 通过单引号（ ''） 、双引号（ \u0026quot;\u0026quot;）或反引号（``）包裹的数据都叫字符串，单引号和双引号没有本质上的区别，推荐使用单引号。\n注意事项：\n无论单引号或是双引号必须成对使用 单引号/双引号可以互相嵌套，但是不以自已嵌套自已 必要时可以使用转义符 \\，输出单引号或双引号 prompt收集的数据默认是字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 数据类型\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let user_name = \u0026#39;小明\u0026#39; // 使用单引号 let gender = \u0026#34;男\u0026#34; // 使用双引号 let str = \u0026#39;123\u0026#39; // 看上去是数字，但是用引号包裹了就成了字符串了 let str1 = \u0026#39;\u0026#39; // 这种情况叫空字符串 documeent.write(typeof user_name) // 结果为 string documeent.write(typeof gender) // 结果为 string documeent.write(typeof str) // 结果为 string \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let num1 = prompt(\u0026#39;请输入一个数字\u0026#39;) let num2 = prompt(\u0026#39;请再输入一个数字\u0026#39;) let sum = num1 + num2 document.write(typeof num1) document.write(`\u0026lt;br\u0026gt;${typeof num2}`) document.write(`\u0026lt;br\u0026gt;两个数字相加等于${sum}`) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n![](/assets/GIF 2024-10-15 16-10-12.gif)\n字符串的拼接 两个字符串可以用 + 来连接，字符串 + 数字会自动拼接成字符串\n例1：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let myname = \u0026#39;我的\u0026#39; + \u0026#39;名字\u0026#39; document.write(myname) //输出：我的名字 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 例2：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let age = 18 document.write(\u0026#39;我今年\u0026#39; + age + \u0026#39;岁\u0026#39;) //输出：我今年18岁 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 模板字符串 使用场景：字符串的拼接，用+拼接字符串比较不方便，所以一般用模板字符串拼接变量\n语法：最外面用反应号包裹``，用${}包住变量\n例1：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let age = 18 document.write(`我今年${age}岁`) //输出：我今年18岁 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let name = prompt(\u0026#39;名字\u0026#39;) let age = prompt(\u0026#39;年龄\u0026#39;) document.write(`你的名字是：${name}，年龄是${age}岁`) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n![](/assets/GIF 2024-10-15 13-20-18.gif)\n布尔类型 表示肯定或否定时在计算机中对应的是布尔类型数据，它有两个固定的值 true 和 false，表示肯定的数据用 true，表示否定的数据用 false。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 数据类型\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // pink老师帅不帅？回答 是 或 否 let isCool = true // 是的，摔死了！ isCool = false // 不，套马杆的汉子！ document.write(typeof isCool) // 结果为 boolean \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; undefined 未定义是比较特殊的类型，只有一个值 undefined，只声明变量，不赋值的情况下，变量的默认值为 undefined，一般很少【直接】为某个变量赋值为 undefined。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 数据类型\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 只声明了变量，并末赋值 let tmp; document.write(typeof tmp) // 结果为 undefined \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注：JavaScript 中变量的值决定了变量的数据类型。\nnull null仅仅是一个代表“无”、“空”或“值未知”的特殊值\nnull和undefined区别：\n1.undefined表示没有赋值\n2.null表示赋值了，但是内容为空\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; document.write(undefined + 1)//输出：NaN document.write(null + 1)//输出：1 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; null开发中的使用场景：\n把null作为尚未创建的对象（将来有个变量里面存放的是一个对象，但是对象还没创建好，可以先给个null）\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let temp = null document.write(typeof temp)//输出：object document.write(temp)//输出：null \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 类型转换 理解弱类型语言的特征，掌握显式类型转换的方法\n在 JavaScript 中数据被分成了不同的类型，如数值、字符串、布尔值、undefined，在实际编程的过程中，不同数据类型之间存在着转换的关系。\n隐式转换 某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。\n规则：\n+号两边只要有一个是字符串，都会把另外一个转成字符串 除了+以外的算术运算符，比如 -、*、/ 等都会把数据转成数字类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 隐式转换\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let num = 13 // 数值 let num2 = \u0026#39;2\u0026#39; // 字符串 // 结果为 132 // 原因是将数值 num 转换成了字符串，相当于 \u0026#39;13\u0026#39; // 然后 + 将两个字符串拼接到了一起 console.log(num + num2) // 结果为 11 // 原因是将字符串 num2 转换成了数值，相当于 2 // 然后数值 13 减去 数值 2 console.log(num - num2) let a = prompt(\u0026#39;请输入一个数字\u0026#39;) let b = prompt(\u0026#39;请再输入一个数字\u0026#39;) alert(a + b); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注：数据类型的隐式转换是 JavaScript 的特征，后续学习中还会遇到，目前先需要理解什么是隐式转换。\n补充介绍模板字符串的拼接的使用\n小技巧：\n+号作为正号解析可以转换成数字型 任何数据和字符串相加结果都是字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; console.log(11 + 11)//22 console.log(\u0026#39;11\u0026#39; + 11)//1111 console.log(11 - 11)//0 console.log(\u0026#39;11\u0026#39; - 11)//0 console.log(1 * 1)//1 console.log(\u0026#39;1\u0026#39; * 1)//1 console.log(typeof \u0026#39;123\u0026#39;)//string console.log(typeof +\u0026#39;123\u0026#39;)//number console.log(+\u0026#39;11\u0026#39; + 11)//22 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let num1 = +prompt(\u0026#39;请输入一个数字\u0026#39;) let num2 = +prompt(\u0026#39;请再输入一个数字\u0026#39;) alert(`两数相加等于${num1 + num2}`) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n![](/assets/GIF 2024-10-15 16-36-22-1728981521569-4.gif)\n显式转换 编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。\nNumber() 通过 Number 显示转换成数值类型，当转换失败时结果为 NaN（Not a Number）即不是一个数字。（NaN也是number类型的数据，代表非数字）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 隐式转换\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let t = \u0026#39;12\u0026#39; let f = 8 // 显式将字符串 12 转换成数值 12 t = Number(t) // 检测转换后的类型 // console.log(typeof t); console.log(t + f) // 结果为 20 // 并不是所有的值都可以被转成数值类型 let str = \u0026#39;hello\u0026#39; // 将 hello 转成数值是不现实的，当无法转换成 // 数值时，得到的结果为 NaN （Not a Number） console.log(Number(str)) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let num1 = Number(prompt(\u0026#39;请输入一个数字\u0026#39;)) let num2 = Number(prompt(\u0026#39;请再输入一个数字\u0026#39;)) alert(`两数相加等于${num1 + num2}`) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n![](/assets/GIF 2024-10-15 16-36-22.gif)\nparseInt() 只保留整数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; console.log(parseInt(\u0026#39;12px\u0026#39;))//输出：12 console.log(parseInt(\u0026#39;12.01px\u0026#39;))//输出：12 console.log(parseInt(\u0026#39;12.99px\u0026#39;))//输出：12 console.log(parseInt(\u0026#39;12.34px56\u0026#39;))//输出：12 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; parseFloat() 可以保留小数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; console.log(parseFloat(\u0026#39;12px\u0026#39;))//输出：12 console.log(parseFloat(\u0026#39;12.01px\u0026#39;))//输出：12.01 console.log(parseFloat(\u0026#39;12.99px\u0026#39;))//输出：12.99 console.log(parseFloat(\u0026#39;12.34px56\u0026#39;))//输出：12.34 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; String()、变量.toString() 转化成字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let temp = 123 console.log(typeof temp)//number temp = String(temp) console.log(typeof temp)//string temp = 123 console.log(typeof temp)//number temp = temp.toString() console.log(typeof temp)//string \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 常见错误 1.\n2.\n3.\n4.\n5.\n综合案例 实现以下效果：\n![](/assets/GIF 2024-10-15 17-21-32.gif)\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;综合1\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; h2 { text-align: center; } table,th,td { margin: auto; border: 1px solid black; } table { /* 合并相邻边框 */ border-collapse: collapse; height: 100px; text-align: center; } th,td { padding: 5px 30px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;订单确认\u0026lt;/h2\u0026gt; \u0026lt;script\u0026gt; let name = prompt(\u0026#39;请输入商品名称：\u0026#39;) let price = +prompt(\u0026#39;请输入商品价格：\u0026#39;) let num = +prompt(\u0026#39;请输入商品数量：\u0026#39;) let address = prompt(\u0026#39;请输入收货地址\u0026#39;) let sum = price * num //总价 document.write(` \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;商品名称\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品价格\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品数量\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;总价\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;收货地址\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;${name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${price}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${num}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${sum}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${address}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; `) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JavaScript 基础 - 第2天 理解什么是流程控制，知道条件控制的种类并掌握其对应的语法规则，具备利用循环编写简易ATM取款机程序能力\n运算符 语句 综合案例 运算符 算术运算符 数字是用来计算的，比如：乘法 * 、除法 / 、加法 + 、减法 - 等等，所以经常和算术运算符一起。\n算术运算符：也叫数学运算符，主要包括加、减、乘、除、取余（求模）等\n运算符 作用 + 求和 - 求差 * 求积 / 求商 % 取模（取余数），开发中经常用于作为某个数字是否被整除 注意：在计算失败时，显示的结果是 NaN （not a number）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 算术运算符 console.log(1 + 2 * 3 / 2) // 4 let num = 10 console.log(num + 10) // 20 console.log(num + num) // 20 // 1. 取模(取余数) 使用场景： 用来判断某个数是否能够被整除 console.log(4 % 2) // 0 console.log(6 % 3) // 0 console.log(5 % 3) // 2 console.log(3 % 5) // 3 // 2. 注意事项 : 如果我们计算失败，则返回的结果是 NaN (not a number) console.log(\u0026#39;pink老师\u0026#39; - 2) console.log(\u0026#39;pink老师\u0026#39; * 2) console.log(\u0026#39;pink老师\u0026#39; + 2) // pink老师2 赋值运算符 赋值运算符：对变量进行赋值的运算符\n= 将等号右边的值赋予给左边, 要求左边必须是一个容器\n运算符 作用 += 加法赋值 -+ 减法赋值 *= 乘法赋值 /= 除法赋值 %= 取余赋值 1 2 3 4 5 6 7 8 \u0026lt;script\u0026gt; let num = 1 // num = num + 1 // 采取赋值运算符 // num += 1 num += 3 console.log(num) \u0026lt;/script\u0026gt; 自增/自减运算符 符号 作用 说明 ++ 自增 变量自身的值加1，例如: x++ \u0026ndash; 自减 变量自身的值减1，例如: x\u0026ndash; ++在前和++在后在单独使用时二者并没有差别，而且一般开发中我们都是独立使用 ++在后（后缀式）我们会使用更多 注意：\n只有变量能够使用自增和自减运算符 ++、\u0026ndash; 可以在变量前面也可以在变量后面，比如: x++ 或者 ++x 前置自增：先自加再使用 后置自增：先使用再自加 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;script\u0026gt; // let num = 10 // num = num + 1 // num += 1 // // 1. 前置自增 // let i = 1 // ++i // console.log(i) // let i = 1 // console.log(++i + 1)//3 // 2. 后置自增 // let i = 1 // i++ // console.log(i) // let i = 1 // console.log(i++ + 1)//输出2 // console.log(i)//输出2 // 了解 let i = 1 console.log(i++ + ++i + i)//7（1+3+3） \u0026lt;/script\u0026gt; 比较运算符 使用场景：比较两个数据大小、是否相等，根据比较结果返回一个布尔值（true / false）\n运算符 作用 \u0026gt; 左边是否大于右边 \u0026lt; 左边是否小于右边 \u0026gt;= 左边是否大于或等于右边 \u0026lt;= 左边是否小于或等于右边 === 左右两边是否类型和值都相等（重点） == 左右两边值是否相等 != 左右值不相等 !== 左右两边是否不全等 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;script\u0026gt; console.log(3 \u0026gt; 5) console.log(3 \u0026gt;= 3) console.log(2 == 2) // 比较运算符有隐式转换 把\u0026#39;2\u0026#39; 转换为 2 双等号 只判断值 console.log(2 == \u0026#39;2\u0026#39;) // true // console.log(undefined === null) // false // === 全等 判断 值 和 数据类型都一样才行 // 以后判断是否相等 请用 === console.log(2 === \u0026#39;2\u0026#39;) // false console.log(NaN === NaN) // false(NaN 不等于任何人，包括他自己) console.log(2 !== \u0026#39;2\u0026#39;) // true console.log(2 != \u0026#39;2\u0026#39;) // false console.log(\u0026#39;-------------------------\u0026#39;) //字符串依次比较字母的ASCII码，第一个字母和第一个字母比 //若相同就依次往后比 console.log(\u0026#39;a\u0026#39; \u0026lt; \u0026#39;b\u0026#39;) // true console.log(\u0026#39;aa\u0026#39; \u0026lt; \u0026#39;ab\u0026#39;) // true console.log(\u0026#39;aa\u0026#39; \u0026lt; \u0026#39;aac\u0026#39;) // true console.log(\u0026#39;-------------------------\u0026#39;) \u0026lt;/script\u0026gt; 逻辑运算符 使用场景：可以把多个布尔值放到一起运算，最终返回一个布尔值\n符号 名称 日常读法 特点 口诀 \u0026amp;\u0026amp; 逻辑与 并且 符号两边有一个假的结果为假 一假则假 || 逻辑或 或者 符号两边有一个真的结果为真 一真则真 ! 逻辑非 取反 true变false false变true 真变假，假变真 A B A \u0026amp;\u0026amp; B A || B !A false false false false true false true false true true true false false true false true true true true false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;script\u0026gt; // 逻辑与 一假则假 console.log(true \u0026amp;\u0026amp; true)\t//true console.log(false \u0026amp;\u0026amp; true)\t//false console.log(3 \u0026lt; 5 \u0026amp;\u0026amp; 3 \u0026gt; 2)\t//true console.log(3 \u0026lt; 5 \u0026amp;\u0026amp; 3 \u0026lt; 2)\t//false console.log(\u0026#39;-----------------\u0026#39;) // 逻辑或 一真则真 console.log(true || true)\t//true console.log(false || true)\t//true console.log(false || false)\t//false console.log(\u0026#39;-----------------\u0026#39;) // 逻辑非 取反 console.log(!true)\t//false console.log(!false)\t//true console.log(\u0026#39;-----------------\u0026#39;) let num = 6 console.log(num \u0026gt; 5 \u0026amp;\u0026amp; num \u0026lt; 10)//true console.log(\u0026#39;-----------------\u0026#39;) \u0026lt;/script\u0026gt; 练习：判断一个数是否能被4整除，但不能被100整除\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let num = +prompt(\u0026#39;判断这个数是否能被4整除，但不能被100整除\u0026#39;) alert(num % 4 === 0 \u0026amp;\u0026amp; num % 100 !== 0) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 运算符优先级 逻辑运算符优先级： ！\u0026gt; \u0026amp;\u0026amp; \u0026gt; ||\n语句 表达式和语句 分支语句 分支语句可以根据条件判定真假，来选择性的执行想要的代码\n分支语句包含：\nif分支语句（重点） 三元运算符 switch语句 if 分支语句 语法：\n1 2 3 if(条件表达式) { // 满足条件要执行的语句 } 小括号内的条件结果是布尔值，为 true 时，进入大括号里执行代码；为false，则不执行大括号里面代码\n小括号内的结果若不是布尔类型时，会发生类型转换为布尔值，类似Boolean()\n如果大括号只有一个语句，大括号可以省略，但是，俺们不提倡这么做~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;script\u0026gt; // 单分支语句 // if (false) { // console.log(\u0026#39;执行语句\u0026#39;) // } // if (3 \u0026gt; 5) { // console.log(\u0026#39;执行语句\u0026#39;) // } // if (2 === \u0026#39;2\u0026#39;) { // console.log(\u0026#39;执行语句\u0026#39;) // } // 1. 除了0 所有的数字都为真 // if (0) { // console.log(\u0026#39;执行语句\u0026#39;) // } // 2.除了 \u0026#39;\u0026#39; 所有的字符串都为真 true // if (\u0026#39;pink老师\u0026#39;) { // console.log(\u0026#39;执行语句\u0026#39;) // } // if (\u0026#39;\u0026#39;) { // console.log(\u0026#39;执行语句\u0026#39;) // } // // if (\u0026#39;\u0026#39;) console.log(\u0026#39;执行语句\u0026#39;) // 1. 用户输入 let score = +prompt(\u0026#39;请输入成绩\u0026#39;) // 2. 进行判断输出 if (score \u0026gt;= 700) { alert(\u0026#39;恭喜考入黑马程序员\u0026#39;) } console.log(\u0026#39;-----------------\u0026#39;) \u0026lt;/script\u0026gt; if双分支语句 如果有两个条件的时候，可以使用 if else 双分支语句\n1 2 3 4 5 if (条件表达式){ // 满足条件要执行的语句 } else { // 不满足条件要执行的语句 } 例如：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; // 1. 用户输入 let uname = prompt(\u0026#39;请输入用户名:\u0026#39;) let pwd = prompt(\u0026#39;请输入密码:\u0026#39;) // 2. 判断输出 if (uname === \u0026#39;pink\u0026#39; \u0026amp;\u0026amp; pwd === \u0026#39;123456\u0026#39;) { alert(\u0026#39;恭喜登录成功\u0026#39;) } else { alert(\u0026#39;用户名或者密码错误\u0026#39;) } \u0026lt;/script\u0026gt; if 多分支语句 使用场景： 适合于有多个条件的时候\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; // 1. 用户输入 let score = +prompt(\u0026#39;请输入成绩：\u0026#39;) // 2. 判断输出 if (score \u0026gt;= 90) { alert(\u0026#39;成绩优秀，宝贝，你是我的骄傲\u0026#39;) } else if (score \u0026gt;= 70) { alert(\u0026#39;成绩良好，宝贝，你要加油哦~~\u0026#39;) } else if (score \u0026gt;= 60) { alert(\u0026#39;成绩及格，宝贝，你很危险~\u0026#39;) } else { alert(\u0026#39;成绩不及格，宝贝，我不想和你说话，我只想用鞭子和你说话~\u0026#39;) } \u0026lt;/script\u0026gt; 三元运算符（三元表达式） 使用场景： 一些简单的双分支，可以使用 三元运算符（三元表达式），写起来比 if else双分支 更简单\n符号：? 与 : 配合使用\n语法：\n1 条件 ? 表达式1 ： 表达式2 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 三元运算符（三元表达式） // 1. 语法格式 // 条件 ? 表达式1 : 表达式2 // 2. 执行过程 // 2.1 如果条件为真，则执行表达式1 // 2.2 如果条件为假，则执行表达式2 // 3. 验证 // 5 \u0026gt; 3 ? \u0026#39;真的\u0026#39; : \u0026#39;假的\u0026#39; console.log(5 \u0026lt; 3 ? \u0026#39;真的\u0026#39; : \u0026#39;假的\u0026#39;) // let age = 18 // age = age + 1 // age++ // 1. 用户输入 let num = prompt(\u0026#39;请您输入一个数字:\u0026#39;) // 2. 判断输出- 小于10才补0 // num = num \u0026lt; 10 ? 0 + num : num num = num \u0026gt;= 10 ? num : 0 + num alert(num) switch语句（了解） 使用场景： 适合于有多个条件的时候，也属于分支语句，大部分情况下和 if多分支语句 功能相同\n注意：\nswitch case语句一般用于等值判断, if适合于区间判断 switchcase一般需要配合break关键字使用 没有break会造成case穿透 if 多分支语句开发要比switch更重要，使用也更多 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // switch分支语句 // 1. 语法 // switch (表达式) { // case 值1: // 代码1 // break // case 值2: // 代码2 // break // ... // default: // 代码n // } \u0026lt;script\u0026gt; switch (2) { case 1: console.log(\u0026#39;您选择的是1\u0026#39;) break // 退出switch case 2: console.log(\u0026#39;您选择的是2\u0026#39;) break // 退出switch case 3: console.log(\u0026#39;您选择的是3\u0026#39;) break // 退出switch default: console.log(\u0026#39;没有符合条件的\u0026#39;) } \u0026lt;/script\u0026gt; 练习：输入两个数和+-*/中的一个符号，并输出结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let num1 = +prompt(\u0026#39;请输入一个数\u0026#39;) let num2 = +prompt(\u0026#39;请再输入一个数\u0026#39;) let sp = prompt(\u0026#39;请输入运算符号\u0026#39;) switch (sp) { case \u0026#39;+\u0026#39;: alert(`${num1 + sp + num2}结果是${num1 + num2}`) break case \u0026#39;-\u0026#39;: alert(`${num1 + sp + num2}结果是${num1 - num2}`) break case \u0026#39;*\u0026#39;: alert(`${num1 + sp + num2}结果是${num1 * num2}`) break case \u0026#39;/\u0026#39;: alert(`${num1 + sp + num2}结果是${num1 / num2}`) break default: alert(\u0026#39;请从+-*/中选一个符号\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 断点调试 **作用：**学习时可以帮助更好的理解代码运行，工作时可以更快找到bug\n浏览器打开调试界面\n按F12打开开发者工具 点到源代码一栏 （ sources ） 选择代码文件 **断点：**在某句代码上加的标记就叫断点，当程序执行到这句有标记的代码时会暂停下来\n![](/assets/GIF 2024-10-15 23-24-39.gif)\n循环语句 使用场景：重复执行 指定的一段代码，比如我们想要输出10次 \u0026lsquo;我学的很棒\u0026rsquo;\n学习路径：\n1.while循环\n2.for 循环（重点）\nwhile循环 while : 在…. 期间， 所以 while循环 就是在满足条件期间，重复执行某些代码。\n语法：\n1 2 3 while (条件表达式) { // 循环体 } 例如：\n1 2 3 4 5 6 7 8 // while循环: 重复执行代码 // 1. 需求: 利用循环重复打印3次 \u0026#39;月薪过万不是梦，毕业时候见英雄\u0026#39; let i = 1 while (i \u0026lt;= 3) { document.write(\u0026#39;月薪过万不是梦，毕业时候见英雄~\u0026lt;br\u0026gt;\u0026#39;) i++ // 这里千万不要忘了变量自增否则造成死循环 } 循环三要素：\n1.初始值 （经常用变量）\n2.终止条件\n3.变量的变化量\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;script\u0026gt; // // 1. 变量的起始值 // let i = 1 // // 2. 终止条件 // while (i \u0026lt;= 3) { // document.write(\u0026#39;我要循环三次 \u0026lt;br\u0026gt;\u0026#39;) // // 3. 变量的变化量 // i++ // } // 1. 变量的起始值 let end = +prompt(\u0026#39;请输入次数:\u0026#39;) let i = 1 // 2. 终止条件 while (i \u0026lt;= end) { document.write(\u0026#39;我要循环三次 \u0026lt;br\u0026gt;\u0026#39;) // 3. 变量的变化量 i++ } \u0026lt;/script\u0026gt; 中止循环 break 中止整个循环，一般用于结果已经得到, 后续的循环不需要的时候可以使用（提高效率）\ncontinue 中止本次循环，一般用于排除或者跳过某一个选项的时候\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script\u0026gt; // let i = 1 // while (i \u0026lt;= 5) { // console.log(i) // if (i === 3) { // break // 退出循环 // } // i++ // } let i = 1 while (i \u0026lt;= 5) { if (i === 3) { i++ continue } console.log(i) i++ } \u0026lt;/script\u0026gt; 无限循环 1.while(true) 来构造“无限”循环，需要使用break退出循环。（常用）\n2.for(;;) 也可以来构造“无限”循环，同样需要使用break退出循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 无限循环 // 需求： 页面会一直弹窗询问你爱我吗？ // (1). 如果用户输入的是 \u0026#39;爱\u0026#39;，则退出弹窗 // (2). 否则一直弹窗询问 // 1. while(true) 无限循环 // while (true) { // let love = prompt(\u0026#39;你爱我吗?\u0026#39;) // if (love === \u0026#39;爱\u0026#39;) { // break // } // } // 2. for(;;) 无限循环 for (; ;) { let love = prompt(\u0026#39;你爱我吗?\u0026#39;) if (love === \u0026#39;爱\u0026#39;) { break } } 练习 计算1-100之间的所有偶数和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let i = 1 let sum = 0 while (i \u0026lt;= 100) { if (i % 2 === 0) { sum += i } i++ } document.write(sum)//2550 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 综合案例-ATM存取款机 分析：\n①：提示输入框写到循环里面（无限循环）\n②：用户输入4则退出循环 break\n③：提前准备一个金额预先存储一个数额 money\n④：根据输入不同的值，做不同的操作\n​ (1) 取钱则是减法操作， 存钱则是加法操作，查看余额则是直接显示金额\n​ (2) 可以使用 if else if 多分支 来执行不同的操作\n完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;script\u0026gt; // 1. 开始循环 输入框写到 循环里面 // 3. 准备一个总的金额 let money = 100 while (true) { let re = +prompt(` 请您选择操作： 1.存钱 2.取钱 3.查看余额 4.退出 `) // 2. 如果用户输入的 4 则退出循环， break 写到if 里面，没有写到switch里面， 因为4需要break退出循环 if (re === 4) { break } // 4. 根据输入做操作 switch (re) { case 1: // 存钱 let cun = +prompt(\u0026#39;请输入存款金额\u0026#39;) money = money + cun break case 2: // 存钱 let qu = +prompt(\u0026#39;请输入取款金额\u0026#39;) money = money - qu break case 3: // 存钱 alert(`您的银行卡余额是${money}`) break } } \u0026lt;/script\u0026gt; 我自己写的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let event let money = 0 while(event !== \u0026#39;退出\u0026#39;) { event = prompt(` 请输入要进行的操作 1.存钱 2.取钱 3.查询余额 4.退出 `) switch (event) { case \u0026#39;存钱\u0026#39;: money += +prompt(\u0026#39;请输入要存入金额\u0026#39;) break case \u0026#39;取钱\u0026#39;: money -= +prompt(\u0026#39;请输入要取出金额\u0026#39;) break case \u0026#39;查询余额\u0026#39;: alert(`当前余额为${money}元`) break case \u0026#39;退出\u0026#39;: break; default: alert(\u0026#39;请输入正确操作！\u0026#39;) } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JavaScript 基础第三天笔记 if 多分支语句和 switch的区别：\n共同点\n都能实现多分支选择， 多选1 大部分情况下可以互换 区别：\nswitch…case语句通常处理case为比较确定值的情况，而if…else…语句更加灵活，通常用于范围判断(大于，等于某个范围)。 switch 语句进行判断后直接执行到程序的语句，效率更高，而if…else语句有几种判断条件，就得判断多少次 switch 一定要注意 必须是 === 全等，一定注意 数据类型，同时注意break否则会有穿透效果 结论： 当分支比较少时，if…else语句执行效率高。 当分支比较多时，switch语句执行效率高，而且结构更清晰。 for 语句 掌握 for 循环语句，让程序具备重复执行能力\nfor 是 JavaScript 提供的另一种循环控制的话句，它和 while 只是语法上存在差异。\nfor语句的基本使用 实现循环的 3 要素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; // 1. 语法格式 // for(起始值; 终止条件; 变化量) { // // 要重复执行的代码 // } // 2. 示例：在网页中输入标题标签 // 起始值为 1 // 变化量 i++ // 终止条件 i \u0026lt;= 6 for(let i = 1; i \u0026lt;= 6; i++) { document.write(`\u0026lt;h${i}\u0026gt;循环控制，即重复执行\u0026lt;h${i}\u0026gt;`) } \u0026lt;/script\u0026gt; 变化量和死循环，for 循环和 while 一样，如果不合理设置增量和终止条件，便会产生死循环。\n跳出和终止循环\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script\u0026gt; // 1. continue for (let i = 1; i \u0026lt;= 5; i++) { if (i === 3) { continue // 结束本次循环，继续下一次循环 } console.log(i) } // 2. break for (let i = 1; i \u0026lt;= 5; i++) { if (i === 3) { break // 退出结束整个循环 } console.log(i) } \u0026lt;/script\u0026gt; 结论：\nJavaScript 提供了多种语句来实现循环控制，但无论使用哪种语句都离不开循环的3个特征，即起始值、变化量、终止条件，做为初学者应着重体会这3个特征，不必过多纠结三种语句的区别。 起始值、变化量、终止条件，由开发者根据逻辑需要进行设计，规避死循环的发生。 当如果明确了循环的次数的时候推荐使用for循环,当不明确循环的次数的时候推荐使用while循环 注意：for 的语法结构更简洁，故 for 循环的使用频次会更多。\n练习 遍历数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let arr = [\u0026#39;小米\u0026#39;, \u0026#39;小哈\u0026#39;, \u0026#39;小游\u0026#39;, \u0026#39;小原\u0026#39;, \u0026#39;小铁\u0026#39;] for(let i = 0; i \u0026lt; arr.length; i++) { document.write(arr[i] + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n循环嵌套 利用循环的知识来对比一个简单的天文知识，我们知道地球在自转的同时也在围绕太阳公转，如果把自转和公转都看成是循环的话，就相当于是循环中又嵌套了另一个循环。\n实际上 JavaScript 中任何一种循环语句都支持循环的嵌套，如下代码所示：\n1 2 3 4 5 6 7 8 // 1. 外面的循环 记录第n天 for (let i = 1; i \u0026lt; 4; i++) { document.write(`第${i}天 \u0026lt;br\u0026gt;`) // 2. 里层的循环记录 几个单词 for (let j = 1; j \u0026lt; 6; j++) { document.write(`记住第${j}个单词\u0026lt;br\u0026gt;`) } } 记住，外层循环循环一次，里层循环循环全部\n例：每天背5个单词，一共背三天\n要求效果：\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; for (let i = 1; i \u0026lt;= 3; i++) { document.write(`第${i}天\u0026lt;br\u0026gt;`) for (let j = 1;j \u0026lt;= 5; j++) { document.write(`记住今天第${j}个单词\u0026lt;br\u0026gt;`) } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 倒三角 1 2 3 4 5 6 7 8 // 外层打印几行 for (let i = 1; i \u0026lt;= 5; i++) { // 里层打印几个星星 for (let j = 1; j \u0026lt;= i; j++) { document.write(\u0026#39;★\u0026#39;) } document.write(\u0026#39;\u0026lt;br\u0026gt;\u0026#39;) } 九九乘法表 样式css\n1 2 3 4 5 6 7 8 9 10 11 12 span { display: inline-block; width: 100px; padding: 5px 10px; border: 1px solid pink; margin: 2px; border-radius: 5px; box-shadow: 2px 2px 2px rgba(255, 192, 203, .4); background-color: rgba(255, 192, 203, .1); text-align: center; color: hotpink; } javascript\n1 2 3 4 5 6 7 8 9 10 11 // 外层打印几行 for (let i = 1; i \u0026lt;= 9; i++) { // 里层打印几个星星 for (let j = 1; j \u0026lt;= i; j++) { // 只需要吧 ★ 换成 1 x 1 = 1 document.write(` \u0026lt;span\u0026gt; ${j} x ${i} = ${j * i} \u0026lt;/span\u0026gt; `) } document.write(\u0026#39;\u0026lt;br\u0026gt;\u0026#39;) } 数组 知道什么是数组及其应用的场景，掌握数组声明及访问的语法。\n数组是什么？ 数组：(Array)是一种可以按顺序保存数据的数据类型\n**使用场景：**如果有多个数据可以用数组保存起来，然后放到一个变量中，管理非常方便\n数组的基本使用 定义数组和数组单元 1 2 3 4 5 6 7 8 \u0026lt;script\u0026gt; // 1. 语法，使用 [] 来定义一个空数组 // 定义一个空数组，然后赋值给变量 classes // let classes = []; // 2. 定义非空数组 let classes = [\u0026#39;小明\u0026#39;, \u0026#39;小刚\u0026#39;, \u0026#39;小红\u0026#39;, \u0026#39;小丽\u0026#39;, \u0026#39;小米\u0026#39;] \u0026lt;/script\u0026gt; 通过 [] 定义数组，数据中可以存放真正的数据，如小明、小刚、小红等这些都是数组中的数据，我们这些数据称为数组单元，数组单元之间使用英文逗号分隔。\n访问数组和数组索引 使用数组存放数据并不是最终目的，关键是能够随时的访问到数组中的数据（单元）。其实 JavaScript 为数组中的每一个数据单元都编了号，通过数据单元在数组中的编号便可以轻松访问到数组中的数据单元了。\n我们将数据单元在数组中的编号称为索引值，也有人称其为下标。\n索引值实际是按着数据单元在数组中的位置依次排列的，注意是从 0 开始的，如下图所示：\n观察上图可以数据单元【小明】对应的索引值为【0】，数据单元【小红】对应的索引值为【2】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; let classes = [\u0026#39;小明\u0026#39;, \u0026#39;小刚\u0026#39;, \u0026#39;小红\u0026#39;, \u0026#39;小丽\u0026#39;, \u0026#39;小米\u0026#39;] // 1. 访问数组，语法格式为：变量名[索引值] document.write(classes[0]) // 结果为：小明 document.write(classes[1]) // 结果为：小刚 document.write(classes[4]) // 结果为：小米 // 2. 通过索引值还可以为数组单重新赋值 document.write(classes[3]) // 结果为：小丽 // 重新为索引值为 3 的单元赋值 classes[3] = \u0026#39;小小丽\u0026#39; document.wirte(classes[3]); // 结果为： 小小丽 \u0026lt;/script\u0026gt; 数据单元值类型 数组做为数据的集合，它的单元值可以是任意数据类型\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; // 6. 数组单值类型可以是任意数据类型 // a) 数组单元值的类型为字符类型 let list = [\u0026#39;HTML\u0026#39;, \u0026#39;CSS\u0026#39;, \u0026#39;JavaScript\u0026#39;] // b) 数组单元值的类型为数值类型 let scores = [78, 84, 70, 62, 75] // c) 混合多种类型 let mixin = [true, 1, false, \u0026#39;hello\u0026#39;] \u0026lt;/script\u0026gt; 数组长度属性 重申一次，数组在 JavaScript 中并不是新的数据类型，它属于对象类型。\n1 2 3 4 5 6 \u0026lt;script\u0026gt; // 定义一个数组 let arr = [\u0026#39;html\u0026#39;, \u0026#39;css\u0026#39;, \u0026#39;javascript\u0026#39;] // 数组对应着一个 length 属性，它的含义是获取数组的长度 console.log(arr.length) // 3 \u0026lt;/script\u0026gt; 练习：求数组最大值与最小值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let arr = [12, 23, 6, 18, 77, 11, 56, 1] let max = arr[0] let min = arr[0] let i = 1 while (i \u0026lt; arr.length) { max = max \u0026gt; arr[i] ? max : arr[i] min = min \u0026lt; arr[i] ? min : arr[i] i++ } document.write(`最小值是${min}\u0026lt;br\u0026gt;最大值是${max}`) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n操作数组 数组做为对象数据类型，不但有 length 属性可以使用，还提供了许多方法：\npush 动态向数组的尾部添加一个单元 unshit 动态向数组头部添加一个单元 pop 删除最后一个单元 shift 删除第一个单元 splice 动态删除或增加任意单元 使用以上4个方法时，都是直接在原数组上进行操作，即成功调任何一个方法，原数组都跟着发生相应的改变。并且在添加或删除单元时 length 并不会发生错乱。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;script\u0026gt; // 定义一个数组 let arr = [\u0026#39;html\u0026#39;, \u0026#39;css\u0026#39;, \u0026#39;javascript\u0026#39;] // 1. push 动态向数组的尾部添加一个单元 arr.push(\u0026#39;Nodejs\u0026#39;) console.log(arr) arr.push(\u0026#39;Vue\u0026#39;) // 2. unshit 动态向数组头部添加一个单元 arr.unshift(\u0026#39;VS Code\u0026#39;) console.log(arr) // 3. splice 动态删除和增加任意单元 arr.splice(2, 1) // 从索引值为2的位置开始删除1个单元 console.log(arr) let arr = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;] arr.splice(1, 0, \u0026#39;pink\u0026#39;) // 在索引号是1的位置添加 pink console.log(arr) // [\u0026#39;red\u0026#39;, \u0026#39;pink\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;] arr.splice(1, 0, \u0026#39;pink\u0026#39;, \u0026#39;hotpink\u0026#39;) // 在索引号是1的位置添加 pink hotpink console.log(arr) // [\u0026#39;red\u0026#39;, \u0026#39;pink\u0026#39;, \u0026#39;hotpink\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;] // 4. pop 删除最后一个单元 arr.pop() console.log(arr) // 5. shift 删除第一个单元 arr.shift() console.log(arr) \u0026lt;/script\u0026gt; 注：直接输出上述方法的效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let arr = [\u0026#39;小米\u0026#39;, \u0026#39;小哈\u0026#39;, \u0026#39;小游\u0026#39;] document.write(arr.push(\u0026#39;小绝\u0026#39;))\t//4 document.write(arr)\t//小米,小哈,小游,小绝 document.write(arr.unshift(\u0026#39;小原\u0026#39;)) //5 document.write(arr)\t//小原,小米,小哈,小游,小绝 document.write(arr.shift())\t//小原 document.write(arr)\t//小米,小哈,小游,小绝 document.write(arr.pop())\t//小绝 document.write(arr)\t//小米,小哈,小游 document.write(arr.splice(1,2))\t//小哈,小游 document.write(arr)\t//小米 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 数组的筛选 需求：将数组 [2, 0, 6, 1, 77, 0, 52, 0, 25, 7] 中大于等于 10 的元素选出来，放入新数组\n分析：\n①：声明一个新的数组用于存放新数据newArr\n②：遍历原来的旧数组， 找出大于等于 10 的元素\n③：依次追加给新数组 newArr\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7] let newArr = [] // 遍历旧数组 for (let i = 0; i \u0026lt; arr.length; i++) { // 满足条件的存入新数组 if (arr[i] \u0026gt;= 10) { newArr.push(arr[i]) } } document.write(newArr) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 综合案例 需求：输入数据形成柱形图，如图\n![](/assets/GIF 2024-10-17 13-31-43.gif)\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;综合案例2\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .outer { width: 800px; border-bottom: 2px solid black; border-left: 2px solid black; margin: auto; margin-top: 80px; display: flex; justify-content: space-around; align-items: flex-end; } .inner { width: 100px; background-color: pink; display: flex; justify-content: space-between; flex-direction: column; text-align: center; } .inner .data { position: relative; font-size: 20px; top: -30px; } .inner .quarter { position: relative; font-size: 25px; font-weight: bold; bottom: -50px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 获取每个季度的数据 let arrData = [] for (let i = 1; i \u0026lt;= 4; i++) { arrData.push(prompt(`请输入第${i}季度的数据`)) } // 打印最外面的盒子的头 document.write(\u0026#39;\u0026lt;div class=\u0026#34;outer\u0026#34;\u0026gt;\u0026#39;) // 通过循环打印中间重复的内容 for (let i = 0; i \u0026lt; arrData.length; i++) { document.write(` \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;data\u0026#34; style=\u0026#34;height: ${arrData[i]}px;\u0026#34;\u0026gt;${arrData[i]}\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;quarter\u0026#34;\u0026gt;第${i+1}季度\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; `) } // 打印最外面盒子的尾 document.write(\u0026#39;\u0026lt;/div\u0026gt;\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JavaScript 基础 - 第4天笔记 理解封装的意义，能够通过函数的声明实现逻辑的封装，知道对象数据类型的特征，结合数学对象实现简单计算功能。\n理解函数的封装的特征 掌握函数声明的语法 理解什么是函数的返回值 知道并能使用常见的内置函数 函数 理解函数的封装特性，掌握函数的语法规则\n声明和调用 函数可以把具有相同或相似逻辑的代码“包裹”起来，通过函数调用执行这些被“包裹”的代码逻辑，这么做的优势是有利于精简代码方便复用。\n声明（定义） 声明（定义）一个完整函数包括关键字、函数名、形式参数、函数体、返回值5个部分\n调用 声明（定义）的函数必须调用才会真正被执行，使用 () 调用函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 声明和调用\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 声明（定义）了最简单的函数，既没有形式参数，也没有返回值 function sayHi() { console.log(\u0026#39;嗨~\u0026#39;) } // 函数调用，这些函数体内的代码逻辑会被执行 // 函数名() sayHi() // 可以重复被调用，多少次都可以 sayHi() \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注：函数名的命名规则与变量是一致的，并且尽量保证函数名的语义。\n小案例： 小星星\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;script\u0026gt; // 函数声明 function sayHi() { // document.write(\u0026#39;hai~\u0026#39;) document.write(`*\u0026lt;br\u0026gt;`) document.write(`**\u0026lt;br\u0026gt;`) document.write(`***\u0026lt;br\u0026gt;`) document.write(`****\u0026lt;br\u0026gt;`) document.write(`*****\u0026lt;br\u0026gt;`) document.write(`******\u0026lt;br\u0026gt;`) document.write(`*******\u0026lt;br\u0026gt;`) document.write(`********\u0026lt;br\u0026gt;`) document.write(`*********\u0026lt;br\u0026gt;`) } // 函数调用 sayHi() sayHi() sayHi() sayHi() sayHi() \u0026lt;/script\u0026gt; 参数 通过向函数传递参数，可以让函数更加灵活多变，参数可以理解成是一个变量。\n声明（定义）一个功能为打招呼的函数\n传入数据列表 声明这个函数需要传入几个数据 多个数据用逗号隔开 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 函数参数\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 声明（定义）一个功能为打招呼的函数 // function sayHi() { // console.log(\u0026#39;嗨~\u0026#39;) // } // 调用函数 // sayHi() // 这个函数似乎没有什么价值，除非能够向不同的人打招呼 // 这就需要借助参数来实现了 function sayHi(name) { // 参数 name 可以被理解成是一个变量 console.log(name) console.log(\u0026#39;嗨~\u0026#39; + name) } // 调用 sayHi 函数，括号中多了 \u0026#39;小明\u0026#39; // 这时相当于为参数 name 赋值了 sayHi(\u0026#39;小明\u0026#39;)// 结果为 小明 // 再次调用 sayHi 函数，括号中多了 \u0026#39;小红\u0026#39; // 这时相当于为参数 name 赋值了 sayHi(\u0026#39;小红\u0026#39;) // 结果为 小红 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 总结：\n声明（定义）函数时的形参没有数量限制，当有多个形参时使用 , 分隔 调用函数传递的实参要与形参的顺序一致 形参和实参 形参：声明函数时写在函数名右边小括号里的叫形参（形式上的参数）\n实参：调用函数时写在函数名右边小括号里的叫实参（实际上的参数）\n形参可以理解为是在这个函数内声明的变量（比如 num1 = 10）实参可以理解为是给这个变量赋值\n开发中尽量保持形参和实参个数一致\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 函数参数\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 声明（定义）一个计算任意两数字和的函数 // 形参 x 和 y 分别表示任意两个数字，它们是两个变量 function count(x, y) { console.log(x + y); } // 调用函数，传入两个具体的数字做为实参 // 此时 10 赋值给了形参 x // 此时 5 赋值给了形参 y count(10, 5); // 结果为 15 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 默认参数 如果形参没有默认值，用户又没输入实参，可能会导致实际结果与预期不同，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; function getSum(a, b) { document.write(a + b) } getSum() //NaN \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 从生活上来说，两个空的数相加应该是0，但因为没有给入实参，a和b都undefined型，所以两者相加等于NaN\n为了防止用户不输入实参，可以给 形参默认值，这样程序更严谨，形参有默认值时，并不影响实参的传入，如下\n例1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; function getSum(a = 0, b = 0) { document.write(a + b) } getSum() //0 getSum(2, 6) //8 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; function getArrSum(arr = []) { let sum = 0 for (let i = 0; i \u0026lt; arr.length; i++) { sum += arr[i] } console.log(sum) } getArrSum([1,2,3])//6 getArrSum() //0(不设默认值会报错) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 说明：这个默认值只会在缺少实参参数传递时 才会被执行，所以有参数会优先执行传递过来的实参, 否则默认为undefined\n返回值 函数的本质是封装（包裹），函数体内的逻辑执行完毕后，函数外部如何获得函数内部的执行结果呢？要想获得函数内部逻辑的执行结果，需要通过 return 这个关键字，将内部执行结果传递到函数外部，这个被传递到外部的结果就是返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 函数返回值\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 定义求和函数 function count(a, b) { let s = a + b // s 即为 a + b 的结果 // 通过 return 将 s 传递到外部 return s } // 调用函数，如果一个函数有返回值 // 那么可将这个返回值赋值给外部的任意变量 let total = count(5, 12) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 总结：\n在函数体中使用return 关键字能将内部的执行结果交给函数外部使用 函数内部只能出现1 次 return，并且 return 下一行代码不会再被执行，所以return 后面的数据不要换行写 return会立即结束当前函数 函数可以没有return，这种情况默认返回值为 undefined 返回多个值 当需要return多个值时，可以使用数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 写一个求最大值和最小值的函数 function getMaxAndMin(arr = []) { let max = arr[0] let min = arr[0] for (let i = 1; i \u0026lt; arr.length; i++) { max = max \u0026gt; arr[i] ? max : arr[i] min = min \u0026lt; arr[i] ? min : arr[i] } return [max, min] } let arrMaxAndMin = getMaxAndMin([1, 3, 5, 7, 9, 0]) document.write(arrMaxAndMin)//9,0 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 断点进入函数 在浏览器断点调试时，按F10可以下一步，而按F11也是下一步，但F10不会进入函数，F11可以进入函数，更细致地调试\n![](/assets/GIF 2024-10-17 21-40-00.gif)\n函数细节补充 在Javascript中 实参的个数和形参的个数可以不一致\n如果形参过多 会自动填上undefined 如果实参过多 那么多余的实参会被忽略 (函数内部有一个arguments,里面装着所有的实参) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; function getSum(a, b) { return a + b } // 实参多于形参 document.write(getSum(1, 2, 100))//3 // 实参少于形参 document.write(getSum(1))\t//NaN \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 作用域 通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。\n作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。\n全局作用域 作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件\n处于全局作用域内的变量，称为全局变量\n局部作用域 作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。\n处于局部作用域内的变量称为局部变量\n如果函数内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐\n但是有一种情况，函数内部的形参可以看做是局部变量。\n变量的访问原则 就近原则：在能够访问到的情况下，先局部，局部没有再找全局\n例1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let temp = 10 function getNum() { let sum = 20 console.log(sum) } getNum()//20 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; function f1() { let num = 123 function f2() { console.log(num) } f2() } let num = 456 f1() //123 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 例3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; function f1() { let num = 123 function f2() { let num = 0 console.log(num) } f2() } let num = 456 f1() //0 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 例4：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let a = 1 function fn1() { let a = 2 let b = \u0026#39;22\u0026#39; fn2() function fn2() { let a = 3 fn3() function fn3() { let a = 4 console.log(a) //4 console.log(b) //22 } } } fn1() \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 匿名函数 函数可以分为具名函数和匿名函数\n匿名函数：没有名字的函数,无法直接使用。\n函数表达式 1 2 3 4 5 6 // 声明 let fn = function() { console.log(\u0026#39;函数表达式\u0026#39;) } // 调用 fn() 函数表达式和具名函数的区别：\n具名函数的调用可以写到任意位置，就算是把调用写在声明之前也能正常运行，但函数表达式如果把调用写在声明之前就会报错\n立即执行函数 1 2 (function(){ xxx })();\t//写法一 (function(){xxxx}());\t//写法二 无需调用，立即执行，其实本质已经调用了\n多个立即执行函数之间用分号隔开\n例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; //写法一 (function(x, y) { console.log(x + y) })(1, 2);\t//3 //写法二 (function(x, y) { console.log(x + y) }(1, 2))\t//3 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 逻辑中断 逻辑运算符里的短路 短路：只存在于 \u0026amp;\u0026amp; 和 || 中，当满足一定条件会让右边代码不执行\n原因：通过左边能得到整个式子的结果，因此没必要再判断右边\n运算结果：无论 \u0026amp;\u0026amp; 还是 || ，运算结果都是最后被执行的表达式值，一般用在变量赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let age = 18 console.log(false \u0026amp;\u0026amp; age++)//false console.log(0 \u0026amp;\u0026amp; age++) //0 console.log(age) //18 console.log(true || age++) //true console.log(1 || age++) //1 console.log(age) //18 console.log(11 \u0026amp;\u0026amp; 22) //22(逻辑与，都是真则返回最后一个真值) console.log(11 || 22) //11(逻辑或，都是真则返回第一个真值，一真则真) console.log(undefined \u0026amp;\u0026amp; 0)//undefined(逻辑与，遇到一个假直接返回，一假则假) console.log(undefined || 0)//0(逻辑或，都是假则返回最后一个) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 小练习：\n转换为布尔型 记忆： ‘’ 、0、undefined、null、false、NaN 转换为布尔值后都是false, 其余则为 true\n隐式转换：\n有字符串的加法 “” + 1 ，结果是 “1” 减法 - （像大多数数学运算一样）只能用于数字，它会使空字符串 \u0026quot;\u0026quot; 转换为 0 null 经过数字转换之后会变为 0 undefined 经过数字转换之后会变为 NaN 综合案例 需求：用户输入秒数，可以自动转换为几时几分几秒\n分析：\n①： 用户输入总秒数 （注意默认值）\n②：计算时分秒（封装函数） 里面包含数字补0\n③：打印输出\n计算公式：计算时分秒\n小时： h = parseInt(总秒数 / 60 / 60 % 24)\n分钟： m = parseInt(总秒数 / 60 % 60 )\n秒数: s = parseInt(总秒数 % 60)\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;综合3\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let second = +prompt(\u0026#39;请输入秒数：\u0026#39;) function getTime(t) { let h = parseInt(t / 60 / 60 % 24) let m = parseInt(t / 60 % 60 ) let s = parseInt(t % 60) h = h \u0026lt; 10 ? \u0026#39;0\u0026#39; + h : h m = m \u0026lt; 10 ? \u0026#39;0\u0026#39; + m : m s = s \u0026lt; 10 ? \u0026#39;0\u0026#39; + s : s document.write(`${second}秒是${h}时${m}分${s}秒`) } getTime(second) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n![](/assets/GIF 2024-10-17 23-30-16.gif)\nJavaScript 基础 - 第5天 知道对象数据类型的特征，能够利用数组对象渲染页面\n理解什么是对象，掌握定义对象的语法 掌握数学对象的使用 对象 对象是 JavaScript 数据类型的一种，之前已经学习了数值类型、字符串类型、布尔类型、undefined。对象数据类型可以被理解成是一种数据集合。它由属性和方法两部分构成。\n语法 声明一个对象类型的变量与之前声明一个数值或字符串类型的变量没有本质上的区别。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 对象语法\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 声明字符串类型变量 let str = \u0026#39;hello world!\u0026#39; // 声明数值类型变量 let num = 199 // 声明对象类型变量，使用一对花括号 // user 便是一个对象了，目前它是一个空对象 let user = {} \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 属性和访问 数据描述性的信息称为属性，如人的姓名、身高、年龄、性别等，一般是名词性的。\n属性都是成 对出现的，包括属性名和值，它们之间使用英文 : 分隔 多个属性之间使用英文 , 分隔 属性就是依附在对象上的变量 属性名可以使用 \u0026quot;\u0026quot; 或 ''，一般情况下省略，除非名称遇到特殊符号如空格、中横线等 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 对象语法\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 通过对象描述一个人的数据信息 // person 是一个对象，它包含了一个属性 name // 属性都是成对出现的，属性名 和 值，它们之间使用英文 : 分隔 let person = { name: \u0026#39;小明\u0026#39;, // 描述人的姓名 age: 18, // 描述人的年龄 stature: 185, // 描述人的身高 gender: \u0026#39;男\u0026#39;, // 描述人的性别 } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 声明对象，并添加了若干属性后，可以使用 . 或 [] 获得对象中属性对应的值，我称之为属性访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 对象语法\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 通过对象描述一个人的数据信息 // person 是一个对象，它包含了一个属性 name // 属性都是成对出现的，属性名 和 值，它们之间使用英文 : 分隔 let person = { name: \u0026#39;小明\u0026#39;, // 描述人的姓名 age: 18, // 描述人的年龄 stature: 185, // 描述人的身高 gender: \u0026#39;男\u0026#39;, // 描述人的性别 }; // 访问人的名字 console.log(person.name) // 结果为 小明 // 访问人性别 console.log(person.gender) // 结果为 男 // 访问人的身高 console.log(person[\u0026#39;stature\u0026#39;]) // 结果为 185 // 或者 console.log(person.stature) // 结果同为 185 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 扩展：也可以动态为对象添加属性，动态添加与直接定义是一样的，只是语法上更灵活。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 对象语法\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 声明一个空的对象（没有任何属性） let user = {} // 动态追加属性 user.name = \u0026#39;小明\u0026#39; user[\u0026#39;age\u0026#39;] = 18 // 动态添加与直接定义是一样的，只是语法上更灵活 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 删除属性用delete\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let obj = { name: \u0026#39;张三\u0026#39;, } document.write(obj.name)//张三 delete obj.name document.write(obj.name)//undefined \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 声明复杂属性名，即要使用特殊符号时就需要用 \u0026quot; \u0026quot;或 ''包裹起来\n两种查的方式：\n对象名.属性名 对象名[\u0026lsquo;属性名\u0026rsquo;] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let obj = { // my-name: \u0026#39;张三\u0026#39; //不能直接用-，不然会报错 \u0026#39;my-name\u0026#39;: \u0026#39;张三\u0026#39; } //document.write(obj.my-name)//此时就不能用这种方式访问 document.write(obj[\u0026#39;my-name\u0026#39;])//输出 张三 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 方法和调用 数据行为性的信息称为方法，如跑步、唱歌等，一般是动词性的，其本质是函数。\n方法是由方法名和函数两部分构成，它们之间使用 : 分隔 多个属性之间使用英文 , 分隔 方法是依附在对象中的函数 方法名可以使用 \u0026quot;\u0026quot; 或 ''，一般情况下省略，除非名称遇到特殊符号如空格、中横线等 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 对象方法\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 方法是依附在对象上的函数 let person = { name: \u0026#39;小红\u0026#39;, age: 18, // 方法是由方法名和函数两部分构成，它们之间使用 : 分隔 singing: function () { console.log(\u0026#39;两只老虎，两只老虎，跑的快，跑的快...\u0026#39;) }, run: function () { console.log(\u0026#39;我跑的非常快...\u0026#39;) } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 声明对象，并添加了若干方法后，可以使用 . 或 [] 调用对象中函数，我称之为方法调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 对象方法\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 方法是依附在对象上的函数 let person = { name: \u0026#39;小红\u0026#39;, age: 18, // 方法是由方法名和函数两部分构成，它们之间使用 : 分隔 singing: function () { console.log(\u0026#39;两只老虎，两只老虎，跑的快，跑的快...\u0026#39;) }, run: function () { console.log(\u0026#39;我跑的非常快...\u0026#39;) } } // 调用对象中 singing 方法 person.singing() // 调用对象中的 run 方法 person.run() \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 扩展：也可以动态为对象添加方法，动态添加与直接定义是一样的，只是语法上更灵活。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript 基础 - 对象方法\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 声明一个空的对象（没有任何属性，也没有任何方法） let user = {} // 动态追加属性 user.name = \u0026#39;小明\u0026#39; user.[\u0026#39;age\u0026#39;] = 18 // 动态添加方法 user.move = function () { console.log(\u0026#39;移动一点距离...\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注：无论是属性或是方法，同一个对象中出现名称一样的，后面的会覆盖前面的。\nnull null 也是 JavaScript 中数据类型的一种，通常只用它来表示不存在的对象。使用 typeof 检测类型它的类型时，结果为 object。\n遍历对象 1 2 3 4 5 6 7 8 let obj = { uname: \u0026#39;pink\u0026#39; } for(let k in obj) { // k是属性名，并且是带引号的字符串类型 //所以如果使用obj.k 就相当于写 obj.\u0026#39;uname\u0026#39; ，会调用失败 //所以要用另一种调用方法：obj[k] } for in 不提倡遍历数组 因为 k 是 字符串\n例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let obj = { name: \u0026#39;张三\u0026#39;, age: 18, gender: \u0026#39;男\u0026#39; } for (let k in obj) { console.log(obj[k]) } console.log(\u0026#39;-------\u0026#39;); for (let k in obj) { console.log(obj.k) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n遍历数组对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let students = [ { name: \u0026#39;小明\u0026#39;, age: 18, gender: \u0026#39;男\u0026#39;, hometown: \u0026#39;河北省\u0026#39; }, { name: \u0026#39;小红\u0026#39;, age: 19, gender: \u0026#39;女\u0026#39;, hometown: \u0026#39;河南省\u0026#39; }, { name: \u0026#39;小刚\u0026#39;, age: 17, gender: \u0026#39;男\u0026#39;, hometown: \u0026#39;山西省\u0026#39; }, { name: \u0026#39;小丽\u0026#39;, age: 18, gender: \u0026#39;女\u0026#39;, hometown: \u0026#39;山东省\u0026#39; } ] for (let i = 0; i \u0026lt; students.length; i++) { console.log(students[i]) console.log(students[i].name) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 学生信息表案例练习 将学生信息数据渲染到页面中\n效果图：\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; table { width: 600px; text-align: center; } table, th, td { border: 1px solid #ccc; border-collapse: collapse; } caption { font-size: 18px; margin-bottom: 10px; font-weight: 700; } tr { height: 40px; cursor: pointer; } table tr:nth-child(1) { background-color: #ddd; } table tr:not(:first-child):hover { background-color: #eee; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;caption\u0026gt;学生列表\u0026lt;/caption\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;序号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;家乡\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;script\u0026gt; let students = [ { name: \u0026#39;小明\u0026#39;, age: 18, gender: \u0026#39;男\u0026#39;, hometown: \u0026#39;河北省\u0026#39; }, { name: \u0026#39;小红\u0026#39;, age: 19, gender: \u0026#39;女\u0026#39;, hometown: \u0026#39;河南省\u0026#39; }, { name: \u0026#39;小刚\u0026#39;, age: 17, gender: \u0026#39;男\u0026#39;, hometown: \u0026#39;山西省\u0026#39; }, { name: \u0026#39;小丽\u0026#39;, age: 18, gender: \u0026#39;女\u0026#39;, hometown: \u0026#39;山东省\u0026#39; } ] for (let i = 0; i \u0026lt; students.length; i++) { document.write(` \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;${i + 1}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${students[i].name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${students[i].age}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${students[i].gender}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${students[i].hometown}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; `) } \u0026lt;/script\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 内置对象 回想一下我们曾经使用过的 console.log，console其实就是 JavaScript 中内置的对象，该对象中存在一个方法叫 log，然后调用 log 这个方法，即 console.log()。\n除了 console 对象外，JavaScritp 还有其它的内置的对象\nMath Math 是 JavaScript 中内置的对象，称为数学对象，这个对象下即包含了属性，也包含了许多的方法。\n属性 Math.PI，获取圆周率 1 2 // 圆周率 console.log(Math.PI); 方法 Math.random，生成 0 到 1 间的随机数 1 2 // 0 ~ 1 之间的随机数, 包含 0 不包含 1 Math.random() Math.ceil，数字向上取整 1 2 // 舍弃小数部分，整数部分加1 Math.ceil(3.4) Math.floor，数字向下取整 1 2 // 舍弃小数部分，整数部分不变 Math.floor(4.68) Math.round，四舍五入取整 1 2 3 4 5 // 取整，四舍五入原则 Math.round(5.46539) Math.round(4.849) Math.round(-1.5)//-1 Math.round(-1.51)//-2 Math.max，在一组数中找出最大的 1 2 // 找出最大值 Math.max(10, 21, 7, 24, 13) Math.min，在一组数中找出最小的 1 2 // 找出最小值 Math.min(24, 18, 6, 19, 21) Math.pow，幂方法 1 2 3 // 求某个数的多少次方 Math.pow(4, 2) // 求 4 的 2 次方 Math.pow(2, 3) // 求 2 的 3 次方 Math.sqrt，平方根 1 2 // 求某数的平方根 Math.sqrt(16) Math.abs，绝对值 1 2 // 求某数的绝对值 Math.abs(-12.3) 数学对象提供了比较多的方法，这里不要求强记，通过演示数学对象的使用，加深对对象的理解。\n详情见：Math - JavaScript | MDN (mozilla.org)\n随机数函数练习 Math.random() 随机数函数， 返回一个0 - 1之间，并且包括0不包括1的随机小数 [0, 1）\n如何生成0-10的随机整数？（包括0和10） 1 2 // 取0-11的随机数后向下取整 Math.floor(Math.random() * 11) 如何生成5-10的随机整数？（包括5和10） 1 Math.floor(Math.random() * 6) + 5 如何生成N~M之间的随机整数？（包括N和M） 1 Math.floor(Math.random() * (M - N + 1)) + N 从数组中随机选一个 1 2 3 let arr = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;] let random = Math.floor(Math.random() * arr.length) console.log(arr[random]) 猜数字游戏 需求：程序随机生成 1~10 之间的一个数字，用户输入一个数字\n①：如果大于该数字，就提示，数字猜大了，继续猜\n②：如果小于该数字，就提示，数字猜小了，继续猜\n③：如果猜对了，就提示猜对了，程序结束\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let random = Math.floor((Math.random() * 10) + 1) while (true) { let temp = +prompt(\u0026#39;请输入一个1-10之间的数\u0026#39;) if (temp \u0026gt; random) { alert(\u0026#39;猜大了\u0026#39;) }else if (temp \u0026lt; random){ alert(\u0026#39;猜小了\u0026#39;) }else { alert(\u0026#39;猜对了\u0026#39;) break } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 当猜的次数有限时，可以写一个开关变量来辅助\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let random = Math.floor((Math.random() * 10) + 1) let flag = true //生成一个开关变量 for (let i = 1; i \u0026lt;= 3; i++) { let temp = +prompt(\u0026#39;请输入一个1-10之间的数\u0026#39;) if (temp \u0026gt; random) { alert(\u0026#39;猜大了\u0026#39;) }else if (temp \u0026lt; random){ alert(\u0026#39;猜小了\u0026#39;) }else { flag = false //猜对后改成false alert(\u0026#39;猜对了\u0026#39;) break } } // 3次都没猜对，flag就还是true if (flag) { alert(\u0026#39;次数已用完\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 生成随机颜色 需求：该函数接收一个布尔类型参数，表示颜色的格式是十六进制还是rgb格式。\n①：如果参数传递的是true或者无参数，则输出 一个随机十六进制的颜色\n②：如果参数传递的是false，则输出 一个随机rgb的颜色\n③：格式：\nfunction getRandomColor(flag){ }\nconsole.log(getRandomColor(true)) //#ffffff\nconsole.log(getRandomColor(false)) //rgb(255,255,255)\n分析：\n提示： 16进制颜色格式为: ‘#ffffff’ 其中f可以是任意 0-f之间的字符,需要用到数组，\nlet arr = [\u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;, \u0026lsquo;4\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;6\u0026rsquo;, \u0026lsquo;7\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;9\u0026rsquo;, \u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026rsquo;d\u0026rsquo;, \u0026rsquo;e\u0026rsquo;, \u0026lsquo;f\u0026rsquo;]\n提示: rgb颜色格式为: ‘rgb(255,255,255) ’ 其中255可以是任意0-255之间的数字\n步骤：\n①：如果参数为true或者无参数，则处理16进制颜色，核心思想是循环6次，生成随机的6个数字（取\n值范围0~15），根据这个数字去找数组的值，然后和 # 拼接起来，并且返回值。\n②：如果参数为false，随机生成一个0~255的数给三个变量，分别作为 r g b 三个颜色，之后拼接字\n符串rgb(255,255,255)格式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 写一个生成N~M之间随机整数的函数，方便后续使用 function getRandomInt(N, M) { return Math.floor(Math.random() * (M - N + 1)) + N } // 自定义一个随机颜色函数 function getRandomColor(flag = true) { // 如果传入true或无实参传入，则返回格式为十六进制的颜色 if(flag) { let temp = \u0026#39;#\u0026#39; let arr = [\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;] for (let i = 1; i \u0026lt;= 6; i++) { // 每次从数组中抽一个出来 let random = getRandomInt(0, arr.length - 1) // 把抽出来的接到temp中 temp += arr[random] } return `${temp}` } // 如果传入false，则返回格式为rgb的颜色 else { let r = getRandomInt(0, 255) let g = getRandomInt(0, 255) let b = getRandomInt(0, 255) return `rgb(${r}, ${g}, ${b})` } } // 调用函数getRandomColor() console.log(getRandomColor(true)) console.log(getRandomColor(false)) console.log(getRandomColor()) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 拓展 基本数据类型和引用数据类型 简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。\n值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型 string ，number，boolean，undefined，null\n引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型 通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等\n堆栈空间分配区别： 1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的\n栈；\n简单数据类型存放到栈里面\n2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。\n引用数据类型存放到堆里面\n简单类型的内存分配 值类型（简单数据类型）： string ，number，boolean，undefined，null\n值类型变量的数据直接存放在变量（栈空间）中\n复杂类型的内存分配 引用类型（复杂数据类型）：通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等\n引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中\n小练习 1 2 3 4 5 6 7 8 9 10 11 12 let num1 = 10 let num2 = num1 num2 = 20 console.log(num1)//(1) let obj1 = { age: 18 } let obj2 = obj1 obj2.age = 20 console.log(obj1.age)//(2) 答案：\n(1) 10 ; (2) 20\n（1）此时num为简单数据类型，直接存入栈中，把num1赋值给num2后，num2获得了一块新的栈空间，与num1的栈空间相互独立，互不影响\n（2）此时obj为复杂数据类型，栈空间里存放的是地址，真正的对象实例存放在堆空间中，当把obj1赋值给obj2后，obj2获得了一块存放着地址的栈空间，虽然obj1和obj2的栈空间互不影响，但存放的地址是相同的，无论通过obj1还是obj2的地址，找到的对象实例都是同一个，所以对obj2的对象实例进行修改会影响到obj1\n视频讲解：https://www.bilibili.com/video/BV1Y84y1L7Nn?t=817.3\u0026p=77\n综合案例 需求：根据数据渲染列表页面\n效果图：\n![](/assets/GIF 2024-10-19 22-02-18.gif)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;学车在线首页\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } .w { width: 1200px; margin: auto; } body { background-color: #f3f5f7; } li { list-style: none; } a { text-decoration: none; } .clearfix:before,.clearfix:after { content:\u0026#34;\u0026#34;; display:table; } .clearfix:after { clear:both; } .clearfix { zoom:1; } .box { margin-top: 30px; } .box-hd { height: 45px; } .box-hd h3 { float: left; font-size: 20px; color: #494949; } .box-hd a { float: right; font-size: 12px; color: #a5a5a5; margin-top: 10px; margin-right: 30px; } /* 把li 的父亲ul 修改的足够宽一行能装开5个盒子就不会换行了 */ .box-bd ul { width: 1225px; } .box-bd ul li { position: relative; top: 0; float: left; width: 228px; height: 270px; background-color: #fff; margin-right: 15px; margin-bottom: 15px; transition: all .3s; } .box-bd ul li a { display: block; } .box-bd ul li:hover { top: -8px; box-shadow: 0 15px 30px rgb(0 0 0 / 10%); } .box-bd ul li img { width: 100%; } .box-bd ul li h4 { margin: 20px 20px 20px 25px; font-size: 14px; color: #050505; font-weight: 400; } .box-bd .info { margin: 0 20px 0 25px; font-size: 12px; color: #999; } .box-bd .info span { color: #ff7c2d; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 4. box核心内容区域开始 --\u0026gt; \u0026lt;div class=\u0026#34;box w\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box-hd\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;精品推荐\u0026lt;/h3\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;查看全部\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box-bd\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;clearfix\u0026#34;\u0026gt; \u0026lt;script\u0026gt; let data = [ { src: \u0026#39;images/course01.png\u0026#39;, title: \u0026#39;Think PHP 5.0 博客系统实战项目演练\u0026#39;, num: 1125 }, { src: \u0026#39;images/course02.png\u0026#39;, title: \u0026#39;Android 网络动态图片加载实战\u0026#39;, num: 357 }, { src: \u0026#39;images/course03.png\u0026#39;, title: \u0026#39;Angular2 大前端商城实战项目演练\u0026#39;, num: 22250 }, { src: \u0026#39;images/course04.png\u0026#39;, title: \u0026#39;Android APP 实战项目演练\u0026#39;, num: 389 }, { src: \u0026#39;images/course05.png\u0026#39;, title: \u0026#39;UGUI 源码深度分析案例\u0026#39;, num: 124 }, { src: \u0026#39;images/course06.png\u0026#39;, title: \u0026#39;Kami2首页界面切换效果实战演练\u0026#39;, num: 432 }, { src: \u0026#39;images/course07.png\u0026#39;, title: \u0026#39;UNITY 从入门到精通实战案例\u0026#39;, num: 888 }, { src: \u0026#39;images/course08.png\u0026#39;, title: \u0026#39;Cocos 深度学习你不会错过的实战\u0026#39;, num: 590 }, ] for (let i = 0; i \u0026lt; data.length; i++){ document.write(` \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;${data[i].src}\u0026#34; title=\u0026#34;${data[i].title}\u0026#34;\u0026gt; \u0026lt;h4\u0026gt; ${data[i].title} \u0026lt;/h4\u0026gt; \u0026lt;div class=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;span\u0026gt;高级\u0026lt;/span\u0026gt; • \u0026lt;span\u0026gt;${data[i].num}\u0026lt;/span\u0026gt;人在学习 \u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; `) } \u0026lt;/script\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2024-03-27T15:06:23+08:00","permalink":"https://IAmYuanyu.github.io/p/javascript%E5%9F%BA%E7%A1%80/","title":"JavaScript基础"},{"content":"系统网络配置 手动设置网络地址 Xshell远程连接 安装ssh Ubantu默认没有ssh服务，需要手动下载\n分别在终端输入sudo apt update和sudo apt install -y ssh下载完成后即可连接Xshell\n系统管理操作 关闭防火墙 systemctl 基本语法：systemctl start | stop | restart | status 服务名\n其中，服务名不用一个个记，查看/usr/lib/systemd/system 目录下的文件列表，该目录下每个文件都\n对应一个服务\nsystemctl案例实操 查看网络服务的状态 在终端输入sudo systemctl status NetworkManager后可查看网络管理服务\n此时按q可退出此状态，继续输入指令\n其他操作类似\n停止网络服务 sudo systemctl stop NetworkManager\n启动网络服务 sudo systemctl start NetworkManager\n重启网络服务 sudo systemctl restart NetworkManager\nsystemctl 设置后台服务的自启配置 查看服务开机启动状态 ：systemctl list-unit-files\n关掉指定服务的自动启动：systemctl disable 服务名\n开启指定服务的自动启动：systemctl enable 服务名\n关闭防火墙 临时关闭防火墙 查看防火墙状态：sudo systemctl status ufw\n临时关闭防火墙：sudo systemctl stop ufw\n长期关闭防火墙 设置开机时启动防火墙：sudo systemctl enable ufw\n设置开机时关闭防火墙：sudo systemctl disable ufw\n查看服务是否开机自启：sudo systemctl is-enabled ufw\n关机重启命令 关闭系统，当前版本 Ubuntu 不会断电：halt\n关闭系统并断电，等同于 shutdown -h now：poweroff\n重启，等同于 shutdown -r now：reboot\nshutdown [选项] 时间\n① shutdown 参数说明\n选项 功能 -h -h=halt 关机，不完全等同于 halt 命令 -r -r=reboot 重启 ② now 参数说明\n选项 功能 now 立刻关机 时间 等待多久后关机（时间单位是分钟） 修改主机名 在终端执行：sudo hostnamectl --static set-hostname 新名字\n执行完上述命令，重启后生效\n通过主机名连接Xshell 找到电脑位于C:\\Windows\\System32\\drivers\\etc目录下的hosts文件，在最下方输入地址和主机名\n修改完hosts文件后就可以在Xshell的连接中将主机中原本填写的地址改为自己的主机名\nAPT软件包 在终端输入apt即可查看apt常用命令\n例如，当前需要根据名称列出软件包，就可以在终端输入sudo apt list\n其中sudo表示以管理员身份执行命令\n常用基本命令 帮助命令 Manual Packages 查看手册页说明文档：在终端输入man man\nman 获得帮助信息 查看ls命令的帮助信息：man ls help 获取shell内建命令的帮助信息 shell 内建命令：shell 内建命令是 shell 的一部分，他们没有单独的可执行文件或手册页，这类命令的文档通过 help 命令访问。\n基本语法：help 命令 （功能描述：获得 shell 内建命令的帮助信息）\n例如：查看cd命令的帮助信息help cd\n常用快捷键 常用快捷键 功能 ctrl + c 停止进程 ctrl + l (这是L) 清屏；彻底清屏是：reset ctrl + q 退出 tab 键 提示 (更重要的是可以防止敲错) 上下键 查找执行过的命令 ctrl + u 清除当前敲的命令 文件目录类 pwd 显示当前工作目录的绝对路径 pwd即print working directory 打印工作目录\n显示当前工作目录的绝对路径：pwd\nls 列出目录内容 ls即list 列出目录内容\n在终端输入ls列出目录的内容（LS）\n选项 功能 -a 全部的文件，连同隐藏档 (开头为。的文件) 一起列出来 (常用) -l 长数据串列出，包含文件的属性与权限等等数据；(常用) 显示说明：\n每行列出的信息依次是：文件类型与权限 链接数 文件属主 文件属组 文件大小(用byte来表示) 建立或最近修改的时间 名字\n其中ls -l可以简写为ll\ncd 切换目录 cd即Change Directory 切换路径\n参数 功能 cd 绝对路径 切换路径 cd 相对路径 切换路径 cd ~ 或者 cd 回到自己的家目录 cd - 回到上一次所在目录 cd .. 回到当前目录的上一级目录 cd -P 跳转到实际物理路径，而非快捷方式路径 例如：\nmkdir 创建一个新目录 mkdir即Make directory 建立目录\n选项 功能 -p 创建多层目录 touch 创建一个文件 cp 复制文件或目录 基本语法：cp 源文件 目标文件 功能描述：复制源文件文件到目标文件\n选项 功能 -r 递归复制整个文件夹 强制覆盖不提示的方法：\\cp\nrm 删除文件或目录 选项 功能 -r 递归删除目录中所有内容 -f 强制执行删除操作，而不提示用于进行确认 -v 显示指令的详细执行过程 mv 移动文件与目录或重命名 基本语法：\n① mv oldNameFile newNameFile （功能描述：重命名）\n② mv /temp/movefile /targetFolder （功能描述：移动文件）\n注：不能用mv将文件移动到回收站，这和用rm删除没区别，文件会直接丢失，除非自己手动创建一个文件夹作为回收站\n4种方式查看文件内容 cat 查看文件内容 作用：查看文件内容，从第一行开始显示\n一般用于查看比较小的文件，一屏幕能显示全的\n选项 功能描述 -n 显示所有行的行号，包括空行 示例：\n查看文件内容并显示行号：cat -n houge.txt\nmore 文件内容分屏查看器 more 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容\nmore 指令中内置了若干快捷键，详见操作说明\n操作 功能说明 空格键 (space) 代表向下翻一页 Enter 代表向下翻「一行」 q 代表立刻离开 more ，不再显示该文件内容 Ctrl+F 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 :f 输出文件名和当前行的行号 less 分屏显示文件内容 less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率\n操作 功能说明 空白键 向下翻动一页 [pagedown] 向下翻动一行 [pageup] 向上翻动一行 / 字串 向下搜寻「字串」的功能；n：向下查找；N：向上查找 ? 字串 向上搜寻「字串」的功能；n：向上查找；N：向下查找 q 离开less程序 tail 输出文件尾部内容 tail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容\n基本语法：\n选项 功能 -n \u0026lt;行数\u0026gt; 输出文件尾部 n 行内容 -f 显示文件最新追加的内容，监视文件变化 echo 输出内容到控制台 选项 功能 -e 支持反斜线控制的字符转换（转义字符） 转义字符 意义 ASCLL码值(十进制) \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\' 代表一个单引号 039 \\\u0026quot; 代表一个双引号字符 034 \\0 空字符(NUL) 000 \\ddd 1到3位八进制数所代表的任意字符 三位八进制 \\xhh 十六进制所代表的任意字符 十六进制 示例：（记得加双引号）\n\u0026gt; 输出重定向和 \u0026raquo; 追加 基本语法：\n示例：\nln 软链接（快捷方式）和硬链接 软链接也成为符号链接，类似于 windows 里的快捷方式，有自己的数据块，主要存放了链接其他文件的路径\n基本语法：\nln -s 原文件或目录 软链接名\t（功能描述：给原文件创建一个软链接）\nln 原文件 目标文件 （功能描述：给原文件创建一个硬链接）\n删除软链接： rm -rf 软链接名，而不是 rm -rf 软链接名/\n查询：通过 ll 就可以查看，列表属性第 1 位是 l，尾部会有位置指向。\n示例：\nhistory 查看已执行的历史命令 示例：\nVI/VIM 编辑器 VI 是 Unix 操作系统和类 Unix 操作系统中最通用的文本编辑器。\nVIM 编辑器是从 VI 发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM 与 VI 编辑器完全兼容。\n在终端中执行以下命令安装 vim：sudo apt install vim\n一般模式 以 vim 打开一个档案就直接进入一般模式了（这是默认的模式）。在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。\n语法 功能描述 yy 复制光标当前一行 y 数字 y 复制一段（从光标当前行到后 n 行） p 箭头移动到目的行粘贴 u 撤销上一步 dd 删除光标当前行 d 数字 d 删除光标（含）后多少行 x 剪切一个字母 (当前光标)，相当于 del X 剪切一个字母 (当前光标的前一个)，相当于 Backspace yw 复制一个词 dw 删除一个词 shift+6(^) 移动到行头 shift+4($) 移动到行尾 1+shift+g 移动到页头，数字 shift+g 移动到页尾 数字 N+shift+g 移动到目标行 编辑模式 ​\t在一般模式中可以进行删除、复制、粘贴等的动作，但是却无法编辑文件内容的！要等到你按下『i, I, o, O, a, A』等任何一个字母之后才会进入编辑模式。\n​\t通常在 Linux 中，按下这些按键时，在画面的左下方会出现『INSERT 或 REPLACE』的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下『Esc』这个按键即可退出编辑模式。\n按键 功能 i 当前光标前 a 当前光标后 o 当前光标行的下一行 I 光标所在行最前 A 光标所在行最后 O 当前光标行的上一行 指令模式 在一般模式当中，输入『 : / ?』3 个中的任何一个按钮，就可以将光标移动到最底下那一行\n在这个模式当中， 可以提供你『搜寻资料』的动作，而读取、存盘、大量取代字符、离开 vi 、显示行号等动作是在此模式中达成的\n命令 功能 :w 保存 :q 退出 :! 强制执行 / 要查找的词 n 查找下一个，N 往上查找 :noh 取消高亮显示 :set nu 显示行号 :set nonu 关闭行号 :%s/old/new/g 替换内容 模式间的转换图 时间日期类 基本语法：date 选项 参数\n选项 功能 -d \u0026lt;时间字符串\u0026gt; 显示指定的 “时间字符串” 表示的时间，而非当前时间 -s \u0026lt;日期时间\u0026gt; 设置系统日期时间 参数 功能 +%Y 当前年份 +%y 当前年份的后两位 +%m 当前月份 +%d 当前哪一日 +%H 当前时 +%M 当前分 +%S 当前秒 +%F 当前年月日，中间以 : 隔开 +%T 当前时分秒，中间以 - 隔开 date 显示当前时间 基本语法：\n示例1：\n示例2：\ndate 显示非当前时间 基本语法：（很多写法，仅展示其一）\n示例：\ndate 设置系统时间 基本语法：date -s 字符串时间\n示例：date -s \u0026quot;2025-01-23 23:03:20\u0026quot;\n用户管理命令 adduser 添加新用户 基本语法：adduser 用户名\n应用场景 1：企业开发，多人协同（也会有多人使用相同的一个低权限用户）。\n应用场景 2：框架协同 gitlab mysql redis\n示例：\npasswd 设置或更改用户密码 基本语法：passwd 用户名\nid 查看用户是否存在 基本语法：id 用户名\ncat /etc/passwd 查看创建了哪些用户 基本语法：cat /etc/passwd\nsu 切换用户 su即swith user 切换用户\n基本语法：\nsu 用户名称\t（功能描述：切换用户，只能获得用户的执行权限，不能获得环境变量）\nsu - 用户名称\t（功能描述：切换到用户并获得该用户的环境变量及执行权限）\n示例：\nuserdel 删除用户 基本语法：\n选项 功能 -r 删除用户的同时，删除与用户相关的所有文件 usermod 修改用户 基本语法：\n选项 功能 -l 改变用户名 -d 修改家目录 示例：\n用户组管理命令 ​\t每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同。\n​\t如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。\n​\t用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group 文件的更新。\ngroupadd 新增组 基本语法：groupadd 组名\ngroupdel 删除组 基本语法：groupdel 组名\ngroupmod 修改组 基本语法：groupmod -n 新组名 老组名\nusermod 修改用户主组 ​\t在 Linux 和 Unix 系统中，每个用户都有一个主组（primary group）和可能的多个附加组（secondary groups 或 additional groups）\n​\t用户的主组在用户创建时被指定，默认与用户名称相同，当用户创建一个新文件或目录时，默认情况下，这些文件或目录会被分配给用户的主组\n基本语法：usermod -g 组名 用户名\n查看附加组和用户的映射关系 /etc/group 文件存储了用户和附加组的映射关系，每一行对应一个用户组，第三个冒号后面是以该组作为附加组的用户列表，列表为空表示没有用户将其作为附加组。\n操作：cat /etc/group\n将用户添加到附加组 基本语法：usermod -aG 组名 用户名\n将用户从组中移除 基本语法：deluser 用户名 组名\nsudo 设置普通用户具有 root 权限 把普通用户添加进sudo组中\n操作：sudo usermod -aG sudo 用户\n文件权限类 文件属性 文件基本属性介绍：\n如果查看到是文件：链接数指的是硬链接个数\n如果查看的是文件夹：链接数指的是子文件夹个数\n文件属性由从左到右的10 个字符表示\n如果没有权限，就会出现减号[ - ]而已。从左至右用 0-9 这些数字来表示：\n（1）0 首位表示类型\n在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等\n- 代表文件；d 代表目录；l代表链接文档(link file)\n（2）第 1-3 位确定属主（该文件的所有者）拥有该文件的权限。\u0026mdash;User\n（3）第 4-6 位确定属组（所有者的同组用户）拥有该文件的权限，\u0026mdash;Group\n（4）第 7-9 位确定其他用户拥有该文件的权限 \u0026mdash;Other\nrxw 作用文件和目录的不同解释 （1）作用到文件：\n[ r ]代表可读（read）：可以读取，查看\n[ w ]代表可写（write）：可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件\n[ x ]代表可执行（execute）：可以被系统执行\n（2）作用到目录：\n[ r ]代表可读（read）：可以读取，ls 查看目录内容\n[ w ]代表可写（write）：可以修改，目录内创建+删除+重命名目录\n[ x ]代表可执行（execute）：可以进入该目录\n示例：\nchmod 改变权限 第一种方式：chmod [{ugoa}{+-=}{rwx}] 文件或目录\n第二种方式：chmod [mode=对应数字 ] [文件或目录]\n其中，\nu：所有者 g：所有组 o：其他人 a：所有人（u、g、o 的总和）\n而在第二种方式中，r=4， w=2， x=1 ，rwx=4+2+1=7\n示例1：\n示例2：\nchown 改变所有者 基本语法：chown [选项] [最终用户] [文件或目录]\t（功能描述：改变文件或者目录的所有者）\n选项 功能 -R 同时更改该文件夹内所有子文件 示例：\nchgrp 改变所属组 基本语法：chgrp [最终用户组] [文件或目录]\t（功能描述：改变文件或者目录的所属组）\n搜索查找类 find 查找文件或者目录 基本语法：find [搜索范围] [选项]\n选项 功能 -name \u0026lt;查询方式\u0026gt; 按照指定的文件名查找模式查找文件 -user \u0026lt;查询方式\u0026gt; 查找属于指定用户名所有文件 -size \u0026lt;文件大小\u0026gt; 按照指定的文件大小查找文件，单位为： b —— 块（512 字节） c —— 字节 w —— 字（2 字节） k —— 千字节 M —— 兆字节 G —— 吉字节 示例：\ngrep 过滤查找及 “|” 管道符 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理\n基本语法：grep 选项 查找内容 源文件\n选项 功能 -n 显示匹配行及行号。 示例：\n压缩和解压类 gzip/gunzip 压缩 基本语法：\ngzip 文件\t（功能描述：压缩文件，只能将文件压缩为*.gz 文件）\ngunzip 文件.gz\t（功能描述：解压缩文件命令）\n只能压缩文件不能压缩目录，且不保留原来的文件\ntar 打包 基本语法：tar [选项] XXX.tar.gz 将要打包进去的内容\t（功能描述：打包目录，压缩后的文件格式.tar.gz）\n选项 功能 -c 产生 .tar 打包文件 -v 显示详细信息 -f 指定压缩后的文件名 -z 打包同时压缩 -x 解包 .tar 文件 示例：\n磁盘类 df 查看磁盘空间使用情况 df即disk free 空余硬盘\n基本语法：df 选项\t（功能描述：列出文件系统的整体磁盘使用量，检查文件系统的磁盘空间占用情况）\n选项 功能 -h 以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示 示例：\ndu 文件和目录的磁盘使用空间 基本语法：du 目录/文件\t（功能描述：统计文件或递归显示目录及子目录的磁盘使用空间）\n选项 功能 -a 显示当前目录下所有的文件目录及子目录大小 示例：\n进程线程类 ps 查看当前系统进程状态 ps即process status 进程状态\n基本语法：\nps -aux [| grep xxx] （功能描述：查看系统中所有进程，可以过滤查找）\nps -ef [| grep xxx]\t（功能描述：可以查看子父进程之间的关系）\n选项 功能 -a 选择所有进程 -u 显示所有用户的所有进程 -x 显示没有终端的进程 ps -aux 显示信息说明： 名称 含义 USER 该进程是由哪个用户产生的 PID 进程的 ID 号 %CPU 该进程占用 CPU 资源的百分比，占用越高，进程越耗费资源 %MEM 该进程占用物理内存的百分比，占用越高，进程越耗费资源 VSZ 该进程占用虚拟内存的大小，单位 KB RSS 该进程占用实际物理内存的大小，单位 KB TTY 该进程是在哪个终端中运行的。其中 tty1 - tty7 代表本地控制台终端，tty1 - tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 - 255 代表虚拟终端 STAT 进程状态。常见的状态有：R：运行、S：睡眠、T：停止状态、s：包含子进程、+：位于后台 START 该进程的启动时间 TIME 该进程占用 CPU 的运算时间，注意不是系统时间 COMMAND 产生此进程的命令名 ps -ef 显示信息说明 名称 含义 UID 用户 ID PID 进程 ID PPID 父进程 ID C CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高 STIME 进程启动的时间 TTY 完整的终端名称 TIME CPU 时间 CMD 启动进程所用的命令和参数 示例1：\n示例2：\nkill 终止进程 基本语法：\nkill [选项] 进程号\t（功能描述：通过进程号杀死进程）\nkillall 进程名称\t（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）\n选项 功能 -9 表示强迫进程立即停止 查看服务器总体内存 基本语法：free -m\t（功能描述：查看服务器总体内存，单位为兆M）\ntop 查看系统健康状态 （现在一般用软件监控）\n基本命令：top [选项]\n选项说明：\n选项 功能 -d 秒数 指定 top 命令每隔几秒更新 -i 使 top 不显示任何闲置或者僵死进程 -p 通过指定监控进程 ID 来仅仅监控某个进程的状态 操作说明：\n操作 功能 P 以 CPU 使用率排序，默认就是此项 M 以内存的使用率排序 N 以 PID 排序 q 退出 top 查询结果字段解释：\n（1）第一行信息为任务队列信息\n（2）第二行为进程信息\n（3）第三行为 CPU 信息\n（4）第四行为物理内存信息\n（5）第五行为交换分区（swap）信息\nnetstat 显示网络统计信息和端口占用情况 基本语法：\nnetstat -anp | grep 进程号\t（功能描述：查看该进程网络信息）\nnetstat -nlp | grep 端口号\t（功能描述：查看网络端口号占用情况）\n选项 功能 -n 拒绝显示别名，能显示数字的全部转化成数字 -l 仅列出有在 listen（监听）的服务状态 -p 表示显示哪个进程在调用 crontab 系统定时任务 crontab 服务管理 重新启动 crond 服务：sudo systemctl restart cron\ncrontab 定时任务设置 基本语法：crontab [选项]\n选项 功能 -e 编辑 crontab 定时任务 -l 查询 crontab 任务 -r 删除当前用户所有的 crontab 任务 输入EDITOR=vim crontab -e后，打开如下文件，在最后写入命令即可\nShell Shell概述 Shell是一个命令行解释器，它接收应用程序/用户命令，然后调用操作系统内核\nShell还是一个功能相当强大的编程语言，易编写、易调试、灵活性强\nShell入门 脚本格式 脚本以#!/bin/bash 开头（指定解析器）\n创建并执行一个脚本 要创建并执行一个Shell脚本，需要先在终端输入vim hello.sh创建并编辑一个Shell脚本\n在hello.sh中输入如图内容（按\u0026rsquo;a\u0026rsquo;开始编辑，按\u0026rsquo;esc\u0026rsquo;退出编辑，输入\u0026rsquo;:wq\u0026rsquo;保存并退出，忘记了看笔记VIM编辑器部分）\n编辑成功后，有两种运行方式\n方法一：不赋予脚本执行权限时，用sh 脚本或bash 脚本即可运行（效果一样）\n方法二：赋予脚本执行权限，可直接执行\n变量 系统变量 常用系统变量有HOME、PWD、SHELL、USER 等\n一般系统变量都是由全大写字母构成，所以自定义变量的时候尽量避免全部用大写字母\n要获取变量的值可以用$变量名，$和变量名之间不能有空格\n示例：\n自定义变量 基本语法：\n（1）定义变量：变量名=变量值，注意，=号前后不能有空格。（起名的时候不用加$）\n（2）撤销变量：unset 变量名。\n（3）声明静态变量：readonly 变量，注意：不能 unset。\n变量定义规则：\n（1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。\n（2）等号两侧不能有空格。\n（3）在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算。\n（4）变量的值如果有空格，需要使用双引号或单引号括起来。\n示例：\n特殊变量 $n 基本语法：\n$n （功能描述：n 为数字，$0 代表该脚本名称，$1-$9 代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}）\n示例：\n$# $# （功能描述：获取所有输入参数个数，常用于循环,判断参数的个数是否正确以及加强脚本的健壮性）\n示例：\n$* 和 $@ 基本语法：\n$* （功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体。）\n$@ （功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待。）\n（具体区别会在后续学习中了解）\n示例：\n$? 基本语法：\n$？ （功能描述：最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一个命令正确执行；如果这个变量的值为非 0（具体是哪个数，由命令自己来决定，表示错误代码），则证明上一个命令执行不正确了）\n示例：\n运算符 基本语法：\n$((运算式))或$[运算式]\n示例：计算 （2 + 3）× 4 的值\n条件判断 基本语法：\ntest 条件或[ 条件 ]\t（注意条件前后有空格）\n注意：条件非空即为 true，[ atguigu ]返回 true，[ ] 返回 false\n常用判断条件 示例1：\n示例2：\n示例3：多条件判断（\u0026amp;\u0026amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令）\n流程控制 if判断 基本语法：\n注意事项：\n① [ 条件判断式 ]，中括号和条件判断式之间必须有空格\n② if 后要有空格\n示例：\ncase 语句 基本语法：\n注意事项：\n（1）case 行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。\n（2）双分号“;;”表示命令序列结束，相当于 C 中的 break。\n（3）最后的“*）”表示默认模式，相当于 C 中的 defaul。\n示例：\nfor 循环 基本语法1：\n基本语法2：\n示例1：\n示例2：打印所有输入参数\n比较$*和$@的区别 $*和$@都表示传递给函数或脚本的所有参数，不被双引号“”包含时，都以$1 $2 …$n的形式输出所有参数。 在for3.sh中写入如下内容\n1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash echo \u0026#39;=============$*=============\u0026#39; for i in $* do echo \u0026#34;ban zhang love $i\u0026#34; done echo \u0026#39;=============$@=============\u0026#39; for j in $@ do echo \u0026#34;ban zhang love $j\u0026#34; done 如下执行：\n当它们被双引号“”包含时，$*会将所有的参数作为一个整体，以“$1 $2 …$n”的形式输出所有参数；$@会将各个参数分开，以“$1” “$2”…“$n”的形式输出所有参数。 在for4.sh中写入如下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash echo \u0026#39;=============$*=============\u0026#39; for i in \u0026#34;$*\u0026#34; ## $*中的所有参数看成是一个整体，所以这个 for 循环只会循环一次 do echo \u0026#34;ban zhang love $i\u0026#34; done echo \u0026#39;=============$@=============\u0026#39; for j in \u0026#34;$@\u0026#34; ## $@中的每个参数都看成是独立的，所以“$@”中有几个参数，就会循环几次 do echo \u0026#34;ban zhang love $j\u0026#34; done 如下执行：\nwhile 循环 基本语法：\n示例：从 1 加到 100\n在while.sh中写入如下内容\n1 2 3 4 5 6 7 8 9 10 #!/bin/bash sum=0 i=1 while [ $i -le 100 ] do sum=$[$sum+$i] i=$[$i+1] done echo $sum 执行：\nread 读取控制台输入 基本语法：read （选项） （参数）\n选项：\n-p：指定读取值时的提示符。\n-t：指定读取值时等待的时间（秒）如果-t 不加表示一直等待。\n参数\n变量：指定读取值的变量名。\n示例：\n1 2 3 4 5 6 7 8 #!/bin/bash read -t 5 -p \u0026#34;请在5秒内输入你的名字:\u0026#34; name if [ $name ]; then echo \u0026#34;你好，$name\u0026#34; else echo \u0026#34;未在指定时间内输入名字\u0026#34; fi 如下执行：\n函数 系统函数 basename取文件名 基本语法：\nbasename [string / pathname] [suffix] （功能描述：basename 命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。\nbasename 可以理解为取路径里的文件名称。\nsuffix 为后缀，如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉。\n示例：\ndirname取路径 基本语法：\ndirname 文件绝对路径 （功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））\ndirname 可以理解为取文件路径的绝对路径名称。\n示例：\n自定义函数 基本语法：\n（1）必须在调用函数地方之前，先声明函数，shell 脚本是逐行运行。不会像其它语言一样先编译。\n（2）函数返回值，只能通过$?系统变量获得，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。return 后跟数值 n（0-255），运行成功返回0，其他均为失败\n示例：\n在fun.sh中如下写入\n1 2 3 4 5 6 7 8 9 10 #!/bin/bash function sum() { s=0 s=$[$1+$2] echo \u0026#34;$s\u0026#34; } read -p \u0026#34;Please input the number1: \u0026#34; n1; read -p \u0026#34;Please input the number2: \u0026#34; n2; sum $n1 $n2; 如下执行：\nShell工具 cut 工具的使用 cut 的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。\n基本用法：\ncut [选项参数] filename\t说明：默认分隔符是制表符\n选项参数 功能 -f 列号，提取第几列 -d 分隔符，按照指定分隔符分割列，默认是制表符“\\t” -c 按字符进行切割 后加加 n 表示取第几列 比如 -c 1 示例：\nawk 工具的使用 一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。\n基本用法：\nawk [选项参数] ‘/pattern1/{action1} /pattern2/{action2}...’ filename\npattern：表示 awk 在数据中查找的内容，就是匹配模式。\naction：在找到匹配内容时所执行的一系列命令。\n选项参数 功能 -F 指定输入文件的分隔符 -v 赋值一个用户定义变量 正则表达式入门 常用特殊字符 1）特殊字符：^\n2）特殊字符：$\n3）特殊字符：.\n4）特殊字符：*\n5）特殊字符：[ ]\n6）特殊字符：\\\n经典正则表达式 1 2 3 4 #邮箱正则 ^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$ #手机号正则 /^1((34[0-8])|(8\\d{2})|(([35][0-35-9]|4[579]|66|7[35678]|9[1389])\\d{1}))\\d{7}$/ 补充 该笔记基于尚硅谷课程 https://www.bilibili.com/video/BV1JF4m1A7mN/\n虚拟机代理配置 https://blog.csdn.net/weixin_63594197/article/details/138069939\n链接失效时可以看下方视频\n设置使用sudo时不需要密码 在终端输入：sudo vim /etc/sudoers\n找到文件最下面，修改为如图所示的样子：\n\\ 在下一行继续输入 示例：\n","date":"2024-03-27T14:54:42+08:00","permalink":"https://IAmYuanyu.github.io/p/ubuntu%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Ubuntu基础学习笔记"},{"content":"第一章：初识Python 注释 块注释 以#开始，一直到本行结束都是注释\n为了保证代码的可读性，#后面建议先添加一个空格，然后再编写相应的说明文字（PEP8规范），如下\n1 ## 注释内容 行内注释 一般在#前面至少有两个空格（PEP8规范）\n1 print(666) # 注释内容 多行注释 要在python 程序中使用多行注释，可以用 一对 连续的 三个 引号(单引号和双引号都可以)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026#39;\u0026#39;\u0026#39; 注释内容 注释内容 注释内容 \u0026#39;\u0026#39;\u0026#39; \u0026#34;\u0026#34;\u0026#34; 注释内容 注释内容 注释内容 \u0026#34;\u0026#34;\u0026#34; ## 注释内容 ## 注释内容 ## 注释内容 输出 print()函数 print()函数：print(*objects, sep=' ', end='\\n', file=None, flush=False)\nsep：设置多个内容之间的分隔符，默认分隔符、空格\nend: 设置结束符，默认结束符\u0026rsquo;\\n'\n想要在一行中打印多个内容，可以在print()函数中使用逗号隔开多个内容，如下\n1 print(\u0026#34;今年是\u0026#34;, 2025, \u0026#34;年\u0026#34;) # 输出：今年是 2025 年 逗号默认会转化为空格，可以通过设置sep来改变分隔符，如下\n1 2 print(\u0026#34;今年是\u0026#34;, 2025, \u0026#34;年\u0026#34;, sep=\u0026#34;\u0026#34;) # 输出：今年是2025年 print(\u0026#34;今年是\u0026#34;, 2025, \u0026#34;年\u0026#34;, sep=\u0026#34;-\u0026#34;) # 输出：今年是-2025-年 输出结果独占一行是因为print()函数结尾默认是转义字符\\n，即换行\n1 2 3 print(\u0026#34;今年是2025年\u0026#34;, end=\u0026#34;\\t\u0026#34;) print(\u0026#34;今天是1月9日\u0026#34;, end=\u0026#34;!\u0026#34;) ## 输出：今年是2025年\t今天是1月9日! 格式化输出 如果希望输出文字信息的同时，一起输出 数据，就需要使用到 格式化操作符\n% 被称为 格式化操作符，专门用于处理字符串中的格式 包含 % 的字符串，被称为 格式化字符串 % 和不同的 字符 连用，不同类型的数据 需要使用 不同的格式化字符 print(\u0026quot;格式化字符串\u0026quot; % (变量1, 变量2...))\n格式化字符 含义 %s 字符串 %d 有符号十进制整数，%06d 表示输出的整数显示6位数，不足的地方使用 0 补全 %f 浮点数，%.2f 表示小数点后只显示两位 %% 输出 % 1 2 3 4 year = 2025 month = 1 print(\u0026#34;现在是%d年%02d月\u0026#34; % (year, month)) 输出：现在是2025年01月 输入 input()函数 在 Python 中，如果要获取用户在 键盘 上的输入信息，需要使用到 input 函数\n用户输入的 任何内容 Python 都认为是一个 字符串\n1 2 3 temp1 = input(\u0026#34;请输入第一个数：\u0026#34;) temp2 = input(\u0026#34;请输入第二个数：\u0026#34;) print(temp1 + temp2) 输出：\n类型转换 可以通过类型转换改变输出的类型\n1 2 3 temp1 = int(input(\u0026#34;请输入第一个数：\u0026#34;)) temp2 = int(input(\u0026#34;请输入第二个数：\u0026#34;)) print(temp1 + temp2) 输出：\n第二章：变量与简单数据类型 变量 多个变量的赋值 1 2 3 4 5 ## 多个变量的值相同时 num1 = num2 = num3 = 10 ## 多个变量的值不同，元组赋值 a, b = 10, 20 变量的修改 在Python中不同类型的变量也可以进行修改、重新赋值\n1 2 3 money = 10 money = \u0026#34;10元\u0026#34; print(money) # 输出：10元 变量的数据类型 可以使用type()和isinstance()来判断变量的数据类型\n1 2 3 4 temp = \u0026#34;hello\u0026#34; print(type(temp)) # 输出：\u0026lt;class \u0026#39;str\u0026#39;\u0026gt; print(isinstance(temp, str)) # 输出：True print(isinstance(temp, int)) # 输出：False Python中的数据类型有如下几个\n常量 Python中没有专门的常量类型，一般约定俗成使用大写表示常量\n浮点数的误差 可以使用round(表达式, 保留几位)函数四舍五入，在一定程度上消除误差\n1 2 3 4 5 n1 = 0.1 n2 = 0.2 print(n1 + n2) # 输出：0.30000000000000004 print(round(n1 + n2, 2)) # 输出：0.3 （因为计算结果只有1位） print(round(0.6666, 2)) # 输出：0.67 也可以使用math库里的取整函数\n1 2 3 4 5 6 7 8 ## 导入math库 import math ## 向上取整 ceil() print(math.ceil(3.14)) # 输出：4 ## 向下取整 floor() print(math.floor(3.14)) # 输出：3 布尔型 在Python中布尔型的变量只有True和False两种值，注意首字母大写\n在Python中，能够解释为假的值有：\nNone、0、0.0、False、所有的空容器（空列表、空元组、空字典、空集合、空字符串）\n字符串 多行字符串 在 Python 中可以使用 一对双引号 \u0026quot; 或者 一对单引号 \u0026rsquo; 定义一个字符串。\n字符串是以单引号或者双引号括起来的任意文本，也可以是以三引号\u0026rsquo;\u0026lsquo;\u0026lsquo;或者\u0026quot;\u0026ldquo;\u0026ldquo;引起来的任意文本。\n1 2 3 4 5 6 7 ## 多行字符串 str = \u0026#39;\u0026#39;\u0026#39;welcome to my world\u0026#39;\u0026#39;\u0026#39; print(str) ## 输出： welcome to my world 字符串乘法 1 2 ## 字符串乘法 print(\u0026#34;你好\u0026#34; * 3) # 输出：你好你好你好 字符串索引 可以使用 索引 获取一个字符串中 指定位置的字符，索引计数从 0 开始。\n1 2 3 4 5 6 7 str = \u0026#34;0123456\u0026#34; print(str[0], str[-1]) # 输出：0 6 ## 切片 变量名[起始索引:结束索引+1:步数] ## 起始索引默认为0，可省略; 结束索引默认为-1，可省略; 步数默认为1，可省略 print(str[1:-1]) # 输出：12345 print(str[1:-1:2]) # 输出：135 (最后一个值表示读取间隔，默认为1) print(str[::2]) # 输出：0246 利用切片实现字符串反转 1 2 3 str = \u0026#34;0123456\u0026#34; strNew = str[::-1] print(strNew) # 输出：6543210 数据类型转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## 转换为int print(int(\u0026#39;2024\u0026#39;)) # 输出：2024 ## print(int(\u0026#39;nihao\u0026#39;)) # 无法转换，会报错 ## print(int(\u0026#39;2024.1.10\u0026#39;)) # 无法转换，会报错 print(int(2.999)) # 输出：2 print(int(True), int(False)) # 输出：1 0 print(int(\u0026#39;15\u0026#39;, 10)) # 表示将内容是10进制整数的字符串转换为10进制整数，输出：15 print(int(\u0026#39;100110\u0026#39;, 2)) # 表示将内容是2进制整数的字符串转换为10进制整数，输出：38 print(int(\u0026#39;1f\u0026#39;, 16)) # 表示将内容是16进制整数的字符串转换为10进制整数，输出：31 print(int(\u0026#39;11\u0026#39;, 8)) # 表示将内容是8进制整数的字符串转换为10进制整数，输出：9 ## 转换为bool print(bool(\u0026#39;\u0026#39;)) # 输出：False print(bool(\u0026#39;0\u0026#39;)) # 输出：True 第三章：运算符与表达式 算数运算符 运算符优先级 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 运算符优先级 第四章：条件判断 单分支 双分支 多分支 match语句 与其他语言中的switch分支类似\n第五章：循环 while循环 1 2 3 4 5 6 7 ## 从1加到100的和 num = 1 sum = 0 while num \u0026lt;= 100: sum += num num += 1 print(sum) for循环 1 2 3 4 5 6 7 8 9 10 11 12 for i in range(3): print(i, end=\u0026#34;\\t\u0026#34;) ## 输出：0\t1\t2\t## 从1加到100的和 num = 1 sum = 0 for i in range(100): sum += num num += 1 print(sum) 循环控制 break continue pass 第六章：组合数据类型 序列 在python中，有这样一些类型，它们的成员是有序排列的，并且可以通过下标访问成员，这些类型称之为序列。\n包括：列表、range、元组和字符串；\n序列的通用操作 列表（数组） List（列表） 是 Python 中使用 最频繁 的数据类型，在其他语言中通常叫做 数组\n专门用于存储 一串 信息\n列表用 [ ] 定义，数据 之间使用 , 分隔\n列表的 索引 从 0 开始\n索引 就是数据在 列表 中的位置编号，索引 又可以被称为 下标\n注意：从列表中取值时，如果 超出索引范围，程序会报错\n创建列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ## 创建列表 ## 语法： ## 列表名 = [元素1, 元素2, ...] list1 = [] print(type(list1)) # 输出：\u0026lt;class \u0026#39;list\u0026#39;\u0026gt; list2 = [123, \u0026#34;你好\u0026#34;, True] print(type(list2), list2) # 输出：\u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [123, \u0026#39;你好\u0026#39;, True] list3 = list() # 类型转换：把参数转换为列表 print(type(list3)) list4 = list(\u0026#34;hello\u0026#34;) print(type(list4), list4) # 输出：\u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;] 列表的运算 1 2 3 4 5 6 7 8 9 list1 = list(\u0026#34;123\u0026#34;) list2 = list(\u0026#34;456\u0026#34;) print(list1 + list2) # 输出：[\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;] print(list1 * 2) # 输出：[\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;] print(\u0026#34;4\u0026#34; in list1, \u0026#34;4\u0026#34; in list2) # 输出：False True ## 比较规则：每个数依次比较，若相同则比较各自的下一位，若不同则直接出结果 print([2, 3, 4, 5] \u0026lt; [1, 9, 9, 9]) # 输出：False print([2, 3, 4, 5] \u0026lt; [3, 0]) # 输出：True 列表内置的部分函数 1 2 3 4 5 6 7 list1 = list(\u0026#34;0123456789\u0026#34;) print(len(list1)) # 输出：10 print(max(list1)) # 输出：9 print(min(list1)) # 输出：0 list = [1, 2, 3, 4, 5] print(sum(list)) # 输出：15 列表的遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ## 直接遍历 list = list(\u0026#34;hello\u0026#34;) for i in list: print(i, end=\u0026#34;\\t\u0026#34;) ## 输出：h\te\tl\tl\to\t## 想要索引和内容一起打印可以使用枚举函数enumerate() list = list(\u0026#34;hello\u0026#34;) for index,value in enumerate(list): # 枚举 print(index, value) ## 输出： ## 0 h ## 1 e ## 2 l ## 3 l ## 4 o ## 通过索引遍历 list = list(\u0026#34;hello\u0026#34;) for i in range(len(list)): print(list[i], end=\u0026#34;\\t\u0026#34;) ## 输出：h\te\tl\tl\to\t列表的常用方法 分类 关键字 / 函数 / 方法 说明 增加 列表.insert (索引，数据) 在指定位置插入数据 增加 列表.append (数据) 在末尾追加数据 增加 列表.extend (列表 2) 将列表 2 的数据追加到列表 修改 列表 [索引] = 数据 修改指定索引的数据 删除 del 列表 [索引] 删除指定索引的数据 删除 列表.remove [数据] 删除第一个出现的指定数据 删除 列表.pop 删除末尾数据 删除 列表.pop (索引) 删除指定索引数据 删除 列表.clear 清空列表 统计 len (列表) 列表长度 统计 列表.count (数据) 数据在列表中出现的次数 排序 列表.sort () 升序排序 排序 列表.sort (reverse=True) 降序排序 排序 列表.reverse () 逆序、反转 元组 • Tuple（元组）与列表类似，不同之处在于元组的元素不能修改\n• 元组 表示多个元素组成的序列\n• 用于存储 一串信息，数据之间使用 , 分隔\n• 元组用 () 定义\n1 2 3 4 5 6 7 8 9 tuple1 = (6, \u0026#34;hello\u0026#34;, True) print(tuple1) # 输出：(6, \u0026#39;hello\u0026#39;, True) print(type(tuple1)) # 输出：\u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; ## 当元组中只存一个数时，为了避免被识别为别的数据类型，要在最后加一个, tuple1 = (1) print(type(tuple1)) # 输出：\u0026lt;class \u0026#39;int\u0026#39;\u0026gt; tuple2 = (1,) print(type(tuple2)) # 输出：\u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; 元组的常用方法 1 2 3 4 5 tuple1 = (123, 123, 456, \u0026#34;hello\u0026#34;) print(tuple1.count(123)) # 输出：2 print(tuple1.count(\u0026#34;he\u0026#34;)) # 输出：0 print(tuple1.index(\u0026#34;hello\u0026#34;)) # 输出：3 range • 系统提供的内建函数range(start=0, end, [step=1])，生成一个等差序列 [start, end)\n• 注意序列属于不可变序列，不支持元素修改，不支持+和*操作。\n• range一般用于for-in循环遍历\n1 2 3 print(list(range(10))) # end 输出：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] print(list(range(1, 10))) # start, end 输出：[1, 2, 3, 4, 5, 6, 7, 8, 9] print(list(range(1, 10, 2))) # start, end, step 输出：[1, 3, 5, 7, 9] 水仙花练习（利用Python的字符串索引） 三位数，每一位数字的立方和加起来等于这个三位数本身\n1 2 3 4 5 6 7 8 9 10 11 12 13 for i in range(100, 1000): num = str(i) a = int(num[2]) b = int(num[1]) c = int(num[0]) if a**3 + b**3 + c**3 == i: print(i) ## 输出： ## 153 ## 370 ## 371 ## 407 字符串 字符串也可以使用序列的通用操作\n字符串常用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 s = \u0026#34; 686 hello \u0026#34; ## 判断含有的字母是否全是小写 print(s.islower()) # 输出：True ## 判断含有的字母是否全是大写 print(s.isupper()) # 输出：False ## 消除字符串首尾的空格 print(s.strip()) # 输出：686 hello ## 将字符串按照给出的分隔符拆成列表 print(s.split(\u0026#39; \u0026#39;)) # 输出：[\u0026#39;\u0026#39;, \u0026#39;686\u0026#39;, \u0026#39;hello\u0026#39;, \u0026#39;\u0026#39;] ## 将列表按照指定分隔符连接成字符串 print(\u0026#34;/\u0026#34;.join([\u0026#34;2024\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;12\u0026#34;])) # 输出：2024/1/12 ## 查找指定内容，可以指定起止位置，找不到则返回-1 print(s.find(\u0026#34;6\u0026#34;)) # 输出：2 print(s.find(\u0026#34;6\u0026#34;, 3)) # 输出：4 print(s.find(\u0026#34;hi\u0026#34;)) # 输出：-1 字典（dict） dictionary（字典） 是 除列表以外 python 之中 最灵活 的数据类型\n字典同样可以用来 存储多个数据\n通常用于存储 描述一个 物体 的相关信息\n和列表的区别\n列表 是 有序 的对象集合\n字典 是 无序 的对象集合\n字典用{}定义，字典使用 键值对 存储数据，键值对之间使用 , 分隔\n• 键 key 是索引\n• 值 value 是数据\n• 键 和 值 之间使用 : 分隔\n• 键必须是唯一的\n• 值 可以取任何数据类型，但 键 只能使用 字符串、数字或 元组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 d = { \u0026#34;name\u0026#34;: \u0026#34;Lihua\u0026#34;, # 键值对 \u0026#34;gender\u0026#34;: \u0026#34;male\u0026#34;, \u0026#34;height\u0026#34;: 168.5 } print(d) # 输出：{\u0026#39;name\u0026#39;: \u0026#39;Lihua\u0026#39;, \u0026#39;gender\u0026#39;: \u0026#39;male\u0026#39;, \u0026#39;height\u0026#39;: 168.5} ## 获取键值对 print(d[\u0026#39;gender\u0026#39;]) # 输出：male ## 新增键值对 d[\u0026#39;salary\u0026#39;] = 3000 print(d) # 输出：{\u0026#39;name\u0026#39;: \u0026#39;Lihua\u0026#39;, \u0026#39;gender\u0026#39;: \u0026#39;male\u0026#39;, \u0026#39;height\u0026#39;: 168.5, \u0026#39;salary\u0026#39;: 3000} ## 修改键值对 d[\u0026#39;height\u0026#39;] = 169 print(d) # 输出：{\u0026#39;name\u0026#39;: \u0026#39;Lihua\u0026#39;, \u0026#39;gender\u0026#39;: \u0026#39;male\u0026#39;, \u0026#39;height\u0026#39;: 169, \u0026#39;salary\u0026#39;: 3000} ## 删除键值对 del d[\u0026#39;salary\u0026#39;] print(d) # 输出；{\u0026#39;name\u0026#39;: \u0026#39;Lihua\u0026#39;, \u0026#39;gender\u0026#39;: \u0026#39;male\u0026#39;, \u0026#39;height\u0026#39;: 169} 字典的遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 d = { \u0026#34;name\u0026#34;: \u0026#34;Lihua\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;male\u0026#34;, \u0026#34;height\u0026#34;: 168.5 } print(d.items()) # 输出：dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Lihua\u0026#39;), (\u0026#39;gender\u0026#39;, \u0026#39;male\u0026#39;), (\u0026#39;height\u0026#39;, 168.5)]) for key, value in d.items(): print(key, value) ## 输出： ## name Lihua ## gender male ## height 168.5 集合（set） • 不允许有重复元素，如果添加重复元素，则会自动过滤，可以进行交集、并集的运算。\n• 是一种无序且无重复元素的数据结构\n• 与dict类似，是一组key的集合(不存储value)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 set1 = {1, 2, 3, 1, 2} print(set1) # 输出：{1, 2, 3} set1 = set([1, 2, 4, 1, 2, 4]) # list --\u0026gt; set print(set1) # 输出：{1, 2, 4} set1 = set((1, 2, 3)) # tuple --\u0026gt; set print(set1) # 输出：{1, 2, 3} set1 = set(\u0026#34;123\u0026#34;) # str --\u0026gt; set print(set1) # 输出：{\u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;1\u0026#39;} （顺序随机） set1 = set({\u0026#39;name\u0026#39;:\u0026#39;zhangsan\u0026#39;, \u0026#39;age\u0026#39;:23}) # dict --\u0026gt; set print(set1) # 输出：{\u0026#39;age\u0026#39;, \u0026#39;name\u0026#39;} print(\u0026#39;age\u0026#39; in set1) # 输出：True print(len(set1)) # 输出：2 交集和并集 1 2 3 4 set1 = {1, 2, 3, 4, 5} set2 = {1, 3, 5, 7, 9} print(set1 \u0026amp; set2) # 交集，输出：{1, 3, 5} print(set1 | set2) # 并集，输出：{1, 2, 3, 4, 5, 7, 9} 用户登录系统小练习 需求：用户输入用户名、密码后，根据用户是否已经注册，用户是否在黑名单中，提示用户是否登录成功\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## 用户名、密码、黑名单 users = { \u0026#39;小红\u0026#39;:{\u0026#39;name\u0026#39;:\u0026#39;小红\u0026#39;, \u0026#39;password\u0026#39;:\u0026#39;123\u0026#39;, \u0026#39;status\u0026#39;:True}, \u0026#39;mia\u0026#39;:{\u0026#39;name\u0026#39;:\u0026#39;mia\u0026#39;, \u0026#39;password\u0026#39;:\u0026#39;456\u0026#39;, \u0026#39;status\u0026#39;:True}, \u0026#39;jack\u0026#39;:{\u0026#39;name\u0026#39;:\u0026#39;jack\u0026#39;, \u0026#39;password\u0026#39;:\u0026#39;789\u0026#39;, \u0026#39;status\u0026#39;:False}, } for j in range(3): user = input(\u0026#39;请输入你的用户名：\u0026#39;) pwd = input(\u0026#39;请输入你的密码：\u0026#39;) if user in users and pwd==users[user][\u0026#39;password\u0026#39;] and users[user][\u0026#39;status\u0026#39;]: print(\u0026#39;登录成功！\u0026#39;) break elif user in users and not users[user][\u0026#39;status\u0026#39;]: print(\u0026#39;账号失效，请联系管理员！\u0026#39;) elif user in users and pwd!=users[user][\u0026#39;password\u0026#39;]: print(\u0026#39;密码输入错误，请重试！\u0026#39;) else: print(\u0026#39;用户不存在，请先注册！\u0026#39;) 计算天数小练习 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ## 题目要求：输入xxxx-xx-xx(如2025-1-12), 输出这一天是这一年的第多少天 date = input(\u0026#39;请输入日期：\u0026#39;).split(\u0026#39;-\u0026#39;) year = int(date[0]) month = int(date[1]) day = int(date[2]) days = [0,31,28,31,30,31,30,31,31,30,31,30,31] ## 如果是闰年2月加一天 if (not year % 4 and year % 100 ) or not year % 400: days[2] += 1 result = 0 for i in range(month): result += days[i] result += day print(\u0026#39;这一天是这一年的第%d天\u0026#39; % result) 第七章：异常处理 常见异常类型 报错类型 描述 AssertionError 当 assert 断言条件为假的时候抛出的异常。 AttributeError 当访问的对象属性不存在的时候抛出的异常 IndexError 超出对象索引的范围时抛出的异常。 KeyError 在字典中查找一个不存在的 key 抛出的异常 NameError 访问一个不存在的变量时抛出的异常。 OSError 操作系统产生的异常。 SyntaxError 语法错误时会抛出此异常。 TypeError 类型错误，通常是不同类型之间的操作会出现此异常。 ZeroDivisionError 进行数学运算时除数为 0 时会出现此异常。 try-except语句（try-catch） 1、首先执行try中【代码块A】，如果出现异常，立即终止代码执行，转而到except块中进行异常处理\n2、异常处理except模块可以多个，从上往下匹配，如果能够匹配成功，立即执行相应的异常处理代码块，执行完毕后，不在往下匹配，转到3执行\n3、执行异常处理完毕后，如果有finally字句则执行finally字句，如果没有则执行【后续语句】\n4、如果匹配不到异常，有finally则执行finally，然后则抛出错误，终止程序执行。\n5、如果没有异常，如果有else字句则执行else字句，执行完else后，有finally字句则执行，没有则执行【后续语句】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 try: print(\u0026#34;第一行成功运行\u0026#34;) print(第二行成功运行) print(\u0026#34;第三行成功运行\u0026#34;) except: print(\u0026#34;出现异常\u0026#34;) ## 输出： ## 第一行成功运行 ## 出现异常 ## --------------------------------------------------- try: print(\u0026#34;第一行成功运行\u0026#34;) print(\u0026#34;1\u0026#34; + 1) except NameError: print(\u0026#34;中文给我加引号！\u0026#34;) except TypeError: print(\u0026#34;Python里不能这么玩\u0026#34;) ## 输出： ## 第一行成功运行 ## Python里不能这么玩 ## --------------------------------------------------- try: print(\u0026#34;第一行成功运行\u0026#34;) print(\u0026#34;1\u0026#34; + 1) except NameError: print(\u0026#34;中文给我加引号！\u0026#34;) except TypeError as e: print(\u0026#34;Python里不能这么玩\u0026#34;) print(\u0026#34;报错信息：\u0026#34;, e) else: print(\u0026#34;else成功运行\u0026#34;) finally: print(\u0026#34;finally成功运行\u0026#34;) ## 输出： ## 第一行成功运行 ## Python里不能这么玩 ## 报错信息： can only concatenate str (not \u0026#34;int\u0026#34;) to str ## finally成功运行 ## --------------------------------------------------- try: print(\u0026#34;第一行成功运行\u0026#34;) except NameError: print(\u0026#34;中文给我加引号！\u0026#34;) except TypeError as e: print(\u0026#34;Python里不能这么玩\u0026#34;) print(\u0026#34;报错信息：\u0026#34;, e) else: print(\u0026#34;else成功运行\u0026#34;) finally: print(\u0026#34;finally成功运行\u0026#34;) ## 输出： ## 第一行成功运行 ## else成功运行 ## finally成功运行 raise关键字（throw） 手动抛出一个指定类型的异常，无论是哪种异常类都可以带一个字符串参数，对异常进行描述。\nraise不带参数会把错误原样抛出\n1 2 3 4 5 6 7 8 9 10 try: print(\u0026#34;第一行成功运行\u0026#34;) raise Exception (\u0026#34;主动抛出异常\u0026#34;) print(\u0026#34;1111\u0026#34;) except Exception as e: print(e) ## 输出： ## 第一行成功运行 ## 主动抛出异常 简易计算器小练习 支持加减乘除四则运算，输入不符合规范的时候给出相应提示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 while True: try: op = input(\u0026#39;请输入一个四则运算算式（例如1+2）：\u0026#39;) if \u0026#39;+\u0026#39; in op:#加法 14+256 a = op.split(\u0026#39;+\u0026#39;) result = int(a[0]) + int(a[1]) print(result) elif \u0026#39;-\u0026#39; in op: a = op.split(\u0026#39;-\u0026#39;) result = int(a[0]) - int(a[1]) print(result) elif \u0026#39;*\u0026#39; in op: a = op.split(\u0026#39;*\u0026#39;) result = int(a[0]) * int(a[1]) print(result) elif \u0026#39;/\u0026#39; in op: a = op.split(\u0026#39;/\u0026#39;) result = int(a[0]) / int(a[1]) print(result) elif op==\u0026#39;C\u0026#39;: print(\u0026#39;感谢您使用本计算器！\u0026#39;) break else: raise Exception(\u0026#39;请按1+2这个格式输入算式！\u0026#39;) except ZeroDivisionError: print(\u0026#39;注意除法运算，除数不能为0！\u0026#39;) except Exception as e: print(e) 第八章：函数 函数的定义和调用 使用关键字def\n1 2 3 4 5 ## 定义函数 def test(): print(\u0026#34;函数被调用\u0026#34;) ## 调用函数 test() # 输出：函数被调用 默认参数 有参数传入时使用传入的参数，没有参数传入时使用默认参数，具有默认值的形参写在最后\n1 2 3 4 5 def f(x, y=1): return x * y print(f(2, 3)) # 2*3=6, 输出：6 print(f(2)) # 2*1=2, 输出2 可变参数 在形参前面加一个*号表示该参数为可变参数，可变参数可以自适应传入参数的个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def f(*args): # 可变参数 sum = 0 for i in args: sum += i return sum print(f(1, 2, 3)) # 输出：6 print(f(1, 2, 3, 4)) # 输出：10 ## ----------------------------------------- def f(**kwargs): for key, value in kwargs.items(): print(key, \u0026#39;:\u0026#39;, value) d = { \u0026#39;name\u0026#39;: \u0026#39;zhangsan\u0026#39;, \u0026#39;gender\u0026#39;: \u0026#39;male\u0026#39; } f(**d) ## 输出： ## name : zhangsan ## gender : male ## ----------------------------------------- def f(*args): # 可变参数 sum = 0 for i in args: sum += i return sum a = [1, 2, 3] ## 传入列表时要在前面加一个*来解列表 print(f(*a)) # 输出：6 变量作用域 在Python中可以通过global在局部修改全局变量\n1 2 3 4 5 6 7 num1 = 1 def f(): global num1 # 声明在f中使用的num1是全局变量num1 num1 = 2 print(num1) f() # 输出：2 print(num1) # 输出：2 匿名函数 补充：map()函数 1 2 3 4 5 6 7 ## map(函数, 数据集) ## map函数的功能就是把数据集之中的数据依次取出，并将其作为参数传入左边的函数 def Square(x): return x**2 list1 = [1, 2, 3, 4] result = map(Square, list1) print(list(result)) # 输出：[1, 4, 9, 16] 补充：reduce()累计函数 1 2 3 from functools import reduce # 导入函数 result = reduce(lambda x, y: x + y, [1, 2, 3, 4, 5]) print(result) # 输出：15 补充：filter()过滤函数 1 2 result = filter(lambda x: x % 2 == 0, range(1,6)) # 只留偶数 print(list(result)) # 输出：[2, 4] 匿名函数的使用 1 2 3 4 5 6 7 8 9 fun = lambda a, b: a + b # 匿名函数 lambda 形参: 函数体 result = fun(1, 2) print(result) ## ----------------------------------------- list1 = [1, 2, 3, 4] result = map(lambda x: x**2, list1) print(list(result)) # 输出：[1, 4, 9, 16] 内置函数 函数 用途 abs() 对传入参数取绝对值 bool() 对传入参数取布尔值，None, 0, \u0026lsquo;\u0026rsquo;,[],{},() 这些参数传入 bool 后，返回 False all() 所有传入参数为真，才为真 any() 任何一个传入参数为真，才为真 ascii() 自动执行传入参数的_repr_方法（将对象转换为字符串） bin() 接收一个十进制，转换成二进制 oct() 接收一个十进制，转换成八进制 hex() 接收一个十进制，转换成十六进制 bytes() 字符串转换成字节。第一个传入参数是要转换的字符串，第二个参数按什么编码转换为字节 str() 字节转换成字符串。第一个传入参数是要转换的字节，第二个参数是按什么编码转换成字符串 chr(65) 数字转字母，查看 ASCII 码表 ord(\u0026lsquo;A\u0026rsquo;) 字母转数字，查看 ASCII 码表 compile() 接收.py 文件或字符串作为传入参数，将其编译成 python 字节码 eval() 执行 python 代码，并返回其执行结果。 exec() 执行 python 代码（可以是编译过的，也可以是未编译的），没有返回结果（返回 None） dir() 接收对象作为参数，返回该对象的所有属性和方法 help() 接收对象作为参数，更详细地返回该对象的所有属性和方法 divmod(100,10) 返回一个元组（10,0），第一个元素的 100/10 的商，第二个元素的 100/10 的余数 enumerate() 接收序列化类型的数据，返回一个迭代器（对象） isinstance(object, class) 判断对象是否是某个类的实例 filter() 对可迭代对象中的每一个元素，将其作为实参传入函数（或 lambda 表达式），如果函数返回 False，将该元素丢弃，如果函数返回 True，将该元素添加到 filter 的返回值中。注意 filter 返回的是一个 filter 对象，实际应用中往往需要用 list 或 tuple 将其转换为列表或元组类型 map() 对可迭代的每一个元素，将其作为实参传入函数，将每一次调用函数返回的结果都添加到 map 的返回值中 format() 字符串格式化 frozenset() 转换为不可变的集合 globals() 返回一个字典，包括所有的全局变量与它的值所组成的键值对 locals() 返回一个字典，包括所有的局部变量与它的值所组成的键值对 hash() 对传入参数取哈希值并返回 id() 返回内存地址，可用于查看两个变量是否指向相同一块内存地址 input(\u0026lsquo;please input:\u0026rsquo;) 提示用户输入，返回用户输入的内容（不论输入什么，都转换成字符串类型） issubclass(subclass,class) 查看这个类是否是另一个类的派生类，如果是返回 True，否则返回 False len() 返回长度 max() 接收序列化类型数据，返回其中值最大的元素 min() 返回其中值最小的元素 memoryview() 查看内存地址 next() 通常与迭代器一起使用，用于获取迭代器的下一个元素。 iter() 用于将一个可迭代对象转换为迭代器。 object() 是所有类的基类，创建一个新的对象。 pow(x,y) 求次方，返回 x**y 的结果 pow(x,y,z) 返回 x**y% z 的结果 property() 获取对象的所有属性 range() 获取随机数或随机字符 eg. range (10) 从 0 到 10 的随机数（此处 range () 函数的用途描述有误，range () 函数用于生成一个整数序列，而不是获取随机数或随机字符） repr() 执行传入对象中的_repr_方法 reversed() 对序列化类型数据反向排序，返回一个新的对象。注意与对象的 reverse 方法区别，后者是就地改变对象 sorted() 对序列化类型数据正向排序，返回一个新的对象。注意与对象的 sort 方法区别，后者是就地改变对象 slice() 对序列化类型数据切片，返回一个新的对象 round() 返回四舍五入后的结果 int() 转换为整型 list() 转换为列表类型 set() 转换为集合类型 str() 转换为字符串类型 tuple() 转换为元组类型 type() 返回对象类型 staticmethod() 返回静态方法 super() 返回基类 vars() 返回当前模块中的所有变量 zip() 接收多个序列化类型的数据，对各序列化数据中的元素，按索引位置分类成一个个元组 名片管理系统小练习 需求：\n程序启动，显示名片管理系统欢迎界面，并显示功能菜单 用户用数字选择不同的功能 根据功能选择，执行不同的功能 用户名片需要记录用户的姓名、电话、QQ、邮箱 如果查询到指定的名片，用户可以选择修改或者删除名片 展示菜单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 cards = [{\u0026#39;name\u0026#39;: \u0026#39;mia\u0026#39;, \u0026#39;phone\u0026#39;: \u0026#39;213\u0026#39;, \u0026#39;qq\u0026#39;: \u0026#39;3546\u0026#39;, \u0026#39;email\u0026#39;: \u0026#39;123\u0026#39;}, {\u0026#39;name\u0026#39;: \u0026#39;jack\u0026#39;, \u0026#39;phone\u0026#39;: \u0026#39;124235\u0026#39;, \u0026#39;qq\u0026#39;: \u0026#39;23423434\u0026#39;, \u0026#39;email\u0026#39;: \u0026#39;3465\u0026#39;}, {\u0026#39;name\u0026#39;: \u0026#39;tom\u0026#39;, \u0026#39;phone\u0026#39;: \u0026#39;234\u0026#39;, \u0026#39;qq\u0026#39;: \u0026#39;234\u0026#39;, \u0026#39;email\u0026#39;: \u0026#39;09877\u0026#39;}] def menu(): print(\u0026#39;*\u0026#39;*30) print(\u0026#39;\u0026#39;\u0026#39;欢迎使用【名片管理系统】 1.新建名片 2.显示全部 3.查询名片 0.退出系统\u0026#39;\u0026#39;\u0026#39;) print(\u0026#39;*\u0026#39;*30) def new_card(name,phone,qq,email): user = { \u0026#39;name\u0026#39;:name, \u0026#39;phone\u0026#39;:phone, \u0026#39;qq\u0026#39;:qq, \u0026#39;email\u0026#39;:email } cards.append(user) return True def modify_card(): pass def del_card(): pass def show_card(): for card in cards: print(card) def query_card(kw): for card in cards: for k,v in card.items(): if kw == v: return card return False def quit(): print(\u0026#39;欢迎下次使用【名片管理系统】\u0026#39;) menu() while True: op = input(\u0026#39;请输入你要操作的序号：\u0026#39;) if op==\u0026#39;1\u0026#39;: name = input(\u0026#39;请输入你的姓名：\u0026#39;) phone = input(\u0026#39;请输入你的电话：\u0026#39;) qq = input(\u0026#39;请输入你的qq号：\u0026#39;) email = input(\u0026#39;请输入你的电子邮箱：\u0026#39;) result = new_card(name,phone,qq,email) if result: print(\u0026#39;成功新建名片\u0026#39;) else: print(\u0026#39;请重试\u0026#39;) elif op==\u0026#39;2\u0026#39;: show_card() elif op==\u0026#39;3\u0026#39;: kw = input(\u0026#39;请输入查询的关键字：\u0026#39;) result = query_card(kw) if result: print(result) op2 = input(\u0026#39;输入4修改名片，输入5删除名片：\u0026#39;) if op2 ==\u0026#39;4\u0026#39;: modify_card() if op2==\u0026#39;5\u0026#39;: del_card() else: print(\u0026#39;没有查到相关信息\u0026#39;) elif op==\u0026#39;0\u0026#39;: quit() break else: print(\u0026#39;请重试\u0026#39;) 第九章：模块 模块的导入 • 模块 就好比是 工具包，要想使用这个工具包中的工具，就需要 导入 import 这个模块\n• 每一个以扩展名 py 结尾的 python 源代码文件都是一个 模块\n• 在模块中定义的 全局变量 、 函数 都是模块能够提供给外界直接使用的工具\n可以只导入一个模块中的部分函数，可以防止导入函数过多导致的重名问题\n包的使用 • 包是Python模块的一种组织形式，将多个模块组合在一起，形成一个大的Python工具库。包通常是一个拥有__init__.py文件的目录，它定义了包的属性和方法。\n常见的标准库 模块 用途 os os 模块提供了许多与操作系统交互的函数，例如创建、移动和删除文件和目录，以及访问环境变量等。 sys sys 模块提供了与 Python 解释器和系统相关的功能，例如解释器的版本和路径，以及与 stdin、stdout 和 stderr 相关的信息。 time time 模块提供了处理时间的函数，例如获取当前时间、格式化日期和时间、计时等。 datetime datetime 模块提供了更高级的日期和时间处理函数，例如处理时区、计算时间差、计算日期差等。 random random 模块提供了生成随机数的函数，例如生成随机整数、浮点数、序列等。 math math 模块提供了数学函数，例如三角函数、对数函数、指数函数、常数等。 re re 模块提供了正则表达式处理函数，可以用于文本搜索、替换、分割等。 json json 模块提供了 JSON 编码和解码函数，可以将 Python 对象转换为 JSON 格式，并从 JSON 格式中解析出 Python 对象。 urllib urllib 模块提供了访问网页和处理 URL 的功能，包括下载文件、发送 POST 请求、处理 cookies 等。 re库的正则表达式 1 2 3 4 5 import re ## 用正则表达式匹配时，要在正则表达式前面加个r，否则会报错 result = re.match(r\u0026#39;\\d+\u0026#39;, \u0026#39;1234abcd\u0026#39;) print(result) # 输出；\u0026lt;re.Match object; span=(0, 4), match=\u0026#39;1234\u0026#39;\u0026gt; time库 1 2 3 4 5 6 7 8 9 import time print(time.time()) # 获取当前时间戳，输出：1737124413.686656 print(time.localtime()) # 获取结构化的当前时间，输出：time.struct_time(tm_year=2025, tm_mon=1, tm_mday=17, tm_hour=22, tm_min=33, tm_sec=33, tm_wday=4, tm_yday=17, tm_isdst=0) ## 百分号加某个字母表示哪个时间是规定好的 s = time.strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;, time.localtime()) print(s) # 输出：2025-01-17 22:33:33 turtle绘图库 1 2 3 4 5 6 7 8 import turtle pen = turtle.Turtle() pen.speed(0) step = 1 while True: pen.forward(step) pen.left(61) step += 1 第十章：文件及IO操作 文件的打开模式 mode 解释 r 只读【默认模式，文件必须存在，不存在则抛出异常】 w 只写，写之前会清空文件的内容，如果文件不存在，会创建新文件 a 追加的方式，在原本内容中继续写，如果文件不存在，则会创建新文件 r+ 可读可写 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 b rb、wb、ab、rb+、wb+、ab + 意义和上面一样，用于二进制文件操作 文件读取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 ## 打开文件 f = open(\u0026#39;./text.txt\u0026#39;, mode=\u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) ## 读取文件 context = f.read() print(context) ## 输出： ## 你好，world ## welcome ## to my ## 世界 ## 关闭文件 f.close() ## ---------------------------------------- ## 也可以只读文件的部分内容，避免读取文件过大导致崩溃 ## 打开文件 f = open(\u0026#39;./text.txt\u0026#39;, mode=\u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) ## 读取文件 context = f.read(4) print(context) # 输出：你好，w ## 关闭文件 f.close() ## ---------------------------------------- ## 还可以按行读，将存成列表形式 ## 打开文件 f = open(\u0026#39;./text.txt\u0026#39;, mode=\u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) ## 读取文件 context = f.readlines() # readline()就是只读一行 print(context) # 输出：[\u0026#39;你好，world\\n\u0026#39;, \u0026#39;welcome\\n\u0026#39;, \u0026#39;to my\\n\u0026#39;, \u0026#39;世界\u0026#39;] ## 关闭文件 f.close() ## ---------------------------------------- ## 假设同目录下有一个名为text.txt的文件，内容为： 你好，world welcome to my 世界 文件写入和追加 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ## 写入内容 ## 打开文件 f = open(\u0026#39;./text.txt\u0026#39;, mode=\u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) ## 写入文件 context = f.write(\u0026#39;你好，世界\\nHello,World\u0026#39;) ## 关闭文件 f.close() ## 文件写入后的效果： 你好，世界 Hello,World ## ----------------------------------------- ## 追加内容 ## 打开文件 f = open(\u0026#39;./text.txt\u0026#39;, mode=\u0026#39;a\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) ## 写入文件 context = f.write(\u0026#39;\\n我是追加的内容\u0026#39;) ## 关闭文件 f.close() ## 文件追加后的效果： 你好，世界 Hello,World 我是追加的内容 with语句 用with语句就不需要手动关闭文件了\n1 2 3 4 with open(\u0026#39;./text.txt\u0026#39;, mode=\u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: # 读取文件 context = f.read() print(context) csv表格文件的读取和写入 现有一个Test.csv文件，内容如图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ## 用普通文件的读取方式 with open(\u0026#39;./Test.csv\u0026#39;, mode=\u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: context = f.read() print(context) ## 输出： A1,B1, ,,C2 ## ----------------------------------------------------- ## 用csv库的读取方式 import csv with open(\u0026#39;./Test.csv\u0026#39;, mode=\u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: cf = csv.reader(f) # print(type(cf)) # 输出：\u0026lt;class \u0026#39;_csv.reader\u0026#39;\u0026gt; for i in cf: print(i) ## 输出： [\u0026#39;A1\u0026#39;, \u0026#39;B1\u0026#39;, \u0026#39;\u0026#39;] [\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;C2\u0026#39;] ## ----------------------------------------------------- ## 用csv库的写入方式 import csv ## 不写newline=\u0026#39;\u0026#39;时，写入的每行之间都会空一行 with open(\u0026#39;./Test.csv\u0026#39;, mode=\u0026#39;a\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;, newline=\u0026#39;\u0026#39;) as f: cf = csv.writer(f) # 一次写入多行可以用二维列表 lista = [[\u0026#39;A3\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;C3\u0026#39;], [\u0026#39;\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;\u0026#39;]] cf.writerows(lista) ## 此时的文件内容为： A1,B1, ,,C2 A3,,C3 ,B4, 第十一章：面向对象程序设计 类的定义 类的创建与实例化 1 2 3 4 5 class Animal(object): # object是基类，表示Animal类继承自object，不写时默认为object pass animal = Animal() # 类的实例化 print(type(animal)) # 输出：\u0026lt;class \u0026#39;__main__.Animal\u0026#39;\u0026gt; 实例属性 1 2 3 4 5 6 7 8 9 10 11 12 13 class Animal(object): # object是基类 def __init__(self, breed, name): # 初始化函数（构造函数），实例化时自动调用 self.breed = breed # 实例属性 self.name = name # 实例属性 animal1 = Animal(\u0026#39;狗\u0026#39;, \u0026#39;小白\u0026#39;) # 类的实例化 print(animal1.breed, animal1.name) # 输出：狗 小白 ## __dict__方法用于获取实例对象的所有属性，以字典形式返回 print(animal1.__dict__) # 输出：{\u0026#39;breed\u0026#39;: \u0026#39;狗\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;小白\u0026#39;} animal2 = Animal(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;) # 有构造函数时，实例化的时候就不能空着不写，空着会报错 ## 所以即使是填\u0026#39;\u0026#39;也不能空着直接写Animal()，默认属性有几个就要写几个，空一个都会报错 类属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Player(): num = 0 # 类属性 def __init__(self, name): self.name = name # 实例属性 Player.num += 1 print(\u0026#39;当前玩家有%d个玩家\u0026#39; % Player.num) # 输出：当前玩家有0个玩家 xiaoming = Player(\u0026#39;小明\u0026#39;) print(\u0026#39;新增玩家\u0026#39;, xiaoming.name) # 输出：新增玩家 小明 print(\u0026#39;当前玩家有%d个玩家\u0026#39; % Player.num) # 输出：当前玩家有1个玩家 ## ------------------------------------------------------------- ## 类属性的常见用法演示 class Player(): num = 0 levelMax = 100 stage = [\u0026#39;初级\u0026#39;, \u0026#39;中级\u0026#39;, \u0026#39;高级\u0026#39;, \u0026#39;未知\u0026#39;] def __init__(self, name, level, stage): self.name = name self.level = level self.stage = stage Player.num += 1 if level \u0026gt; Player.levelMax: raise Exception(\u0026#39;等级异常\u0026#39;) if stage not in Player.stage: raise Exception(\u0026#39;阶段异常\u0026#39;) try: herta = Player(\u0026#39;沉鱼落雁\u0026#39;, 100, \u0026#39;未知\u0026#39;) print(\u0026#39;登入成功，登录用户:%s 当前等级:%d 所处阶段:%s\u0026#39; % (herta.name, herta.level, herta.stage)) wolf = Player(\u0026#39;从不作弊\u0026#39;, 999, \u0026#39;初级\u0026#39;) except Exception as e: print(\u0026#39;登录失败\u0026#39;, e) ## 运行结果： 登入成功，登录用户:沉鱼落雁 当前等级:100 所处阶段:未知 登录失败 等级异常 实例方法 1 2 3 4 5 6 7 8 9 10 class Player(): def __init__(self, name, gender): self.name = name self.gender = gender def show(self): # 实例的方法 print(\u0026#39;当前玩家：%s，性别：%s\u0026#39; % (self.name, self.gender)) xiaoming = Player(\u0026#39;小明\u0026#39;, \u0026#39;男\u0026#39;) xiaoming.show() # 输出：当前玩家：小明，性别：男 类方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Player(): num = 0 def __init__(self, name, gender): self.name = name self.gender = gender Player.num += 1 @classmethod def get_num(cls): # 类方法 return cls.num print(\u0026#39;当前玩家数：\u0026#39;, Player.get_num()) # 输出：当前玩家数： 0 xiaoming = Player(\u0026#39;小明\u0026#39;, \u0026#39;男\u0026#39;) print(\u0026#39;当前玩家数：\u0026#39;, Player.get_num()) # 输出：当前玩家数： 1 静态方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Player(): def __init__(self, name, age): self.name = name self.age = age @staticmethod def isvalid(**kwargs): # 静态方法 if kwargs[\u0026#39;age\u0026#39;] \u0026gt;= 18: return True return False infos = {\u0026#39;name\u0026#39;: \u0026#39;小明\u0026#39;, \u0026#39;age\u0026#39;: 16} if Player.isvalid(**infos): xiaoming = Player(**infos) print(xiaoming.name, \u0026#39;成功登录\u0026#39;) else: print(\u0026#39;去学习\u0026#39;) ## 运行结果： 去学习 类的继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Player(): # 父类 def __init__(self, name): self.name = name def show(self): print(\u0026#39;低贱的普通玩家：%s\u0026#39; % self.name) class VIP(Player): # 子类 # 构造函数重写 def __init__(self, name, status): # 调用父类的构造函数 super().__init__(name) self.status = status # 实例方法重写 def show(self): print(\u0026#39;至高无上的尊贵玩家：%s\u0026#39; % self.name) Istar = VIP(\u0026#39;Istar\u0026#39;, \u0026#39;尊贵的VIP\u0026#39;) print(Istar.name, Istar.status) # 输出：Istar 尊贵的VIP Istar.show() # 输出：至高无上的尊贵玩家：Istar 多态 在编程中，多态是指同一个操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。简单来说，就是用同一种方式去调用不同对象的方法，这些方法可以根据对象的类型做出不同的响应。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Animal(object): # 多态可以大致理解为：父类当形参，子类当实参 # 父类只是表明有这么个方法，具体实现方式靠子类重写 def speak(self): print(\u0026#34;动物叫\u0026#34;) class Dog(Animal): def speak(self): print(\u0026#34;狗叫\u0026#34;) class Cat(Animal): def speak(self): print(\u0026#34;猫叫\u0026#34;) dog = Dog() cat = Cat() dog.speak() # 输出：狗叫 cat.speak() # 输出：猫叫 封装 在python中，在变量前加一个_表示这是个受保护的变量，加两个_表示这是个私有变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class User(object): def __init__(self, name, age): self._name = name # 受保护的变量 self.__age = age # 私有变量 star = User(\u0026#39;星\u0026#39;, 2) print(star._name) # 输出：星 print(star.__age) # 报错 ## --------------------------------------------------- ## 封装后的修改和获取 class User(object): def __init__(self, name, age): self.__name = name self.__age = age def get_name(self): return self.__name def get_age(self): return self.__age def set_name(self, name): if not isinstance(name, str): raise TypeError(\u0026#39;Name must be str\u0026#39;) self.__name = name def set_age(self, age): if not isinstance(age, int): raise TypeError(\u0026#39;Age must be int\u0026#39;) self.__age = age star = User(\u0026#39;星\u0026#39;, 2) print(star.get_age()) # 输出：2 star.set_age(3) print(star.get_age()) # 输出：3 ## --------------------------------------------------- ## 运用装饰器把函数当成变量使用： \u0026#34;\u0026#34;\u0026#34; 用法： @property def 变量名(): # 获取变量 pass @变量名.setter def 变量名(): # 修改变量 pass ## 注：变量名必须一致 \u0026#34;\u0026#34;\u0026#34; class User(object): def __init__(self, name, age): self.__name = name self.__age = age @property def 名字(self): return self.__name @property def 年龄(self): return self.__age @名字.setter def 名字(self, name): # 函数名必须与对应@property的函数名一致 if not isinstance(name, str): raise TypeError(\u0026#39;Name must be str\u0026#39;) self.__name = name @年龄.setter def 年龄(self, age): # 函数名必须与对应@property的函数名一致 if not isinstance(age, int): raise TypeError(\u0026#39;Age must be int\u0026#39;) self.__age = age star = User(\u0026#39;星\u0026#39;, 2) print(star.名字) # 输出：星 star.年龄 = 3 print(star.年龄) # 输出：3 第十二章：界面开发 第三方库wxpython 首先要在终端输入 pip install wxpython下载wxpython库\n使用时使用import wx导入wxpython库\n简单布局 一个普通的窗口布局如下图所示\n下面是简单演示wxpython库的部分功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import wx ## 定义点击事件 def onClick(event): print(\u0026#39;btn被点击\u0026#39;) ## 创建应用程序对象 app = wx.App() ## 创建窗口,size表示大小，pos表示位置 frm = wx.Frame(None, title=\u0026#39;窗口学习\u0026#39;, size=(500, 400), pos=(500, 200)) ## 显示窗口 frm.Show() ## 在frm窗口上创建面板 pl = wx.Panel(frm, size=(500, 400)) ## 显示面板 pl.Show() ## 在pl面板上创建静态文本 staticText = wx.StaticText(pl, label=\u0026#39;欢迎学习Python！\u0026#39;, pos=(200, 150)) ## 在pl面板上创建按钮 btn = wx.Button(pl, label=\u0026#39;点击\u0026#39;, pos=(200, 200)) ## 给frm窗口绑定点击btn按钮的事件 frm.Bind(wx.EVT_BUTTON, onClick, btn) ## 进入主循环，让窗口一直显示 app.MainLoop() 运行效果：\n窗口类 接下来用面向对象的思想来写窗口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import wx class MyFrame(wx.Frame): # 构造方法 def __init__(self): wx.Frame.__init__(self, None, title=\u0026#39;窗口类的学习\u0026#39;) # 创建面板 pl = wx.Panel(self) # 创建静态文本 staticText = wx.StaticText(pl, label=\u0026#39;欢迎学习Python！\u0026#39;) # 创建按钮 btn = wx.Button(pl, label=\u0026#39;按钮\u0026#39;, pos=(100,100)) ## 创建应用程序对象 app = wx.App() ## 创建窗口 frm = MyFrame() ## 显示窗口 frm.Show() 运行效果：\n抽奖器练习 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import wx import random class MyFrame(wx.Frame): # 构造方法 def __init__(self): wx.Frame.__init__(self, None, title=\u0026#39;抽奖器\u0026#39;, size=(500, 200), pos=(500, 300)) # 创建面板 self.pl = wx.Panel(self, size=(500, 200), pos=(0, 0)) # 设置背景颜色 self.SetBackgroundColour((255, 255, 90)) # 创建静态文本，文本高度设置为0时，会根据字体大小自动选择合适大小，style=wx.TE_CENTRE表示文字居中 self.staticText = wx.StaticText(self.pl, label=\u0026#39;欢迎使用抽奖器！\u0026#39;, pos=(0, 30), size=(500, 0), style=wx.TE_CENTRE) # 创建字体 # Font()函数的参数分别为：字体大小，字体包，字体风格，字体加粗 font = wx.Font(26, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD) # 将静态文本设置为创建的字体 self.staticText.SetFont(font) # 创建按钮 self.btn1 = wx.Button(self.pl, label=\u0026#39;开始抽奖\u0026#39;, pos=(150,100)) self.btn2 = wx.Button(self.pl, label=\u0026#39;停止抽奖\u0026#39;, pos=(250,100)) # 绑定事件 self.Bind(wx.EVT_BUTTON, self.onClick, self.btn1) self.Bind(wx.EVT_BUTTON, self.stop_update, self.btn2) def onClick(self, event): self.timer = wx.Timer(self) # 创建一个定时器 self.Bind(wx.EVT_TIMER, self.update_name, self.timer) self.timer.Start(100) # 每隔100毫秒调用一次绑定的函数 # 此处不用担心多次点击造成开启多个定时器的问题 def update_name(self, event): # 随机设置面板内容 self.staticText.SetLabelText(str(random.randint(1, 100))) def stop_update(self, event): try: self.timer.Stop() # 关闭定时器 except: print(\u0026#39;请先开始抽奖\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: # 表示Python程序的主入口 # 创建应用程序对象 app = wx.App() # 创建窗口 frm = MyFrame() # 显示窗口 frm.Show() # 让窗口一直显示 app.MainLoop() 效果：\n","date":"2024-03-27T13:56:38+08:00","permalink":"https://IAmYuanyu.github.io/p/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Python基础学习笔记"},{"content":"1. Vue3简介 2020年9月18日，Vue.js发布版3.0版本，代号：One Piece（n\n经历了：4800+次提交、40+个RFC、600+次PR、300+贡献者\n官方发版地址：Release v3.0.0 One Piece · vuejs/core\n截止2023年10月，最新的公开版本为：3.3.4\n1.1. 【性能的提升】 打包大小减少41%。\n初次渲染快55%, 更新渲染快133%。\n内存减少54%。\n1.2.【 源码的升级】 使用Proxy代替defineProperty实现响应式。\n重写虚拟DOM的实现和Tree-Shaking。\n1.3. 【拥抱TypeScript】 Vue3可以更好的支持TypeScript。 1.4. 【新的特性】 Composition API（组合API）：\nsetup\nref与reactive\ncomputed与watch\n\u0026hellip;\u0026hellip;\n新的内置组件：\nFragment\nTeleport\nSuspense\n\u0026hellip;\u0026hellip;\n其他改变：\n新的生命周期钩子\ndata 选项应始终被声明为一个函数\n移除keyCode支持作为 v-on 的修饰符\n\u0026hellip;\u0026hellip;\n2. 创建Vue3工程 2.1. 【基于 vue-cli 创建】 点击查看官方文档\n备注：目前vue-cli已处于维护模式，官方推荐基于 Vite 创建项目。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ### 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上 vue --version ### 安装或者升级你的@vue/cli npm install -g @vue/cli ### 执行创建命令 vue create vue_test ### 随后选择3.x ### Choose a version of Vue.js that you want to start the project with (Use arrow keys) ### \u0026gt; 3.x ### 2.x ### 启动 cd vue_test npm run serve 2.2. 【基于 vite 创建】(推荐) vite 是新一代前端构建工具，官网地址：https://vitejs.cn，vite的优势如下：\n轻量快速的热重载（HMR），能实现极速的服务启动。 对 TypeScript、JSX、CSS 等支持开箱即用。 真正的按需编译，不再等待整个应用编译完成。 webpack构建 与 vite构建对比图如下： 具体操作如下（点击查看官方文档） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ### 1.创建命令 npm create vue@latest ### 2.具体配置 ### 配置项目名称 √ Project name: vue3_test ### 是否添加TypeScript支持 √ Add TypeScript? Yes ### 是否添加JSX支持 √ Add JSX Support? No ### 是否添加路由环境 √ Add Vue Router for Single Page Application development? No ### 是否添加pinia环境 √ Add Pinia for state management? No ### 是否添加单元测试 √ Add Vitest for Unit Testing? No ### 是否添加端到端测试方案 √ Add an End-to-End Testing Solution? » No ### 是否添加ESLint语法检查 √ Add ESLint for code quality? Yes ### 是否添加Prettiert代码格式化 √ Add Prettier for code formatting? No 2.2.1. 安装依赖 创建后用vscode打开，发现有的文件冒红，可以在终端输入npm i安装依赖后重新启动来解决\n自己动手编写一个App组件（下面内容是写在src文件夹下的App.vue中的）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;你好啊！\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { name:\u0026#39;App\u0026#39; //组件名 } \u0026lt;/script\u0026gt; \u0026lt;!-- scoped表示局部样式，只会修改该vue文件中的元素样式 --\u0026gt; \u0026lt;style scoped\u0026gt; .app { background-color: #ddd; box-shadow: 0 0 10px; border-radius: 10px; padding: 20px; } \u0026lt;/style\u0026gt; 安装官方推荐的vscode插件：\n总结：\nVite 项目中，index.html 是项目的入口文件，在项目最外层。 加载index.html后，Vite 解析 \u0026lt;script type=\u0026quot;module\u0026quot; src=\u0026quot;xxx\u0026quot;\u0026gt; 指向的JavaScript。 Vue3**中是通过 **createApp 函数创建一个应用实例。 2.2.2. 如何运行 查看package.json文件\n发现是dev，则在终端输入npm run dev后，点开生成的链接即可查看\n若觉得每次手动打开浏览器麻烦，可以将\u0026quot;dev\u0026quot;: \u0026quot;vite\u0026quot;改为\u0026quot;dev\u0026quot;: \u0026quot;vite --open\u0026quot;\n此时，每次输入运行命令后将自动打开浏览器\n2.2.3. 如何停止运行 在终端按快捷键ctrl + c停止运行\n2.3. 【一个简单的效果】 Vue3向下兼容Vue2语法，且Vue3中的模板中可以没有根标签\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;姓名：{{name}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{age}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;年龄+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;showTel\u0026#34;\u0026gt;点我查看联系方式\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { name:\u0026#39;App\u0026#39;, data() { return { name:\u0026#39;张三\u0026#39;, age:18, tel:\u0026#39;13888888888\u0026#39; } }, methods:{ changeName(){ this.name = \u0026#39;zhang-san\u0026#39; }, changeAge(){ this.age += 1 }, showTel(){ alert(this.tel) } }, } \u0026lt;/script\u0026gt; 3. Vue3核心语法 3.1. 【OptionsAPI 与 CompositionAPI】 Vue2的API设计是Options（配置）风格的。 Vue3的API设计是Composition（组合）风格的。 Options API 的弊端 Options类型的 API，数据、方法、计算属性等，是分散在：data、methods、computed中的，若想新增或者修改一个需求，就需要分别修改：data、methods、computed，不便于维护和复用。\nComposition API 的优势 可以用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。\n说明：以上四张动图原创作者：大帅老猿\n3.2. 【拉开序幕的 setup】 setup 概述 setup是Vue3中一个新的配置项，值是一个函数，它是 Composition API “表演的舞台”，组件中所用到的：数据、方法、计算属性、监视\u0026hellip;\u0026hellip;等等，均配置在setup中。\n特点如下：\nsetup函数返回的对象中的内容，可直接在模板中使用。 setup中访问this是undefined。 setup函数会在beforeCreate之前调用，它是“领先”所有钩子执行的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;姓名：{{name}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{age}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;年龄+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;showTel\u0026#34;\u0026gt;点我查看联系方式\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { name:\u0026#39;Person\u0026#39;, setup(){ // 数据，原来写在data中（注意：此时的name、age、tel数据都不是响应式数据） let name = \u0026#39;张三\u0026#39; let age = 18 let tel = \u0026#39;13888888888\u0026#39; // 方法，原来写在methods中 function changeName(){ name = \u0026#39;zhang-san\u0026#39; //注意：此时这么修改name页面是不变化的 console.log(name) } function changeAge(){ age += 1 //注意：此时这么修改age页面是不变化的 console.log(age) } function showTel(){ alert(tel) } // 返回一个对象，对象中的内容，模板中可以直接使用 return {name,age,tel,changeName,changeAge,showTel} } } \u0026lt;/script\u0026gt; setup 的返回值 若返回一个对象：则对象中的：属性、方法等，在模板中均可以直接使用**（重点关注）。** 若返回一个函数：则可以自定义渲染内容，代码如下： 1 2 3 setup(){ return ()=\u0026gt; \u0026#39;你好啊！\u0026#39; } setup 与 Options API 的关系 Vue2 的配置（data、methos\u0026hellip;\u0026hellip;）中可以访问到 setup中的属性、方法。 但在setup中不能访问到Vue2的配置（data、methos\u0026hellip;\u0026hellip;）。 如果与Vue2冲突，则setup优先。 setup 语法糖 setup函数有一个语法糖，这个语法糖，可以让我们把setup独立出去，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;姓名：{{name}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{age}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changAge\u0026#34;\u0026gt;年龄+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;showTel\u0026#34;\u0026gt;点我查看联系方式\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { name:\u0026#39;Person\u0026#39;, } \u0026lt;/script\u0026gt; \u0026lt;!-- 下面的写法是setup语法糖 --\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; console.log(this) //undefined // 数据（注意：此时的name、age、tel都不是响应式数据） let name = \u0026#39;张三\u0026#39; let age = 18 let tel = \u0026#39;13888888888\u0026#39; // 方法 function changName(){ name = \u0026#39;李四\u0026#39;//注意：此时这么修改name页面是不变化的 } function changAge(){ console.log(age) age += 1 //注意：此时这么修改age页面是不变化的 } function showTel(){ alert(tel) } \u0026lt;/script\u0026gt; 扩展：上述代码，还需要编写一个不写setup的script标签，去指定组件名字，比较麻烦，我们可以借助vite中的插件简化\n第一步：npm i vite-plugin-vue-setup-extend -D 第二步：vite.config.ts 1 2 3 4 5 6 import { defineConfig } from \u0026#39;vite\u0026#39; import VueSetupExtend from \u0026#39;vite-plugin-vue-setup-extend\u0026#39; export default defineConfig({ plugins: [ VueSetupExtend() ] }) 第三步：\u0026lt;script setup lang=\u0026quot;ts\u0026quot; name=\u0026quot;Person\u0026quot;\u0026gt; 3.3. 【ref 创建：基本类型的响应式数据】 **作用：**定义响应式变量。 语法：let xxx = ref(初始值)。 **返回值：**一个RefImpl的实例对象，简称ref对象或ref，ref对象的value属性是响应式的。 注意点： JS中操作数据需要：xxx.value，但模板中不需要.value，直接使用即可。 对于let name = ref('张三')来说，name不是响应式的，name.value是响应式的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;姓名：{{name}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{age}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;年龄+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;showTel\u0026#34;\u0026gt;点我查看联系方式\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Person\u0026#34;\u0026gt; import {ref} from \u0026#39;vue\u0026#39; // name和age是一个RefImpl的实例对象，简称ref对象，它们的value属性是响应式的。 let name = ref(\u0026#39;张三\u0026#39;) let age = ref(18) // tel就是一个普通的字符串，不是响应式的 let tel = \u0026#39;13888888888\u0026#39; function changeName(){ // JS中操作ref对象时候需要.value name.value = \u0026#39;李四\u0026#39; console.log(name.value) // 注意：name不是响应式的，name.value是响应式的，所以如下代码并不会引起页面的更新。 // name = ref(\u0026#39;zhang-san\u0026#39;) } function changeAge(){ // JS中操作ref对象时候需要.value age.value += 1 console.log(age.value) } function showTel(){ alert(tel) } \u0026lt;/script\u0026gt; 3.4. 【reactive 创建：对象类型的响应式数据】 作用：定义一个响应式对象（基本类型不要用它，要用ref，否则报错） 语法：let 响应式对象= reactive(源对象)。 **返回值：**一个Proxy的实例对象，简称：响应式对象。 注意点：reactive定义的响应式数据是“深层次”的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;汽车信息：一台{{ car.brand }}汽车，价值{{ car.price }}万\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;游戏列表：\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- 在key前面加:才能将\u0026#34;\u0026#34;内的内容识别为变量 --\u0026gt; \u0026lt;!-- :其实是v-bind:的简写 --\u0026gt; \u0026lt;li v-for=\u0026#34;g in games\u0026#34; :key=\u0026#34;g.id\u0026#34;\u0026gt;{{ g.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h2\u0026gt;测试：{{obj.a.b.c.d}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeCarPrice\u0026#34;\u0026gt;修改汽车价格\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeFirstGame\u0026#34;\u0026gt;修改第一游戏\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;测试\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import { reactive } from \u0026#39;vue\u0026#39; // 数据 let car = reactive({ brand: \u0026#39;奔驰\u0026#39;, price: 100 }) let games = reactive([ { id: \u0026#39;ahsgdyfa01\u0026#39;, name: \u0026#39;英雄联盟\u0026#39; }, { id: \u0026#39;ahsgdyfa02\u0026#39;, name: \u0026#39;王者荣耀\u0026#39; }, { id: \u0026#39;ahsgdyfa03\u0026#39;, name: \u0026#39;原神\u0026#39; } ]) let obj = reactive({ a:{ b:{ c:{ d:666 } } } }) function changeCarPrice() { car.price += 10 } function changeFirstGame() { games[0].name = \u0026#39;流星蝴蝶剑\u0026#39; } function test(){ obj.a.b.c.d = 999 } \u0026lt;/script\u0026gt; 3.5. 【ref 创建：对象类型的响应式数据】 其实ref接收的数据可以是：基本类型、对象类型。 若ref接收的是对象类型，内部其实也是调用了reactive函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;汽车信息：一台{{ car.brand }}汽车，价值{{ car.price }}万\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;游戏列表：\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;g in games\u0026#34; :key=\u0026#34;g.id\u0026#34;\u0026gt;{{ g.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h2\u0026gt;测试：{{obj.a.b.c.d}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeCarPrice\u0026#34;\u0026gt;修改汽车价格\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeFirstGame\u0026#34;\u0026gt;修改第一游戏\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;测试\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import { ref } from \u0026#39;vue\u0026#39; // 数据 let car = ref({ brand: \u0026#39;奔驰\u0026#39;, price: 100 }) let games = ref([ { id: \u0026#39;ahsgdyfa01\u0026#39;, name: \u0026#39;英雄联盟\u0026#39; }, { id: \u0026#39;ahsgdyfa02\u0026#39;, name: \u0026#39;王者荣耀\u0026#39; }, { id: \u0026#39;ahsgdyfa03\u0026#39;, name: \u0026#39;原神\u0026#39; } ]) let obj = ref({ a:{ b:{ c:{ d:666 } } } }) console.log(car) function changeCarPrice() { car.value.price += 10 } function changeFirstGame() { games.value[0].name = \u0026#39;流星蝴蝶剑\u0026#39; } function test(){ obj.value.a.b.c.d = 999 } \u0026lt;/script\u0026gt; 3.6. 【ref 对比 reactive】 宏观角度看：\nref用来定义：基本类型数据、对象类型数据；\nreactive用来定义：对象类型数据。\n区别： ref创建的变量必须使用.value（可以使用Vue - Official插件自动添加.value）。\nreactive重新分配一个新对象，会失去响应式（可以使用Object.assign去整体替换）。\n使用原则： 若需要一个基本类型的响应式数据，必须使用ref。 若需要一个响应式对象，层级不深，ref、reactive都可以。 若需要一个响应式对象，且层级较深，推荐使用reactive。 3.7. 【toRefs 与 toRef】 作用：将一个响应式对象中的每一个属性，转换为ref对象。 备注：toRefs与toRef功能一致，但toRefs可以批量转换。 语法如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;姓名：{{person.name}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{person.age}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;性别：{{person.gender}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;修改年龄\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeGender\u0026#34;\u0026gt;修改性别\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {ref,reactive,toRefs,toRef} from \u0026#39;vue\u0026#39; // 数据 let person = reactive({name:\u0026#39;张三\u0026#39;, age:18, gender:\u0026#39;男\u0026#39;}) // 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力 // 不使用toRefs直接解构，属性会丢失响应式的能力 let {name,gender} = toRefs(person) // 注：此时修改name和gender时，person.name和person.gender也会跟着改变！！！ // 通过toRef将person对象中的gender属性取出，且依然保持响应式的能力 let age = toRef(person,\u0026#39;age\u0026#39;) // 方法 function changeName(){ name.value += \u0026#39;~\u0026#39; } function changeAge(){ age.value += 1 } function changeGender(){ gender.value = \u0026#39;女\u0026#39; } \u0026lt;/script\u0026gt; 3.8. 【computed】 作用：根据已有数据计算出新数据（和Vue2中的computed作用一致）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;!-- v-model是双向绑定，v-bind:是单向绑定 --\u0026gt; \u0026lt;!-- 双向绑定后，改变input中的内容时，这个变量的值也会被修改 --\u0026gt; 姓：\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;firstName\u0026#34;\u0026gt; \u0026lt;br\u0026gt; 名：\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;lastName\u0026#34;\u0026gt; \u0026lt;br\u0026gt; 全名：\u0026lt;span\u0026gt;{{fullName}}\u0026lt;/span\u0026gt; \u0026lt;br\u0026gt; \u0026lt;button @click=\u0026#34;changeFullName\u0026#34;\u0026gt;全名改为：li-si\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;App\u0026#34;\u0026gt; import {ref,computed} from \u0026#39;vue\u0026#39; let firstName = ref(\u0026#39;zhang\u0026#39;) let lastName = ref(\u0026#39;san\u0026#39;) // 计算属性——只读取，不修改 /* let fullName = computed(()=\u0026gt;{ return firstName.value + \u0026#39;-\u0026#39; + lastName.value }) */ // 计算属性——既读取又修改 let fullName = computed({ // 读取 get(){ return firstName.value + \u0026#39;-\u0026#39; + lastName.value }, // 修改 set(val){ console.log(\u0026#39;有人修改了fullName\u0026#39;,val) firstName.value = val.split(\u0026#39;-\u0026#39;)[0] lastName.value = val.split(\u0026#39;-\u0026#39;)[1] // 也可以用解构数组： // const [str1, str2] = val.split(\u0026#39;-\u0026#39;) // lastname.value = str1 // firstname.value = str2 } }) function changeFullName(){ // 此时不是直接修改fullName.value的值，而是把\u0026#39;li-si\u0026#39;传给fullName的set方法 // 所以此时，set(val)中的val就是\u0026#39;li-si\u0026#39; fullName.value = \u0026#39;li-si\u0026#39; } \u0026lt;/script\u0026gt; 3.9.【watch】 作用：监视数据的变化（和Vue2中的watch作用一致） 特点：Vue3中的watch只能监视以下四种数据： ref定义的数据。 reactive定义的数据。 函数返回一个值（getter函数）。 一个包含上述内容的数组。 我们在Vue3中使用watch的时候，通常会遇到以下几种情况：\n* 情况一 监视ref定义的【基本类型】数据：直接写数据名即可，监视的是其value值的改变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;情况一：监视【ref】定义的【基本类型】数据\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;当前求和为：{{sum}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeSum\u0026#34;\u0026gt;点我sum+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {ref,watch} from \u0026#39;vue\u0026#39; // 数据 let sum = ref(0) // 方法 function changeSum(){ sum.value += 1 } // 监视，情况一：监视【ref】定义的【基本类型】数据 const stopWatch = watch(sum, (newValue,oldValue)=\u0026gt;{ console.log(\u0026#39;sum变化了\u0026#39;,newValue,oldValue) if(newValue \u0026gt;= 10){ // 新值大于等于10时停止监视 stopWatch() // 函数名与变量名一致 } }) \u0026lt;/script\u0026gt; * 情况二 监视ref定义的【对象类型】数据：直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。\n注意：\n若修改的是ref定义的对象中的属性，newValue 和 oldValue 都是新值，因为它们是同一个对象。\n若修改整个ref定义的对象，newValue 是新值， oldValue 是旧值，因为不是同一个对象了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;情况二：监视【ref】定义的【对象类型】数据\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;姓名：{{ person.name }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{ person.age }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;修改年龄\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changePerson\u0026#34;\u0026gt;修改整个人\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {ref,watch} from \u0026#39;vue\u0026#39; // 数据 let person = ref({ name:\u0026#39;张三\u0026#39;, age:18 }) // 方法 function changeName(){ person.value.name += \u0026#39;~\u0026#39; } function changeAge(){ person.value.age += 1 } function changePerson(){ person.value = {name:\u0026#39;李四\u0026#39;,age:90} } /* 监视，情况一：监视【ref】定义的【对象类型】数据，监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视 watch的第一个参数是：被监视的数据 watch的第二个参数是：监视的回调 watch的第三个参数是：配置对象（deep、immediate等等.....） */ watch(person,(newValue,oldValue)=\u0026gt;{ console.log(\u0026#39;person变化了\u0026#39;,newValue,oldValue) },{deep:true}) \u0026lt;/script\u0026gt; * 情况三 监视reactive定义的【对象类型】数据，且默认开启了深度监视。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;情况三：监视【reactive】定义的【对象类型】数据\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;姓名：{{ person.name }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{ person.age }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;修改年龄\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changePerson\u0026#34;\u0026gt;修改整个人\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;h2\u0026gt;测试：{{obj.a.b.c}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;修改obj.a.b.c\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {reactive,watch} from \u0026#39;vue\u0026#39; // 数据 let person = reactive({ name:\u0026#39;张三\u0026#39;, age:18 }) let obj = reactive({ a:{ b:{ c:666 } } }) // 方法 function changeName(){ person.name += \u0026#39;~\u0026#39; } function changeAge(){ person.age += 1 } function changePerson(){ Object.assign(person,{name:\u0026#39;李四\u0026#39;,age:80}) } function test(){ obj.a.b.c = 888 } // 监视，情况三：监视【reactive】定义的【对象类型】数据，且默认是开启深度监视的 watch(person,(newValue,oldValue)=\u0026gt;{ console.log(\u0026#39;person变化了\u0026#39;,newValue,oldValue) }) watch(obj,(newValue,oldValue)=\u0026gt;{ console.log(\u0026#39;Obj变化了\u0026#39;,newValue,oldValue) }) \u0026lt;/script\u0026gt; * 情况四 监视ref或reactive定义的【对象类型】数据中的某个属性，注意点如下：\n若该属性值不是【对象类型】，需要写成函数形式。 若该属性值是依然是【对象类型】，可直接编，也可写成函数，建议写成函数。 结论：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;情况四：监视【ref】或【reactive】定义的【对象类型】数据中的某个属性\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;姓名：{{ person.name }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{ person.age }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;汽车：{{ person.car.c1 }}、{{ person.car.c2 }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;修改年龄\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeC1\u0026#34;\u0026gt;修改第一台车\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeC2\u0026#34;\u0026gt;修改第二台车\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeCar\u0026#34;\u0026gt;修改整个车\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {reactive,watch} from \u0026#39;vue\u0026#39; // 数据 let person = reactive({ name:\u0026#39;张三\u0026#39;, age:18, car:{ c1:\u0026#39;奔驰\u0026#39;, c2:\u0026#39;宝马\u0026#39; } }) // 方法 function changeName(){ person.name += \u0026#39;~\u0026#39; } function changeAge(){ person.age += 1 } function changeC1(){ person.car.c1 = \u0026#39;奥迪\u0026#39; } function changeC2(){ person.car.c2 = \u0026#39;大众\u0026#39; } function changeCar(){ person.car = {c1:\u0026#39;雅迪\u0026#39;,c2:\u0026#39;爱玛\u0026#39;} } // 监视，情况四：监视响应式对象中的某个属性，且该属性是基本类型的，要写成函数式 // () =\u0026gt; { return person.name } 简写为 () =\u0026gt; person.name /* watch(()=\u0026gt; person.name,(newValue,oldValue)=\u0026gt;{ console.log(\u0026#39;person.name变化了\u0026#39;,newValue,oldValue) }) */ // 监视，情况四：监视响应式对象中的某个属性，且该属性是对象类型的，可以直接写，也能写函数，更推荐写函数 // 直接写 person.car 只能监视对象内的属性变化，无法监视整个对象(即对象的地址)的变化 // 写 () =\u0026gt; person.car 只能监视整个对象的变化，无法监视对象内属性的变化 // 写 () =\u0026gt; person.car 时，在后面加一个{ deep: true } 就可以同时监视两者的变化了 watch(()=\u0026gt;person.car,(newValue,oldValue)=\u0026gt;{ console.log(\u0026#39;person.car变化了\u0026#39;,newValue,oldValue) },{deep:true}) \u0026lt;/script\u0026gt; * 情况五 监视上述的多个数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;情况五：监视上述的多个数据\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;姓名：{{ person.name }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{ person.age }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;汽车：{{ person.car.c1 }}、{{ person.car.c2 }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;修改年龄\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeC1\u0026#34;\u0026gt;修改第一台车\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeC2\u0026#34;\u0026gt;修改第二台车\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeCar\u0026#34;\u0026gt;修改整个车\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {reactive,watch} from \u0026#39;vue\u0026#39; // 数据 let person = reactive({ name:\u0026#39;张三\u0026#39;, age:18, car:{ c1:\u0026#39;奔驰\u0026#39;, c2:\u0026#39;宝马\u0026#39; } }) // 方法 function changeName(){ person.name += \u0026#39;~\u0026#39; } function changeAge(){ person.age += 1 } function changeC1(){ person.car.c1 = \u0026#39;奥迪\u0026#39; } function changeC2(){ person.car.c2 = \u0026#39;大众\u0026#39; } function changeCar(){ person.car = {c1:\u0026#39;雅迪\u0026#39;,c2:\u0026#39;爱玛\u0026#39;} } // 监视，情况五：监视上述的多个数据 watch([()=\u0026gt;person.name,person.car],(newValue,oldValue)=\u0026gt;{ console.log(\u0026#39;person.car变化了\u0026#39;,newValue,oldValue) },{deep:true}) \u0026lt;/script\u0026gt; 3.10. 【watchEffect】 官网：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。\nwatch对比watchEffect\n都能监听响应式数据的变化，不同的是监听数据变化的方式不同\nwatch：要明确指出监视的数据\nwatchEffect：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;需求：水温达到50℃，或水位达到20cm，则联系服务器\u0026lt;/h1\u0026gt; \u0026lt;h2 id=\u0026#34;demo\u0026#34;\u0026gt;水温：{{temp}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;水位：{{height}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changePrice\u0026#34;\u0026gt;水温+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeSum\u0026#34;\u0026gt;水位+10\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {ref,watch,watchEffect} from \u0026#39;vue\u0026#39; // 数据 let temp = ref(0) let height = ref(0) // 方法 function changePrice(){ temp.value += 10 } function changeSum(){ height.value += 1 } // 用watch实现，需要明确的指出要监视：temp、height watch([temp,height],(value)=\u0026gt;{ // 从value中获取最新的temp值、height值 const [newTemp,newHeight] = value // 室温达到50℃，或水位达到20cm，立刻联系服务器 if(newTemp \u0026gt;= 50 || newHeight \u0026gt;= 20){ console.log(\u0026#39;联系服务器\u0026#39;) } }) // 用watchEffect实现，不用 const stopWtach = watchEffect(()=\u0026gt;{ // 室温达到50℃，或水位达到20cm，立刻联系服务器 if(temp.value \u0026gt;= 50 || height.value \u0026gt;= 20){ console.log(document.getElementById(\u0026#39;demo\u0026#39;)?.innerText) console.log(\u0026#39;联系服务器\u0026#39;) } // 水温达到100，或水位达到50，取消监视 if(temp.value === 100 || height.value === 50){ console.log(\u0026#39;清理了\u0026#39;) stopWtach() } }) \u0026lt;/script\u0026gt; 3.11. 【标签的 ref 属性】 作用：用于注册模板引用。\n用在普通DOM标签上，获取的是DOM节点。\n用在组件标签上，获取的是组件实例对象。\n用在普通DOM标签上：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h1 ref=\u0026#34;title1\u0026#34;\u0026gt;尚硅谷\u0026lt;/h1\u0026gt; \u0026lt;h2 ref=\u0026#34;title2\u0026#34;\u0026gt;前端\u0026lt;/h2\u0026gt; \u0026lt;h3 ref=\u0026#34;title3\u0026#34;\u0026gt;Vue\u0026lt;/h3\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref=\u0026#34;inpt\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;button @click=\u0026#34;showLog\u0026#34;\u0026gt;点我打印内容\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {ref} from \u0026#39;vue\u0026#39; let title1 = ref() let title2 = ref() let title3 = ref() function showLog(){ // 通过id获取元素 const t1 = document.getElementById(\u0026#39;title1\u0026#39;) // 打印内容 console.log((t1 as HTMLElement).innerText) console.log((\u0026lt;HTMLElement\u0026gt;t1).innerText) console.log(t1?.innerText) /************************************/ // 通过ref获取元素 console.log(title1.value) console.log(title2.value) console.log(title3.value) } \u0026lt;/script\u0026gt; 用在组件标签上：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;!-- 父组件App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;!-- 给子组件绑定ref --\u0026gt; \u0026lt;Person ref=\u0026#34;ren\u0026#34;/\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;测试\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;App\u0026#34;\u0026gt; import Person from \u0026#39;./components/Person.vue\u0026#39; import {ref} from \u0026#39;vue\u0026#39; // 创建一个ref对象来存储子组件的引用 let ren = ref() function test(){ console.log(ren.value.name) console.log(ren.value.age) } \u0026lt;/script\u0026gt; \u0026lt;!-- 子组件Person.vue中要使用defineExpose暴露内容 --\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {ref,defineExpose} from \u0026#39;vue\u0026#39; // 数据 let name = ref(\u0026#39;张三\u0026#39;) let age = ref(18) /****************************/ /****************************/ // 使用defineExpose将组件中的数据交给外部，只有这样外部才能查看 defineExpose({name,age}) \u0026lt;/script\u0026gt; 3.12. 【props】 1 2 3 4 5 6 7 8 9 // 定义一个接口，限制每个Person对象的格式 export interface PersonInter { id:string, name:string, age:number } // 定义一个自定义类型Persons export type Persons = Array\u0026lt;PersonInter\u0026gt; App.vue中代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;!-- 值的前面加:后，编译器就会把这个值当表达式处理 --\u0026gt; \u0026lt;!-- 注：ref前面无需加:，编译器默认就会当表达式处理 --\u0026gt; \u0026lt;Person :list=\u0026#34;persons\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;App\u0026#34;\u0026gt; import Person from \u0026#39;./components/Person.vue\u0026#39; import {reactive} from \u0026#39;vue\u0026#39; import {type Persons} from \u0026#39;./types\u0026#39; // 效果同let persons:Persons = reactive(...)，不过推荐下面的写法 let persons = reactive\u0026lt;Persons\u0026gt;([ {id:\u0026#39;e98219e12\u0026#39;,name:\u0026#39;张三\u0026#39;,age:18}, {id:\u0026#39;e98219e13\u0026#39;,name:\u0026#39;李四\u0026#39;,age:19}, {id:\u0026#39;e98219e14\u0026#39;,name:\u0026#39;王五\u0026#39;,age:20} ]) \u0026lt;/script\u0026gt; Person.vue中代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in list\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{item.name}}--{{item.age}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {defineProps, withDefaults} from \u0026#39;vue\u0026#39; // @ 默认表示src目录，可以在 tsconfig.json 中设置 import {type PersonInter} from \u0026#39;@/types\u0026#39; // 第一种写法：仅接收 // 会把数组内的所有数据转化为一个对象，所以调用的时候就是props.属性 // const props = defineProps([\u0026#39;list\u0026#39;]) // 第二种写法：接收+限制类型 // defineProps\u0026lt;{list:Persons}\u0026gt;() // 第三种写法：接收+限制类型+指定默认值+限制必要性 // ?:就是可传可不传 let props = withDefaults(defineProps\u0026lt;{list?:Persons}\u0026gt;(),{ // 必须写成函数返回值的形式 list:()=\u0026gt;[{id:\u0026#39;asdasg01\u0026#39;,name:\u0026#39;小猪佩奇\u0026#39;,age:18}] }) console.log(props) \u0026lt;/script\u0026gt; 3.13. 【生命周期】 概念：Vue组件实例在创建时要经历一系列的初始化步骤，在此过程中Vue会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子\n规律：\n生命周期整体分为四个阶段，分别是：创建、挂载、更新、销毁，每个阶段都有两个钩子，一前一后。\nVue2的生命周期\n创建阶段：beforeCreate、created\n挂载阶段：beforeMount、mounted\n更新阶段：beforeUpdate、updated\n销毁阶段：beforeDestroy、destroyed\nVue3的生命周期\n创建阶段：setup\n挂载阶段：onBeforeMount、onMounted\n更新阶段：onBeforeUpdate、onUpdated\n卸载阶段：onBeforeUnmount、onUnmounted\n常用的钩子：onMounted(挂载完毕)、onUpdated(更新完毕)、onBeforeUnmount(卸载之前)\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;当前求和为：{{ sum }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeSum\u0026#34;\u0026gt;点我sum+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- vue3写法 --\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import { ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted } from \u0026#39;vue\u0026#39; // 数据 let sum = ref(0) // 方法 function changeSum() { sum.value += 1 } console.log(\u0026#39;setup\u0026#39;) // 生命周期钩子 onBeforeMount(()=\u0026gt;{ console.log(\u0026#39;挂载之前\u0026#39;) }) onMounted(()=\u0026gt;{ console.log(\u0026#39;挂载完毕\u0026#39;) }) onBeforeUpdate(()=\u0026gt;{ console.log(\u0026#39;更新之前\u0026#39;) }) onUpdated(()=\u0026gt;{ console.log(\u0026#39;更新完毕\u0026#39;) }) onBeforeUnmount(()=\u0026gt;{ console.log(\u0026#39;卸载之前\u0026#39;) }) onUnmounted(()=\u0026gt;{ console.log(\u0026#39;卸载完毕\u0026#39;) }) \u0026lt;/script\u0026gt; 3.14. 【自定义hook】 什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装，类似于vue2.x中的mixin。\n自定义hook的优势：复用代码, 让setup中的逻辑更清楚易懂。\n示例代码：\nuseSum.ts中内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import {ref,onMounted} from \u0026#39;vue\u0026#39; // 将所有script内容包在一个函数里 export default function(){ let sum = ref(0) const increment = ()=\u0026gt;{ sum.value += 1 } const decrement = ()=\u0026gt;{ sum.value -= 1 } onMounted(()=\u0026gt;{ increment() }) //向外部暴露数据 return {sum,increment,decrement} }\tuseDog.ts中内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import {reactive,onMounted} from \u0026#39;vue\u0026#39; import axios,{AxiosError} from \u0026#39;axios\u0026#39; // 将所有script内容包在一个函数里 export default function(){ let dogList = reactive\u0026lt;string[]\u0026gt;([]) // 方法 async function getDog(){ try { // 发请求 let {data} = await axios.get(\u0026#39;https://dog.ceo/api/breed/pembroke/./assets/random\u0026#39;) // 维护数据 dogList.push(data.message) } catch (error) { // 处理错误 const err = \u0026lt;AxiosError\u0026gt;error console.log(err.message) } } // 挂载钩子 onMounted(()=\u0026gt;{ getDog() }) //向外部暴露数据 return {dogList,getDog} } 组件中具体使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;当前求和为：{{sum}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;点我+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;decrement\u0026#34;\u0026gt;点我-1\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;img v-for=\u0026#34;(u,index) in dogList.urlList\u0026#34; :key=\u0026#34;index\u0026#34; :src=\u0026#34;(u as string)\u0026#34;\u0026gt; \u0026lt;span v-show=\u0026#34;dogList.isLoading\u0026#34;\u0026gt;加载中......\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;button @click=\u0026#34;getDog\u0026#34;\u0026gt;再来一只狗\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent} from \u0026#39;vue\u0026#39; export default defineComponent({ name:\u0026#39;App\u0026#39;, }) \u0026lt;/script\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import useSum from \u0026#39;./hooks/useSum\u0026#39; import useDog from \u0026#39;./hooks/useDog\u0026#39; // 进行解构 let {sum,increment,decrement} = useSum() let {dogList,getDog} = useDog() \u0026lt;/script\u0026gt; 4. 路由 4.1. 【对路由的理解】 4.2. 【基本切换效果】 Vue3中要使用vue-router的最新版本，目前是4版本。\n安装命令npm i vue-router\n路由配置文件代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import {createRouter,createWebHistory} from \u0026#39;vue-router\u0026#39; import Home from \u0026#39;@/pages/Home.vue\u0026#39; import News from \u0026#39;@/pages/News.vue\u0026#39; import About from \u0026#39;@/pages/About.vue\u0026#39; const router = createRouter({ history:createWebHistory(), routes:[ { path:\u0026#39;/home\u0026#39;, component:Home }, { path:\u0026#39;/about\u0026#39;, component:About } ] }) export default router main.ts代码如下：\n1 2 3 4 5 import router from \u0026#39;./router/index\u0026#39; // 使用路由器 app.use(router) // 挂载整个应用到app容器中 app.mount(\u0026#39;#app\u0026#39;) App.vue代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;title\u0026#34;\u0026gt;Vue路由测试\u0026lt;/h2\u0026gt; \u0026lt;!-- 导航区 --\u0026gt; \u0026lt;div class=\u0026#34;navigate\u0026#34;\u0026gt; \u0026lt;!-- active-class会自动检测，当切换到对应页面时自动激活 --\u0026gt; \u0026lt;RouterLink to=\u0026#34;/home\u0026#34; active-class=\u0026#34;active\u0026#34;\u0026gt;首页\u0026lt;/RouterLink\u0026gt; \u0026lt;RouterLink to=\u0026#34;/news\u0026#34; active-class=\u0026#34;active\u0026#34;\u0026gt;新闻\u0026lt;/RouterLink\u0026gt; \u0026lt;RouterLink to=\u0026#34;/about\u0026#34; active-class=\u0026#34;active\u0026#34;\u0026gt;关于\u0026lt;/RouterLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 展示区 --\u0026gt; \u0026lt;div class=\u0026#34;main-content\u0026#34;\u0026gt; \u0026lt;RouterView\u0026gt;\u0026lt;/RouterView\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;App\u0026#34;\u0026gt; import {RouterLink,RouterView} from \u0026#39;vue-router\u0026#39; \u0026lt;/script\u0026gt; 4.3. 【两个注意点】 路由组件通常存放在pages 或 views文件夹，一般组件通常存放在components文件夹。\n路由组件：靠路由的规则渲染出来的\n一般组件：亲手写标签出来的\n通过点击导航，视觉效果上“消失” 了的路由组件，默认是被卸载掉的，需要的时候再去挂载。\n4.4.【路由器工作模式】 history模式\n优点：URL更加美观，不带有#，更接近传统的网站URL。\n缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有404错误。\n1 2 3 4 const router = createRouter({ history:createWebHistory(), //history模式 /******/ }) hash模式\n优点：兼容性更好，因为不需要服务器端处理路径。\n缺点：URL带有#不太美观，且在SEO优化方面相对较差。\n1 2 3 4 const router = createRouter({ history:createWebHashHistory(), //hash模式 /******/ }) 4.5. 【to的两种写法】 1 2 3 4 5 \u0026lt;!-- 第一种：to的字符串写法 --\u0026gt; \u0026lt;router-link active-class=\u0026#34;active\u0026#34; to=\u0026#34;/home\u0026#34;\u0026gt;主页\u0026lt;/router-link\u0026gt; \u0026lt;!-- 第二种：to的对象写法 --\u0026gt; \u0026lt;router-link active-class=\u0026#34;active\u0026#34; :to=\u0026#34;{path:\u0026#39;/home\u0026#39;}\u0026#34;\u0026gt;Home\u0026lt;/router-link\u0026gt; 4.6. 【命名路由】 作用：可以简化路由跳转及传参（后面就讲）。\n给路由规则命名：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 routes:[ { name:\u0026#39;zhuye\u0026#39;, path:\u0026#39;/home\u0026#39;, component:Home }, { name:\u0026#39;xinwen\u0026#39;, path:\u0026#39;/news\u0026#39;, component:News, }, { name:\u0026#39;guanyu\u0026#39;, path:\u0026#39;/about\u0026#39;, component:About } ] 跳转路由：\n1 2 3 4 5 \u0026lt;!--简化前：需要写完整的路径（to的字符串写法） --\u0026gt; \u0026lt;router-link to=\u0026#34;/news/detail\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; \u0026lt;!--简化后：直接通过名字跳转（to的对象写法配合name属性） --\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;guanyu\u0026#39;}\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; 4.7. 【嵌套路由】 编写News的子路由：Detail.vue\n配置路由规则，使用children配置项：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const router = createRouter({ history:createWebHistory(), routes:[ { name:\u0026#39;zhuye\u0026#39;, path:\u0026#39;/home\u0026#39;, component:Home }, { name:\u0026#39;xinwen\u0026#39;, path:\u0026#39;/news\u0026#39;, component:News, children:[ // 子集路由 { name:\u0026#39;xiang\u0026#39;, path:\u0026#39;detail\u0026#39;, // 子集不用写/ component:Detail } ] }, { name:\u0026#39;guanyu\u0026#39;, path:\u0026#39;/about\u0026#39;, component:About } ] }) export default router 跳转路由（记得要加完整路径）：\n1 2 3 \u0026lt;router-link to=\u0026#34;/news/detail\u0026#34;\u0026gt;xxxx\u0026lt;/router-link\u0026gt; \u0026lt;!-- 或 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{path:\u0026#39;/news/detail\u0026#39;}\u0026#34;\u0026gt;xxxx\u0026lt;/router-link\u0026gt; 记得去Home组件中预留一个\u0026lt;router-view\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;news\u0026#34;\u0026gt; \u0026lt;nav class=\u0026#34;news-list\u0026#34;\u0026gt; \u0026lt;RouterLink v-for=\u0026#34;news in newsList\u0026#34; :key=\u0026#34;news.id\u0026#34; :to=\u0026#34;{path:\u0026#39;/news/detail\u0026#39;}\u0026#34;\u0026gt; {{news.name}} \u0026lt;/RouterLink\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;div class=\u0026#34;news-detail\u0026#34;\u0026gt; \u0026lt;RouterView/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 4.8. 【路由传参】 query参数 传递参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!-- 跳转并携带query参数（to的字符串写法） --\u0026gt; \u0026lt;router-link to=\u0026#34;/news/detail?a=1\u0026amp;b=2\u0026amp;content=欢迎你\u0026#34;\u0026gt; 跳转 \u0026lt;/router-link\u0026gt; \u0026lt;!-- 跳转并携带query参数（to的对象写法） --\u0026gt; \u0026lt;RouterLink :to=\u0026#34;{ //name:\u0026#39;xiang\u0026#39;, //用name也可以跳转 path:\u0026#39;/news/detail\u0026#39;, query:{ id:news.id, title:news.title, content:news.content } }\u0026#34; \u0026gt; {{news.title}} \u0026lt;/RouterLink\u0026gt; 接收参数：\n1 2 3 4 import {useRoute} from \u0026#39;vue-router\u0026#39; const route = useRoute() // 打印query参数 console.log(route.query) params参数 传递参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!-- 跳转并携带params参数（to的字符串写法） --\u0026gt; \u0026lt;RouterLink :to=\u0026#34;`/news/detail/001/新闻001/内容001`\u0026#34;\u0026gt;{{news.title}}\u0026lt;/RouterLink\u0026gt; \u0026lt;!-- 跳转并携带params参数（to的对象写法） --\u0026gt; \u0026lt;RouterLink :to=\u0026#34;{ name:\u0026#39;xiang\u0026#39;, // 用name跳转，不能用path params:{ id:news.id, title:news.title, content:news.title } }\u0026#34; \u0026gt; {{news.title}} \u0026lt;/RouterLink\u0026gt; 接收参数：\n1 2 3 4 import {useRoute} from \u0026#39;vue-router\u0026#39; const route = useRoute() // 打印params参数 console.log(route.params) 备注1：传递params参数时，若使用to的对象写法，必须使用name配置项，不能用path。\n备注2：传递params参数时，需要提前在规则中占位。\n4.9. 【路由的props配置】 作用：让路由组件更方便的收到参数（可以将路由参数作为props传给组件）\n备注：在src/router/index.ts中编写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { name:\u0026#39;xiang\u0026#39;, path:\u0026#39;detail/:id/:title/:content\u0026#39;, component:Detail, // props的对象写法，作用：把对象中的每一组key-value作为props传给Detail组件 // props:{a:1,b:2,c:3}, // props的布尔值写法，作用：把收到了每一组params参数，作为props传给Detail组件 // props:true // props的函数写法，作用：把返回的对象中每一组key-value作为props传给Detail组件 props(route){ return route.query } } 4.10. 【 replace属性】 作用：控制路由跳转时操作浏览器历史记录的模式。\n浏览器的历史记录有两种写入方式：分别为push和replace：\npush是追加历史记录（默认值）。 replace是替换当前记录。 开启replace模式：\n1 \u0026lt;RouterLink replace .......\u0026gt;News\u0026lt;/RouterLink\u0026gt; push和replace区别演示：\n4.11. 【编程式导航】 编程式路由导航：脱离实现路由跳转\n路由组件的两个重要的属性：route和router变成了两个hooks\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import {useRoute,useRouter} from \u0026#39;vue-router\u0026#39; const route = useRoute() const router = useRouter() console.log(route.query) console.log(route.parmas) console.log(router.push) console.log(router.replace) // 挂载后3秒自动跳转 /* onMounted(() =\u0026gt; { setTimeout(() =\u0026gt; { router.push(\u0026#39;/news\u0026#39;) }, 3000) }) */ // to的写法同样适用于router.push()的括号内 简单演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;news\u0026#34;\u0026gt; \u0026lt;!-- 导航区 --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;news in newsList\u0026#34; :key=\u0026#34;news.id\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;showNewsDetail(news)\u0026#34;\u0026gt;查看新闻\u0026lt;/button\u0026gt; \u0026lt;RouterLink :to=\u0026#34;{ name:\u0026#39;xiang\u0026#39;, query:{ id:news.id, title:news.title, content:news.content } }\u0026#34; \u0026gt; {{news.title}} \u0026lt;/RouterLink\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- 展示区 --\u0026gt; \u0026lt;div class=\u0026#34;news-content\u0026#34;\u0026gt; \u0026lt;RouterView\u0026gt;\u0026lt;/RouterView\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;News\u0026#34;\u0026gt; import {reactive} from \u0026#39;vue\u0026#39; import {RouterView,RouterLink,useRouter} from \u0026#39;vue-router\u0026#39; const newsList = reactive([ {id:\u0026#39;asfdtrfay01\u0026#39;,title:\u0026#39;很好的抗癌食物\u0026#39;,content:\u0026#39;西蓝花\u0026#39;}, {id:\u0026#39;asfdtrfay02\u0026#39;,title:\u0026#39;如何一夜暴富\u0026#39;,content:\u0026#39;学IT\u0026#39;}, {id:\u0026#39;asfdtrfay03\u0026#39;,title:\u0026#39;震惊，万万没想到\u0026#39;,content:\u0026#39;明天是周一\u0026#39;}, {id:\u0026#39;asfdtrfay04\u0026#39;,title:\u0026#39;好消息！好消息！\u0026#39;,content:\u0026#39;快过年了\u0026#39;} ]) const router = useRouter() interface NewsInter { id:string, title:string, content:string } function showNewsDetail(news:NewsInter){ router.replace({ name:\u0026#39;xiang\u0026#39;, query:{ id:news.id, title:news.title, content:news.content } }) } \u0026lt;/script\u0026gt; 4.12. 【重定向】 作用：将特定的路径，重新定向到已有路由。\n具体编码：\n1 2 3 4 { path:\u0026#39;/\u0026#39;, redirect:\u0026#39;/about\u0026#39; } 5. pinia 5.1【准备一个效果】 src/App.vue\n1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;Count/\u0026gt; \u0026lt;br\u0026gt; \u0026lt;LoveTalk/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;App\u0026#34;\u0026gt; import Count from \u0026#39;./components/Count.vue\u0026#39; import LoveTalk from \u0026#39;./components/LoveTalk.vue\u0026#39; \u0026lt;/script\u0026gt; src/components/Count.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;count\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;当前求和为：{{ sum }}\u0026lt;/h2\u0026gt; \u0026lt;select v-model.number=\u0026#34;n\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;1\u0026#34;\u0026gt;1\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;2\u0026#34;\u0026gt;2\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;3\u0026#34;\u0026gt;3\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;button @click=\u0026#34;add\u0026#34;\u0026gt;加\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;minus\u0026#34;\u0026gt;减\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Count\u0026#34;\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; // 数据 let sum = ref(1) // 当前求和 let n = ref(1) // 用户选择的数字 // 方法 function add(){ sum.value += n.value } function minus(){ sum.value -= n.value } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .count { background-color: skyblue; padding: 10px; border-radius: 10px; box-shadow: 0 0 10px; } select,button { margin: 0 5px; height: 25px; } \u0026lt;/style\u0026gt; src/components/LoveTalk.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;talk\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;getLoveTalk\u0026#34;\u0026gt;获取一句土味情话\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;talk in talkList\u0026#34; :key=\u0026#34;talk.id\u0026#34;\u0026gt;{{talk.title}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;LoveTalk\u0026#34;\u0026gt; import {reactive} from \u0026#39;vue\u0026#39; import axios from \u0026#34;axios\u0026#34;; // npm i axios import {nanoid} from \u0026#39;nanoid\u0026#39; // npm i nanoid // 数据 let talkList = reactive([ {id:\u0026#39;ftrfasdf01\u0026#39;,title:\u0026#39;今天你有点怪，哪里怪？怪好看的！\u0026#39;}, {id:\u0026#39;ftrfasdf02\u0026#39;,title:\u0026#39;草莓、蓝莓、蔓越莓，今天想我了没？\u0026#39;}, {id:\u0026#39;ftrfasdf03\u0026#39;,title:\u0026#39;心里给你留了一块地，我的死心塌地\u0026#39;} ]) // 方法 async function getLoveTalk(){ // 发请求，下面这行的写法是：连续解构赋值+重命名 // 从await axios中解构出 data，再从 data 中解构出 content，再将 content 重命名为 title let {data:{content:title}} = await axios.get(\u0026#39;https://api.uomg.com/api/rand.qinghua?format=json\u0026#39;) // 把请求回来的字符串，包装成一个对象 // title 的 key 和 value 相同，可简写 let obj = {id:nanoid(),title} // 放到数组中 talkList.unshift(obj) } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .talk { background-color: orange; padding: 10px; border-radius: 10px; box-shadow: 0 0 10px; } \u0026lt;/style\u0026gt; 5.2【搭建 pinia 环境】 第一步：npm install pinia\n第二步：操作src/main.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; /* 引入createPinia，用于创建pinia */ import { createPinia } from \u0026#39;pinia\u0026#39; /* 创建pinia */ const pinia = createPinia() const app = createApp(App) /* 使用插件 */{} app.use(pinia) app.mount(\u0026#39;#app\u0026#39;) 此时开发者工具中已经有了pinia选项\n5.3【存储+读取数据】 Store是一个保存：状态、业务逻辑 的实体，每个组件都可以读取、写入它。\n它有三个概念：state、getter、action，相当于组件中的： data、 computed 和 methods。\n具体编码：src/store/count.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 引入defineStore用于创建store import {defineStore} from \u0026#39;pinia\u0026#39; // 定义并暴露一个store export const useCountStore = defineStore(\u0026#39;count\u0026#39;,{ // 动作 actions:{}, // 状态 state(){ return { sum:6 } }, // 计算 getters:{} }) 具体编码：src/store/talk.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 引入defineStore用于创建store import {defineStore} from \u0026#39;pinia\u0026#39; // 定义并暴露一个store export const useTalkStore = defineStore(\u0026#39;talk\u0026#39;,{ // 动作 actions:{}, // 状态 state(){ return { talkList:[ {id:\u0026#39;yuysada01\u0026#39;,content:\u0026#39;你今天有点怪，哪里怪？怪好看的！\u0026#39;}, {id:\u0026#39;yuysada02\u0026#39;,content:\u0026#39;草莓、蓝莓、蔓越莓，你想我了没？\u0026#39;}, {id:\u0026#39;yuysada03\u0026#39;,content:\u0026#39;心里给你留了一块地，我的死心塌地\u0026#39;} ] } }, // 计算 getters:{} }) 组件中使用state中的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;当前求和为：{{ sumStore.sum }}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Count\u0026#34;\u0026gt; // 引入对应的useXxxxxStore\timport {useSumStore} from \u0026#39;@/store/sum\u0026#39; // 调用useXxxxxStore得到对应的store const sumStore = useSumStore() // 查看sumStore是什么 console.log(sumStore) // reactive 对象中的 ref 对象的value值可以直接调用 console.log(sumStore.sum) // 此时的sum不需要.value \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;talk in talkStore.talkList\u0026#34; :key=\u0026#34;talk.id\u0026#34;\u0026gt; {{ talk.content }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Count\u0026#34;\u0026gt; import axios from \u0026#39;axios\u0026#39; import {useTalkStore} from \u0026#39;@/store/talk\u0026#39; const talkStore = useTalkStore() \u0026lt;/script\u0026gt; 5.4.【修改数据】(三种方式) 第一种修改方式，直接修改\n1 countStore.sum = 666 第二种修改方式：批量修改\n1 2 3 4 countStore.$patch({ sum:999, school:\u0026#39;atguigu\u0026#39; }) 第三种修改方式：借助action修改（action中可以编写一些业务逻辑）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { defineStore } from \u0026#39;pinia\u0026#39; export const useCountStore = defineStore(\u0026#39;count\u0026#39;, { /*************/ actions: { //加 increment(value:number) { console.log(this) // 打印结果见下图 // this 是当前的store，即useCountStore if (this.sum \u0026lt; 10) { //操作countStore中的sum this.sum += value } }, //减 decrement(value:number){ if(this.sum \u0026gt; 1){ this.sum -= value } } }, /*************/ }) 下图为console.log(this)的结果\n组件中调用action即可\n1 2 3 4 5 // 使用countStore const countStore = useCountStore() // 调用对应action countStore.increment(n.value) 5.5.【storeToRefs】 借助storeToRefs将store中的数据转为ref对象，方便在模板中使用。 注意：pinia提供的storeToRefs只会将数据做转换，而Vue的toRefs会转换store中数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;count\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;当前求和为：{{sum}}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Count\u0026#34;\u0026gt; import { useCountStore } from \u0026#39;@/store/count\u0026#39; /* 引入storeToRefs */ import { storeToRefs } from \u0026#39;pinia\u0026#39; /* 得到countStore */ const countStore = useCountStore() /* 使用storeToRefs转换countStore，随后解构 */ // storeToRefs只会关注store中的数据，不会对方法进行ref包裹 const {sum} = storeToRefs(countStore) \u0026lt;/script\u0026gt; toRefs与storeToRefs对比：\n5.6.【getters】 概念：当state中的数据，需要经过处理后再使用时，可以使用getters配置。\n追加getters配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 引入defineStore用于创建store import {defineStore} from \u0026#39;pinia\u0026#39; // 定义并暴露一个store export const useCountStore = defineStore(\u0026#39;count\u0026#39;,{ // 动作 actions:{ /************/ }, // 状态 state(){ return { sum:1, school:\u0026#39;atguigu\u0026#39; } }, // 计算 getters:{ /* bigSum(state) { return state.sum * 10 } 下行为简写形式 */ // getters有一个名为bigSum的属性，属性值为箭头函数state =\u0026gt; state.sum * 10，函数返回值是number类型 bigSum:(state):number =\u0026gt; state.sum *10, upperSchool():string { return this.school.toUpperCase() } } }) 组件中读取数据：\n1 2 const {increment,decrement} = countStore let {sum,school,bigSum,upperSchool} = storeToRefs(countStore) 5.7.【$subscribe】 通过 store 的 $subscribe() 方法侦听 state 及其变化\n1 2 3 4 5 6 // mutate为本次修改的信息，state为数据 talkStore.$subscribe((mutate,state)=\u0026gt;{ console.log(\u0026#39;LoveTalk\u0026#39;,mutate,state) // localStorage.setItem：在浏览器本地存储 localStorage.setItem(\u0026#39;talk\u0026#39;,JSON.stringify(talkList.value)) }) 5.8. 【store组合式写法】 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import {defineStore} from \u0026#39;pinia\u0026#39; import axios from \u0026#39;axios\u0026#39; import {nanoid} from \u0026#39;nanoid\u0026#39; import {reactive} from \u0026#39;vue\u0026#39; export const useTalkStore = defineStore(\u0026#39;talk\u0026#39;,()=\u0026gt;{ // talkList就是state const talkList = reactive( // JSON.parse只能对字符串使用，所以将localStorage.getItem(\u0026#39;talkList\u0026#39;)断言为字符串 // 当本地浏览器数据为空时，JSON.parse(localStorage.getItem(\u0026#39;talkList\u0026#39;) as string)为null，考虑到null的情况，要用条件或来设置前者为null时的处理方式 JSON.parse(localStorage.getItem(\u0026#39;talkList\u0026#39;) as string) || [] ) // getATalk函数相当于action async function getATalk(){ // 发请求，下面这行的写法是：连续解构赋值+重命名 let {data:{content:title}} = await axios.get(\u0026#39;https://api.uomg.com/api/rand.qinghua?format=json\u0026#39;) // 把请求回来的字符串，包装成一个对象 let obj = {id:nanoid(),title} // 放到数组中 talkList.unshift(obj) } return {talkList,getATalk} }) 6. 组件通信 Vue3组件通信和Vue2的区别：\n移出事件总线，使用mitt代替。 vuex换成了pinia。 把.sync优化到了v-model里面了。 把$listeners所有的东西，合并到$attrs中了。 $children被砍掉了。 常见搭配形式：\n6.1. 【props】 概述：props是使用频率最高的一种通信方式，常用与 ：父 ↔ 子。\n若 父传子：属性值是非函数。 若 子传父：属性值是函数。 父组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;父组件，\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;我的车：{{ car }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;儿子给的玩具：{{ toy }}\u0026lt;/h4\u0026gt; \u0026lt;Child :car=\u0026#34;car\u0026#34; :getToy=\u0026#34;getToy\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Father\u0026#34;\u0026gt; import Child from \u0026#39;./Child.vue\u0026#39; import { ref } from \u0026#34;vue\u0026#34;; // 数据 const car = ref(\u0026#39;奔驰\u0026#39;) const toy = ref() // 方法 function getToy(value:string){ toy.value = value } \u0026lt;/script\u0026gt; 子组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;子组件\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;我的玩具：{{ toy }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;父给我的车：{{ car }}\u0026lt;/h4\u0026gt; \u0026lt;button @click=\u0026#34;getToy(toy)\u0026#34;\u0026gt;玩具给父亲\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Child\u0026#34;\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; const toy = ref(\u0026#39;奥特曼\u0026#39;) defineProps([\u0026#39;car\u0026#39;,\u0026#39;getToy\u0026#39;]) \u0026lt;/script\u0026gt; 6.2. 【自定义事件】 概述：自定义事件常用于：子 =\u0026gt; 父。 注意区分好：原生事件、自定义事件。 原生事件： 事件名是特定的（click、mosueenter等等） 事件对象$event: 是包含事件相关信息的对象（pageX、pageY、target、keyCode） 自定义事件： 事件名是任意名称 事件对象$event: 是调用emit时所提供的数据，可以是任意类型！！！ 示例：\n1 2 3 4 5 6 7 \u0026lt;!--在父组件中，给子组件绑定自定义事件：--\u0026gt; \u0026lt;Child @send-toy=\u0026#34;toy = $event\u0026#34;/\u0026gt; \u0026lt;!--注意区分原生事件与自定义事件中的$event--\u0026gt; \u0026lt;!--原生事件中的$event表示事件对象 --\u0026gt; \u0026lt;!--自定义事件中的$event表示自定义事件传递的参数 --\u0026gt; \u0026lt;button @click=\u0026#34;toy = $event\u0026#34;\u0026gt;测试\u0026lt;/button\u0026gt; 1 2 //子组件中，触发事件： this.$emit(\u0026#39;send-toy\u0026#39;, 传给$event的具体数据) 案例演示\n6.3. 【mitt】 概述：与消息订阅与发布（pubsub）功能类似，可以实现任意组件间通信。\n安装mitt\n1 npm i mitt 新建文件：src\\utils\\emitter.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 引入mitt import mitt from \u0026#34;mitt\u0026#34;; // 调用mitt得到emitter，emitter能绑定事件、触发事件 const emitter = mitt() /* // 绑定事件 emitter.on(\u0026#39;abc\u0026#39;,(value)=\u0026gt;{ console.log(\u0026#39;abc事件被触发\u0026#39;,value) }) emitter.on(\u0026#39;xyz\u0026#39;,(value)=\u0026gt;{ console.log(\u0026#39;xyz事件被触发\u0026#39;,value) }) setInterval(() =\u0026gt; { // 触发事件 emitter.emit(\u0026#39;abc\u0026#39;,666) emitter.emit(\u0026#39;xyz\u0026#39;,777) }, 1000); setTimeout(() =\u0026gt; { // 解绑abc事件 emitter.off(\u0026#39;abc\u0026#39;) // 清理事件，一次性解绑所有事件 emitter.all.clear() }, 3000); */ // 创建并暴露mitt export default emitter 接收数据的组件中：绑定事件、同时在销毁前解绑事件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import emitter from \u0026#34;@/utils/emitter\u0026#34;; import { onUnmounted } from \u0026#34;vue\u0026#34;; // 绑定事件 emitter.on(\u0026#39;send-toy\u0026#39;,(value)=\u0026gt;{ console.log(\u0026#39;send-toy事件被触发\u0026#39;,value) }) // 在组件卸载时解绑事件 onUnmounted(()=\u0026gt;{ // 解绑事件 emitter.off(\u0026#39;send-toy\u0026#39;) }) 【第三步】：提供数据的组件，在合适的时候触发事件\n1 2 3 4 5 6 import emitter from \u0026#34;@/utils/emitter\u0026#34;; function sendToy(){ // 触发事件 emitter.emit(\u0026#39;send-toy\u0026#39;,toy.value) } 注意这个重要的内置关系，总线依赖着这个内置关系\n6.4.【v-model】 概述：实现 父↔子 之间相互通信。\n前序知识 —— v-model的本质\n1 2 3 4 5 6 7 8 9 \u0026lt;!-- 使用v-model指令 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;userName\u0026#34;\u0026gt; \u0026lt;!-- v-model的本质是下面这行代码 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;userName\u0026#34; @input=\u0026#34;userName =(\u0026lt;HTMLInputElement\u0026gt;$event.target).value\u0026#34; \u0026gt; 组件标签上的v-model的本质：:moldeValue ＋ update:modelValue事件。\n1 2 3 4 5 \u0026lt;!-- 组件标签上使用v-model指令 --\u0026gt; \u0026lt;AtguiguInput v-model=\u0026#34;userName\u0026#34;/\u0026gt; \u0026lt;!-- 组件标签上v-model的本质 --\u0026gt; \u0026lt;AtguiguInput :modelValue=\u0026#34;userName\u0026#34; @update:model-value=\u0026#34;userName = $event\u0026#34;/\u0026gt; AtguiguInput组件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;!--将接收的value值赋给input元素的value属性，目的是：为了呈现数据 --\u0026gt; \u0026lt;!--给input元素绑定原生input事件，触发input事件时，进而触发update:model-value事件--\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;modelValue\u0026#34; @input=\u0026#34;emit(\u0026#39;update:model-value\u0026#39;,$event.target.value)\u0026#34; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;AtguiguInput\u0026#34;\u0026gt; // 接收props defineProps([\u0026#39;modelValue\u0026#39;]) // 声明事件 const emit = defineEmits([\u0026#39;update:model-value\u0026#39;]) \u0026lt;/script\u0026gt; 也可以更换value，例如改成abc\n1 2 3 4 5 \u0026lt;!-- 也可以更换value，例如改成abc--\u0026gt; \u0026lt;AtguiguInput v-model:abc=\u0026#34;userName\u0026#34;/\u0026gt; \u0026lt;!-- 上面代码的本质如下 --\u0026gt; \u0026lt;AtguiguInput :abc=\u0026#34;userName\u0026#34; @update:abc=\u0026#34;userName = $event\u0026#34;/\u0026gt; AtguiguInput组件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;abc\u0026#34; @input=\u0026#34;emit(\u0026#39;update:abc\u0026#39;,$event.target.value)\u0026#34; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;AtguiguInput\u0026#34;\u0026gt; // 接收props defineProps([\u0026#39;abc\u0026#39;]) // 声明事件 const emit = defineEmits([\u0026#39;update:abc\u0026#39;]) \u0026lt;/script\u0026gt; 如果value可以更换，那么就可以在组件标签上多次使用v-model\n1 \u0026lt;AtguiguInput v-model:abc=\u0026#34;userName\u0026#34; v-model:xyz=\u0026#34;password\u0026#34;/\u0026gt; 6.5.【$attrs 】 概述：$attrs用于实现当前组件的父组件，向当前组件的子组件通信（祖→孙）。\n具体说明：$attrs是一个对象，包含所有父组件传入的标签属性。\n注意：$attrs会自动排除props中声明的属性(可以认为声明过的 props 被子组件自己“消费”了)\n父组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;父组件\u0026lt;/h3\u0026gt; \u0026lt;!-- v-bind=\u0026#34;{x:100,y:200}\u0026#34; 相当于 :x=\u0026#39;100\u0026#39; :y=\u0026#39;200\u0026#39; --\u0026gt; \u0026lt;Child :a=\u0026#34;a\u0026#34; :b=\u0026#34;b\u0026#34; :c=\u0026#34;c\u0026#34; :d=\u0026#34;d\u0026#34; v-bind=\u0026#34;{x:100,y:200}\u0026#34; :updateA=\u0026#34;updateA\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Father\u0026#34;\u0026gt; import Child from \u0026#39;./Child.vue\u0026#39; import { ref } from \u0026#34;vue\u0026#34;; let a = ref(1) let b = ref(2) let c = ref(3) let d = ref(4) function updateA(value){ a.value = value } \u0026lt;/script\u0026gt; 子组件：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;子组件\u0026lt;/h3\u0026gt; \u0026lt;!-- 把父组件传入的数据再传给子组件 --\u0026gt; \u0026lt;GrandChild v-bind=\u0026#34;$attrs\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Child\u0026#34;\u0026gt; import GrandChild from \u0026#39;./GrandChild.vue\u0026#39; \u0026lt;/script\u0026gt; 孙组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;grand-child\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;孙组件\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;a：{{ a }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;b：{{ b }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;c：{{ c }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;d：{{ d }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;x：{{ x }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;y：{{ y }}\u0026lt;/h4\u0026gt; \u0026lt;button @click=\u0026#34;updateA(666)\u0026#34;\u0026gt;点我更新A\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;GrandChild\u0026#34;\u0026gt; defineProps([\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;updateA\u0026#39;]) \u0026lt;/script\u0026gt; 6.6. 【$refs、$parent】 概述：\n$refs用于 ：父→子。 $parent用于：子→父。 原理如下：\n属性 说明 $refs 值为对象，包含所有被ref属性标识的DOM元素或组件实例。 $parent 值为对象，当前组件的父组件实例对象。 $refs 示例：\nFather.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;父组件\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;getAllChild($refs)\u0026#34;\u0026gt;让所有孩子的书变多\u0026lt;/button\u0026gt; \u0026lt;Child1 ref=\u0026#34;c1\u0026#34;/\u0026gt; \u0026lt;Child2 ref=\u0026#34;c2\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Father\u0026#34;\u0026gt; import Child1 from \u0026#39;./Child1.vue\u0026#39; import Child2 from \u0026#39;./Child2.vue\u0026#39; import { ref } from \u0026#34;vue\u0026#34;; let c1 = ref() let c2 = ref() // 方法 // refs:{[key:string]:any} 表示，refs是一个对象，对象中有为字符串类型的属性，属性存储的类型可能是任何类型（实在搞不懂直接用any） function getAllChild(refs:{[key:string]:any}){ console.log(refs) // 打印结果见下图 for (let key in refs){ refs[key].book += 3 } } \u0026lt;/script\u0026gt; Child1.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;child1\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;子组件1\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;玩具：{{ toy }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;书籍：{{ book }} 本\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Child1\u0026#34;\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; // 数据 let toy = ref(\u0026#39;奥特曼\u0026#39;) let book = ref(3) // 把数据交给外部 defineExpose({toy,book}) \u0026lt;/script\u0026gt; Child2.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;child2\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;子组件2\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;电脑：{{ computer }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;书籍：{{ book }} 本\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Child2\u0026#34;\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; // 数据 let computer = ref(\u0026#39;联想\u0026#39;) let book = ref(6) // 把数据交给外部 defineExpose({computer,book}) \u0026lt;/script\u0026gt; $parent 示例：\nFather.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;父组件\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;房产：{{ house }}\u0026lt;/h4\u0026gt; \u0026lt;Child/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Father\u0026#34;\u0026gt; import Child from \u0026#39;./Child.vue\u0026#39; import { ref } from \u0026#34;vue\u0026#34;; // 数据 let house = ref(4) // 向外部提供数据 defineExpose({house}) \u0026lt;/script\u0026gt; Child.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;子组件\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;minusHouse($parent)\u0026#34;\u0026gt;干掉父亲的一套房产\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Child\u0026#34;\u0026gt; // 方法 function minusHouse(parent:any){ console.log(parent) // 打印结果见下图 // parent是响应式对象，所以调用其中的响应式属性house不用.value parent.house -= 1 } \u0026lt;/script\u0026gt; 6.7. 【provide、inject】 概述：实现祖孙组件直接通信\n具体使用：\n在祖先组件中通过provide配置向后代组件提供数据\nprovide(数据名称,数据的值)\n在后代组件中通过inject配置来声明接收数据\ninject(接收的属性名[,该属性的默认值])\n具体编码：\n【第一步】父组件中，使用provide提供数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;父组件\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;资产：{{ money }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;汽车：{{ car }}\u0026lt;/h4\u0026gt; \u0026lt;button @click=\u0026#34;money += 1\u0026#34;\u0026gt;资产+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;car.price += 1\u0026#34;\u0026gt;汽车价格+1\u0026lt;/button\u0026gt; \u0026lt;Child/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Father\u0026#34;\u0026gt; import Child from \u0026#39;./Child.vue\u0026#39; import { ref,reactive,provide } from \u0026#34;vue\u0026#34;; // 数据 let money = ref(100) let car = reactive({ brand:\u0026#39;奔驰\u0026#39;, price:100 }) // 用于更新money的方法 function updateMoney(value:number){ money.value += value } // 向后代提供数据 provide(\u0026#39;moneyContext\u0026#39;,{money,updateMoney}) provide(\u0026#39;car\u0026#39;,car) \u0026lt;/script\u0026gt; 注意：子组件中不用编写任何东西，是不受到任何打扰的\n【第二步】孙组件中使用inject配置项接受数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;grand-child\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;我是孙组件\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;资产：{{ money }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;汽车：{{ car }}\u0026lt;/h4\u0026gt; \u0026lt;button @click=\u0026#34;updateMoney(6)\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;GrandChild\u0026#34;\u0026gt; import { inject } from \u0026#39;vue\u0026#39;; // 注入数据 // 写一个默认值告诉编译器，moneyContext内有money和updateMoney let {money,updateMoney} = inject(\u0026#39;moneyContext\u0026#39;,{money:0,updateMoney:(x:number)=\u0026gt;{}}) let car = inject(\u0026#39;car\u0026#39;) \u0026lt;/script\u0026gt; 6.8. 【pinia】 参考之前pinia部分的讲解\n6.9. 【slot】 1. 默认插槽 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 父组件中： \u0026lt;Category title=\u0026#34;今日热门游戏\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;g in games\u0026#34; :key=\u0026#34;g.id\u0026#34;\u0026gt;{{ g.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/Category\u0026gt; 子组件中： \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;{{ title }}\u0026lt;/h3\u0026gt; \u0026lt;!-- 默认插槽，会把父组件使用该组件时，写在组件中间的内容放进默认插槽中 --\u0026gt; \u0026lt;slot\u0026gt; \u0026lt;!-- 内部可以写默认内容，父组件不传内容时，就会显示默认内容；父组件传值时就不显示 --\u0026gt; \u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 完整：\nFather.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;父组件\u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;Category title=\u0026#34;热门游戏列表\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;g in games\u0026#34; :key=\u0026#34;g.id\u0026#34;\u0026gt;{{ g.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/Category\u0026gt; \u0026lt;Category title=\u0026#34;今日美食城市\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/Category\u0026gt; \u0026lt;Category title=\u0026#34;今日影视推荐\u0026#34;\u0026gt; \u0026lt;video :src=\u0026#34;videoUrl\u0026#34; controls\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;/Category\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Father\u0026#34;\u0026gt; import Category from \u0026#39;./Category.vue\u0026#39; import { ref,reactive } from \u0026#34;vue\u0026#34;; let games = reactive([ {id:\u0026#39;asgytdfats01\u0026#39;,name:\u0026#39;英雄联盟\u0026#39;}, {id:\u0026#39;asgytdfats02\u0026#39;,name:\u0026#39;王者农药\u0026#39;}, {id:\u0026#39;asgytdfats03\u0026#39;,name:\u0026#39;红色警戒\u0026#39;}, {id:\u0026#39;asgytdfats04\u0026#39;,name:\u0026#39;斗罗大陆\u0026#39;} ]) let imgUrl = ref(\u0026#39;https://z1.ax1x.com/2023/11/19/piNxLo4.jpg\u0026#39;) let videoUrl = ref(\u0026#39;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .father { background-color: rgb(165, 164, 164); padding: 20px; border-radius: 10px; } .content { display: flex; justify-content: space-evenly; } img,video { width: 100%; } \u0026lt;/style\u0026gt; Category.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;category\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{title}}\u0026lt;/h2\u0026gt; \u0026lt;slot\u0026gt;默认内容\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Category\u0026#34;\u0026gt; defineProps([\u0026#39;title\u0026#39;]) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .category { background-color: skyblue; border-radius: 10px; box-shadow: 0 0 10px; padding: 10px; width: 200px; height: 300px; } h2 { background-color: orange; text-align: center; font-size: 20px; font-weight: 800; } \u0026lt;/style\u0026gt; 2. 具名插槽 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 父组件中： \u0026lt;!-- v-slot:也可以写在组件(Category)上，不过不如写在template上灵活 --\u0026gt; \u0026lt;Category title=\u0026#34;今日热门游戏\u0026#34;\u0026gt; \u0026lt;template v-slot:s1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;g in games\u0026#34; :key=\u0026#34;g.id\u0026#34;\u0026gt;{{ g.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- #s2等效于v-slot:s2 --\u0026gt; \u0026lt;template #s2\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;更多\u0026lt;/a\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Category\u0026gt; 子组件中： \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;{{ title }}\u0026lt;/h3\u0026gt; \u0026lt;slot name=\u0026#34;s1\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;s2\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 默认插槽其实也有名字，名字为default\n3. 作用域插槽 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（新闻数据在News组件中，但使用数据所遍历出来的结构由App组件决定）\n具体编码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 父组件中： \u0026lt;!-- 用v-slot接收子组件传来的对象 --\u0026gt; \u0026lt;Game v-slot=\u0026#34;params\u0026#34;\u0026gt; \u0026lt;!-- 作用域插槽也可以有名字，不写名字其实名字就是默认的default --\u0026gt; \u0026lt;!-- \u0026lt;Game v-slot:default=\u0026#34;params\u0026#34;\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;Game #default=\u0026#34;params\u0026#34;\u0026gt; --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;g in params.games\u0026#34; :key=\u0026#34;g.id\u0026#34;\u0026gt;{{ g.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/Game\u0026gt; \u0026lt;!-- 直接解构出games，省得每次都params.games --\u0026gt; \u0026lt;!-- 数据存放在子组件，但具体结构有父组件决定 --\u0026gt; \u0026lt;Game v-slot=\u0026#34;{games}\u0026#34;\u0026gt; \u0026lt;h3 v-for=\u0026#34;g in games\u0026#34; :key=\u0026#34;g.id\u0026#34;\u0026gt;{{ g.name }}\u0026lt;/h3\u0026gt; \u0026lt;/Game\u0026gt; 子组件中： \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;category\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;今日游戏榜单\u0026lt;/h2\u0026gt; \u0026lt;!-- 会把所有props打包成一个对象，传给父组件 --\u0026gt; \u0026lt;slot :games=\u0026#34;games\u0026#34; a=\u0026#34;哈哈\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Category\u0026#34;\u0026gt; import {reactive} from \u0026#39;vue\u0026#39; let games = reactive([ {id:\u0026#39;asgdytsa01\u0026#39;,name:\u0026#39;英雄联盟\u0026#39;}, {id:\u0026#39;asgdytsa02\u0026#39;,name:\u0026#39;王者荣耀\u0026#39;}, {id:\u0026#39;asgdytsa03\u0026#39;,name:\u0026#39;红色警戒\u0026#39;}, {id:\u0026#39;asgdytsa04\u0026#39;,name:\u0026#39;斗罗大陆\u0026#39;} ]) \u0026lt;/script\u0026gt; 作用域插槽也可以有名字，可与具名插槽结合\n7. 其它 API 7.1.【shallowRef 与 shallowReactive 】 shallowRef 作用：创建一个响应式数据，但只对顶层属性进行响应式处理。\n用法：\n1 let myVar = shallowRef(initialValue); 特点：只跟踪引用值的变化，不关心值内部的属性变化。\n即只有myVar.value这一层是响应式的，myVar.value.xxx开始的数据就不是响应式的了\nshallowReactive 作用：创建一个浅层响应式对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的\n用法：\n1 const myObj = shallowReactive({ ... }); 特点：对象的顶层属性是响应式的，但嵌套对象的属性不是。\n总结 通过使用 shallowRef() 和 shallowReactive() 来绕开深度响应。浅层式 API 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理，避免了对每一个内部属性做响应式所带来的性能成本，这使得属性的访问变得更快，可提升性能。\n注意 不是响应式不代表数据不变，当页面中有响应式数据发生了变化，这些被修改的非响应式数据也会跟着变化\n上图页面代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;求和为：{{ sum }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;名字为：{{ person.name }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄为：{{ person.age }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;汽车为：{{ car }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeSum\u0026#34;\u0026gt;sum+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;修改年龄\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changePerson\u0026#34;\u0026gt;修改整个人\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;|\u0026lt;/span\u0026gt; \u0026lt;button @click=\u0026#34;changeBrand\u0026#34;\u0026gt;修改品牌\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeColor\u0026#34;\u0026gt;修改颜色\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeEngine\u0026#34;\u0026gt;修改发动机\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;App\u0026#34;\u0026gt; import { ref,reactive,shallowRef,shallowReactive } from \u0026#39;vue\u0026#39; let sum = shallowRef(0) let person = shallowRef({ name:\u0026#39;张三\u0026#39;, age:18 }) let car = shallowReactive({ barnd:\u0026#39;奔驰\u0026#39;, options:{ color:\u0026#39;红色\u0026#39;, engine:\u0026#39;V8\u0026#39; } }) function changeSum (){ sum.value += 1 } function changeName (){ person.value.name = \u0026#39;李四\u0026#39; } function changeAge (){ person.value.age += 1 } function changePerson (){ person.value = {name:\u0026#39;tony\u0026#39;,age:100} } /* ****************** */ function changeBrand(){ car.barnd = \u0026#39;宝马\u0026#39; } function changeColor(){ car.options.color = \u0026#39;紫色\u0026#39; } function changeEngine(){ car.options.engine = \u0026#39;V12\u0026#39; } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .app { background-color: #ddd; border-radius: 10px; box-shadow: 0 0 10px; padding: 10px; } button { margin:0 5px; } \u0026lt;/style\u0026gt; 7.2.【readonly 与 shallowReadonly】 readonly 作用：用于创建一个对象的深只读副本。\n用法：\n1 2 const original = reactive({ ... }); const readOnlyCopy = readonly(original); 特点：\n对象的所有嵌套属性都将变为只读。 任何尝试修改这个对象的操作都会被阻止（在开发模式下，还会在控制台中发出警告）。 应用场景：\n创建不可变的状态快照。 保护全局状态或配置不被修改。 shallowReadonly 作用：与 readonly 类似，但只作用于对象的顶层属性。\n用法：\n1 2 const original = reactive({ ... }); const shallowReadOnlyCopy = shallowReadonly(original); 特点：\n只将对象的顶层属性设置为只读，对象内部的嵌套属性仍然是可变的。\n适用于只需保护对象顶层属性的场景。\n7.3.【toRaw 与 markRaw】 toRaw 作用：用于获取一个响应式对象的原始对象， toRaw 返回的对象不再是响应式的，不会触发视图更新。\n官网描述：这是一个可以用于临时读取而不引起代理访问/跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。\n何时使用？ —— 在需要将响应式对象传递给非 Vue 的库或外部系统时，使用 toRaw 可以确保它们收到的是普通对象\n具体编码：\n1 2 3 4 5 6 7 8 9 10 import { reactive,toRaw,markRaw,isReactive } from \u0026#34;vue\u0026#34;; /* toRaw */ // 响应式对象 let person = reactive({name:\u0026#39;tony\u0026#39;,age:18}) // 原始对象 let rawPerson = toRaw(person) console.log(isReactive(person)) console.log(isReactive(rawPerson)) 注：修改rawPerson的内容时，虽然页面不会更新，但原person的内容也会被修改，等到其他响应式数据更新时，person被修改的内容也会同步在页面更新\nmarkRaw 作用：标记一个对象，使其永远不会变成响应式的。\n例如使用mockjs时，为了防止误把mockjs变为响应式对象，可以使用 markRaw 去标记mockjs\n编码：\n1 2 3 4 5 6 7 8 9 10 11 /* markRaw */ let citys = markRaw([ {id:\u0026#39;asdda01\u0026#39;,name:\u0026#39;北京\u0026#39;}, {id:\u0026#39;asdda02\u0026#39;,name:\u0026#39;上海\u0026#39;}, {id:\u0026#39;asdda03\u0026#39;,name:\u0026#39;天津\u0026#39;}, {id:\u0026#39;asdda04\u0026#39;,name:\u0026#39;重庆\u0026#39;} ]) // 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了 let citys2 = reactive(citys) console.log(isReactive(citys)) console.log(isReactive(citys2)) 7.4.【customRef】 作用：创建一个自定义的ref，并对其依赖项跟踪和更新触发进行逻辑控制。\n实现防抖效果（useSumRef.ts）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import {customRef } from \u0026#34;vue\u0026#34;; export default function(initValue:string,delay:number){ let msg = customRef((track,trigger)=\u0026gt;{ // track-跟踪，trigger-触发，底层代码自动传递 let timer:number return { // msg被读取时，get()会被调用 get(){ track() // 告诉Vue数据msg很重要，要对msg持续关注，一旦变化就更新 return initValue }, // msg被修改时，set()会被调用 set(value){ clearTimeout(timer) // 防止快速输入时出bug timer = setTimeout(() =\u0026gt; { initValue = value trigger() //通知Vue数据msg变化了 }, delay); } } }) return {msg} } 组件中使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{ msg }}\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;msg\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;App\u0026#34;\u0026gt; import {ref} from \u0026#39;vue\u0026#39; import useMsgRef from \u0026#39;./useMsgRef\u0026#39; // 使用Vue提供的默认ref定义响应式数据，数据一变，页面就更新 // let msg = ref(\u0026#39;你好\u0026#39;) // 使用useMsgRef来定义一个响应式数据且有延迟效果 let {msg} = useMsgRef(\u0026#39;你好\u0026#39;,2000) \u0026lt;/script\u0026gt; 8. Vue3新组件 8.1. 【Teleport】 什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。 1 2 3 4 5 6 7 8 9 \u0026lt;!-- to=\u0026#39;\u0026#39;中写的是选择器，如类选择器.xxx，id选择器#xxx等等 --\u0026gt; \u0026lt;!-- 将teleport包裹的内容传送到页面的body中 --\u0026gt; \u0026lt;teleport to=\u0026#39;body\u0026#39; \u0026gt; \u0026lt;div class=\u0026#34;modal\u0026#34; v-show=\u0026#34;isShow\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;我是一个弹窗\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;我是弹窗中的一些内容\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;isShow = false\u0026#34;\u0026gt;关闭弹窗\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/teleport\u0026gt; 8.2. 【Suspense】 等待异步组件时渲染一些额外内容，让应用有更好的用户体验 使用步骤： 异步引入组件 使用Suspense包裹组件，并配置好default 与 fallback 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;我是App组件\u0026lt;/h3\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;!-- 异步任务完成时 --\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;Child/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 异步任务还在执行时，因为在异步任务完成前，子组件会消失，所以可以写点提示 --\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;h3\u0026gt;加载中.......\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;App\u0026#34;\u0026gt; import { defineAsyncComponent,Suspense } from \u0026#34;vue\u0026#34;; const Child = defineAsyncComponent(()=\u0026gt;import(\u0026#39;./Child.vue\u0026#39;)) \u0026lt;/script\u0026gt; 不使用Suspense时，若子组件有异步任务，该子组件会直接消失\n8.3.【全局API转移到应用对象】 app.component\n在src/main.ts中\n1 2 3 4 5 6 7 8 9 10 11 import {createApp} from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import Hello from \u0026#39;./Hello.vue\u0026#39; // 创建应用 const app = createApp(App) // 让Hello组件成为全局组件，即使用时无需再引入 app.component(\u0026#39;Hello\u0026#39;,Hello) // 挂载应用 app.mount(\u0026#39;#app\u0026#39;) app.config\n在src/main.ts中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import {createApp} from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; // 创建应用 const app = createApp(App) // 设置全局属性 x ，x 的值为 99 app.config.globalProperties.x = 99 // 若只有上一行代码，x可以使用，但使用时会报红，加上下面的代码即可解决报红 declare module \u0026#39;vue\u0026#39; { interface ComponentCustomProperties { // 上面都是固定内容，此处写自定义全局属性的数据类型 x:number } } // 挂载应用 app.mount(\u0026#39;#app\u0026#39;) app.directive\n在src/main.ts中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import {createApp} from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; // 创建应用 const app = createApp(App) // 注册全局指令 app.directive(\u0026#39;beauty\u0026#39;,(element,{value})=\u0026gt;{ element.innerText += value element.style.color = \u0026#39;green\u0026#39; element.style.backgroundColor = \u0026#39;yellow\u0026#39; }) // 挂载应用 app.mount(\u0026#39;#app\u0026#39;) 使用演示：\napp.mount\n挂载app\napp.unmount\n卸载app\n1 2 3 4 5 6 7 8 9 10 11 12 import {createApp} from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; // 创建应用 const app = createApp(App) // 挂载应用 app.mount(\u0026#39;#app\u0026#39;) // 2秒后卸载应用 setTimeout(() =\u0026gt; { app.unmount() }, 2000); app.use\n安装插件\n8.4.【其他（Vue3的非兼容性改变）】 过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from。\nkeyCode 作为 v-on 修饰符的支持。\nv-model 指令在组件上的使用已经被重新设计，替换掉了 v-bind.sync。\nv-if 和 v-for 在同一个元素身上使用时的优先级发生了变化。\n移除了$on、$off 和 $once 实例方法。\n移除了过滤器 filter。\n移除了$children 实例 propert。\n\u0026hellip;\u0026hellip;（详情见官网，在Vue3迁移指南中）\n9. Element Plus 9.1. 安装与导入 ElementPlus官网：https://element-plus.org/zh-CN/\n安装：npm install element-plus --save\n完整引入：\n在src/main.ts中如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { createApp } from \u0026#39;vue\u0026#39; // 整体导入 ElementPlus 组件库 // 导入ElementPlus组件库的所有模块和功能 import ElementPlus from \u0026#39;element-plus\u0026#39; // 导入ElementPlus组件库所需的全局CSS样式 import \u0026#39;element-plus/dist/index.css\u0026#39; import App from \u0026#39;./App.vue\u0026#39; const app = createApp(App) // 使用ElementPlus app.use(ElementPlus) app.mount(\u0026#39;#app\u0026#39;) ","date":"2024-03-27T13:52:16+08:00","permalink":"https://IAmYuanyu.github.io/p/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","title":"Vue3快速上手"}]